{"version":3,"sources":["webpack:///build.js","webpack:///webpack/bootstrap e946022fb1078770e2fa","webpack:///./src/Main.vue","webpack:///./~/vue/dist/vue.esm.js","webpack:///Main.vue","webpack:///./src/main.js","webpack:///./src/Main.vue?b681","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/tone/build/Tone.js","webpack:///./~/vue-loader/lib/component-normalizer.js","webpack:///./src/Main.vue?482a","webpack:///./src/Main.vue?d2db","webpack:///./~/vue-style-loader/lib/addStylesClient.js","webpack:///./~/vue-style-loader/lib/listToStyles.js","webpack:///(webpack)/buildin/global.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","injectStyle","ssrContext","Component","__webpack_exports__","global","isUndef","v","undefined","isDef","isTrue","isFalse","isPrimitive","isObject","obj","isPlainObject","_toString","isRegExp","isValidArrayIndex","val","parseFloat","Math","floor","isFinite","toString","JSON","stringify","String","toNumber","isNaN","makeMap","str","expectsLowerCase","map","create","list","split","length","toLowerCase","remove","arr","item","index","indexOf","splice","hasOwn","key","cached","fn","cache","bind","ctx","boundFn","a","arguments","apply","_length","toArray","start","ret","Array","extend","to","_from","toObject","res","noop","b","looseEqual","isObjectA","isObjectB","isArrayA","isArray","isArrayB","every","e","keysA","keys","keysB","looseIndexOf","once","called","this","isReserved","charCodeAt","def","writable","parsePath","path","bailRE","test","segments","handleError","err","vm","info","config","errorHandler","inBrowser","console","error","isNative","Ctor","pushTarget","_target","Dep","target","targetStack","push","popTarget","pop","protoAugment","src","__proto__","copyAugment","observe","asRootData","ob","__ob__","Observer","observerState","shouldConvert","isServerRendering","isExtensible","_isVue","vmCount","defineReactive$$1","customSetter","shallow","dep","getOwnPropertyDescriptor","setter","set","childOb","depend","dependArray","newVal","notify","max","del","mergeData","from","toVal","fromVal","mergeDataOrFn","parentVal","childVal","instanceData","defaultData","mergeHook","concat","mergeAssets","normalizeProps","options","props","camelize","type","normalizeInject","inject","normalized","normalizeDirectives","dirs","directives","update","mergeOptions","parent","child","mergeField","strat","strats","defaultStrat","extendsFrom","extends","mixins","resolveAsset","id","warnMissing","assets","camelizedId","PascalCaseId","capitalize","validateProp","propOptions","propsData","prop","absent","isType","Boolean","hyphenate","getPropDefaultValue","prevShouldConvert","default","$options","_props","getType","match","len","createTextVNode","VNode","cloneVNode","vnode","cloned","tag","data","children","text","elm","context","componentOptions","asyncFactory","ns","isStatic","isComment","isCloned","cloneVNodes","vnodes","createFnInvoker","fns","invoker","arguments$1","slice","updateListeners","on","oldOn","add","remove$$1","cur","old","event","normalizeEvent","capture","passive","mergeVNodeHook","hookKey","hook","wrappedHook","oldHook","merged","extractPropsFromVNodeData","attrs","altKey","checkProp","hash","preserve","simpleNormalizeChildren","normalizeChildren","normalizeArrayChildren","isTextNode","node","nestedIndex","last","_isVList","ensureCtor","comp","base","createAsyncPlaceholder","factory","createEmptyVNode","asyncMeta","resolveAsyncComponent","baseCtor","errorComp","resolved","loading","loadingComp","contexts","sync","forceRender","$forceUpdate","resolve","reject","reason","then","component","delay","setTimeout","timeout","getFirstComponentChild","initEvents","_events","_hasHookEvent","listeners","_parentListeners","updateComponentListeners","once$$1","$once","$on","remove$1","$off","oldListeners","resolveSlots","slots","defaultSlot","functionalContext","slot","isWhitespace","resolveScopedSlots","initLifecycle","abstract","$parent","$children","$root","$refs","_watcher","_inactive","_directInactive","_isMounted","_isDestroyed","_isBeingDestroyed","mountComponent","el","hydrating","$el","render","callHook","updateComponent","_update","_render","Watcher","$vnode","updateChildComponent","parentVnode","renderChildren","hasChildren","_renderChildren","scopedSlots","$scopedSlots","emptyObject","_parentVnode","_vnode","$attrs","$listeners","propKeys","_propKeys","$slots","isInInactiveTree","activateChildComponent","direct","deactivateChildComponent","handlers","j","$emit","resetSchedulerState","queue","activatedChildren","has","waiting","flushing","flushSchedulerQueue","watcher","sort","run","activatedQueue","updatedQueue","callActivatedHooks","callUpdatedHooks","devtools","emit","queueActivatedComponent","queueWatcher","nextTick","traverse","seenObjects","clear","_traverse","seen","isA","depId","proxy","sourceKey","sharedPropertyDefinition","initState","_watchers","opts","initProps","methods","initMethods","initData","_data","computed","initComputed","watch","nativeWatch","initWatch","propsOptions","isRoot","getData","watchers","_computedWatchers","userDef","computedWatcherOptions","defineComputed","createComputedGetter","dirty","evaluate","handler","createWatcher","keyOrFn","$watch","initProvide","provide","_provided","initInjections","result","resolveInject","forEach","hasSymbol","Reflect","ownKeys","provideKey","source","createFunctionalComponent","mergeProps","_context","h","createElement","injections","functionalOptions","createComponent","_base","cid","resolveConstructorOptions","model","transformModel","functional","nativeOn","mergeHooks","createComponentInstanceForVnode","parentElm","refElm","vnodeComponentOptions","_isComponent","_componentTag","_parentElm","_refElm","inlineTemplate","staticRenderFns","hooksToMerge","fromParent","ours","componentVNodeHooks","mergeHook$1","one","two","callback","normalizationType","alwaysNormalize","ALWAYS_NORMALIZE","_createElement","is","SIMPLE_NORMALIZE","getTagNamespace","isReservedTag","parsePlatformTagName","applyNS","renderList","renderSlot","fallback","bindObject","scopedSlotFn","slotNodes","resolveFilter","identity","checkKeyCodes","eventKeyCode","builtInAlias","keyCodes","bindObjectProps","asProp","isSync","isReservedAttribute","mustUseProp","domProps","$event","renderStatic","isInFor","tree","_staticTrees","_renderProxy","markStatic","markOnce","isOnce","markStaticNode","bindObjectListeners","existing","initRender","renderContext","_c","$createElement","parentData","initInternalComponent","constructor","super","superOptions","modifiedOptions","resolveModifiedOptions","extendOptions","components","modified","latest","extended","sealed","sealedOptions","dedupe","Vue$3","_init","initUse","Vue","use","plugin","installedPlugins","_installedPlugins","args","unshift","install","initMixin$1","mixin","initExtend","Super","SuperId","cachedCtors","_Ctor","Sub","initProps$1","initComputed$1","ASSET_TYPES","Comp","initAssetRegisters","definition","getComponentName","matches","pattern","pruneCache","current","filter","cachedNode","pruneCacheEntry","componentInstance","$destroy","genClassForVnode","parentNode","childNode","mergeClassData","renderClass","staticClass","class","dynamicClass","stringifyClass","stringifyArray","stringifyObject","stringified","isSVG","isUnknownElement","unknownElementCache","document","window","HTMLUnknownElement","HTMLElement","query","selected","querySelector","createElement$1","tagName","multiple","setAttribute","createElementNS","namespace","namespaceMap","createTextNode","createComment","insertBefore","newNode","referenceNode","removeChild","appendChild","nextSibling","setTextContent","textContent","registerRef","isRemoval","ref","refs","refInFor","sameVnode","sameInputType","isAsyncPlaceholder","createKeyToOldIdx","beginIdx","endIdx","updateDirectives","oldVnode","oldDir","dir","isCreate","emptyNode","isDestroy","oldDirs","normalizeDirectives$1","newDirs","dirsWithInsert","dirsWithPostpatch","oldValue","callHook$1","componentUpdated","inserted","callInsert","modifiers","emptyModifiers","getRawDirName","rawName","join","updateAttrs","inheritAttrs","oldAttrs","setAttr","isIE9","isXlink","removeAttributeNS","xlinkNS","getXlinkProp","isEnumeratedAttr","removeAttribute","isBooleanAttr","isFalsyAttrValue","setAttributeNS","updateClass","oldData","cls","transitionClass","_transitionClasses","_prevClass","parseFilters","exp","pushFilter","filters","lastFilterIndex","trim","prev","expression","inSingle","inDouble","inTemplateString","inRegex","curly","square","paren","charAt","validDivisionCharRE","wrapFilter","baseWarn","msg","pluckModuleFunction","_","addProp","addAttr","addDirective","arg","addHandler","important","warn","events","native","nativeEvents","newHandler","getBindingAttr","getStatic","dynamicValue","getAndRemoveAttr","staticValue","attrsMap","attrsList","genComponentModel","number","valueExpression","assignment","genAssignmentCode","modelRs","parseModel","idx","index$1","expressionPos","expressionEndPos","lastIndexOf","eof","chr","next","isStringStart","parseString","parseBracket","substring","inBracket","stringQuote","_warn","warn$1","genSelect","genCheckboxModel","genRadioModel","genDefaultModel","valueBinding","trueValueBinding","falseValueBinding","CHECKBOX_RADIO_TOKEN","selectedVal","code","lazy","needCompositionGuard","RANGE_TOKEN","normalizeEvents","isIE","isChrome","add$1","oldHandler","target$1","ev","remove$2","addEventListener","supportsPassive","removeEventListener","updateDOMListeners","updateDOMProps","oldProps","_value","strCur","shouldUpdateValue","checkVal","composing","isDirty","isInputChanged","notInFocus","activeElement","_vModifiers","normalizeStyleData","style","normalizeStyleBinding","staticStyle","bindingStyle","parseStyleText","getStyle","checkChild","styleData","updateStyle","oldStaticStyle","oldStyleBinding","normalizedStyle","oldStyle","newStyle","setProp","addClass","classList","getAttribute","removeClass","tar","replace","resolveTransition","def$$1","css","autoCssTransition","nextFrame","raf","addTransitionClass","transitionClasses","removeTransitionClass","whenTransitionEnds","expectedType","cb","getTransitionInfo","propCount","TRANSITION","transitionEndEvent","animationEndEvent","ended","end","onEnd","styles","getComputedStyle","transitionDelays","transitionProp","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationProp","animationDurations","animationTimeout","ANIMATION","hasTransform","transformRE","delays","durations","toMs","Number","enter","toggleDisplay","_leaveCb","cancelled","transition","_enterCb","nodeType","enterClass","enterToClass","enterActiveClass","appearClass","appearToClass","appearActiveClass","beforeEnter","afterEnter","enterCancelled","beforeAppear","appear","afterAppear","appearCancelled","duration","activeInstance","transitionNode","isAppear","isRootInsert","startClass","activeClass","toClass","beforeEnterHook","enterHook","afterEnterHook","enterCancelledHook","explicitEnterDuration","expectsCSS","userWantsControl","getHookArgumentsLength","show","pendingNode","_pending","isValidDuration","leave","rm","performLeave","beforeLeave","leaveClass","leaveActiveClass","leaveToClass","explicitLeaveDuration","afterLeave","leaveCancelled","delayLeave","invokerFns","_enter","setSelected","binding","isMultiple","option","getValue","selectedIndex","onCompositionStart","onCompositionEnd","trigger","createEvent","initEvent","dispatchEvent","locateNode","getRealChild","compOptions","extractTransitionData","key$1","placeholder","rawChild","hasParentTransition","isSameChild","oldChild","callPendingCbs","_moveCb","recordPosition","newPos","getBoundingClientRect","applyTranslation","oldPos","pos","dx","left","dy","top","moved","transform","WebkitTransform","transitionDuration","parseText","delimiters","tagRE","buildRegex","defaultTagRE","tokens","lastIndex","exec","transformNode","classBinding","genData","transformNode$1","styleBinding","genData$1","html","decodeAttr","shouldDecodeNewlines","re","encodedAttrWithNewLines","encodedAttr","decodingMap","parseHTML","advance","parseEndTag","lowerCasedTagName","stack","lowerCasedTag","lastTag","expectHTML","isUnaryTag$$1","isUnaryTag","no","canBeLeftOpenTag$$1","canBeLeftOpenTag","isPlainTextElement","endTagLength","stackedTag","reStackedTag","reCache","RegExp","rest$1","all","endTag","shouldIgnoreFirstNewline","chars","textEnd","comment","commentEnd","shouldKeepComment","conditionalComment","conditionalEnd","doctypeMatch","doctype","endTagMatch","curIndex","startTagMatch","startTagOpen","attr","startTagClose","attribute","unarySlash","isNonPhrasingTag","unary","IS_REGEX_CAPTURING_BROKEN","rest","parse","template","endPre","element","pre","inVPre","platformIsPreTag","inPre","warn$2","isPreTag","platformMustUseProp","platformGetTagNamespace","transforms","preTransforms","postTransforms","root","currentParent","preserveWhitespace","comments","guardIESVGBug","makeAttrsMap","isForbiddenTag","forbidden","processPre","processRawAttrs","processFor","processIf","processOnce","processKey","plain","processRef","processSlot","processComponent","i$1","processAttrs","if","elseif","else","addIfCondition","block","processIfConditions","slotScope","slotTarget","i$2","lastNode","isTextTag","decodeHTMLCached","checkInFor","inMatch","forAliasRE","for","alias","iteratorMatch","forIteratorRE","iterator1","iterator2","findPrevElement","condition","ifConditions","slotName","isProp","dirRE","hasBindings","parseModifiers","modifierRE","bindRE","camel","onRE","argMatch","argRE","ieNSBug","ieNSPrefix","optimize","isStaticKey","genStaticKeysCached","staticKeys","isPlatformReservedTag","markStatic$1","markStaticRoots","genStaticKeys$1","static","l$1","staticInFor","staticRoot","isBuiltInTag","isDirectChildOfTemplateFor","genHandlers","genHandler","isMethodPath","simplePathRE","isFunctionExpression","fnExpRE","genModifierCode","modifierCode","genKeyFilter","genFilterCode","keyVal","parseInt","wrapListeners","bind$1","wrapData","generate","ast","state","CodegenState","genElement","staticProcessed","genStatic","onceProcessed","genOnce","forProcessed","genFor","ifProcessed","genIf","genSlot","genComponent","genData$2","genChildren","onceId","altGen","altEmpty","genIfConditions","conditions","genTernaryExp","shift","altHelper","genDirectives","dataGenFns","genProps","genScopedSlots","genInlineTemplate","needRuntime","hasRuntime","gen","inlineRenderFns","genScopedSlot","genForScopedSlot","scope","checkSkip","altGenElement","altGenNode","el$1","getNormalizationType","maybeComponent","genNode","needsNormalization","some","genComment","genText","transformSpecialNewlines","bind$$1","componentName","createFunction","errors","Function","createCompileToFunctionFn","compile","compiled","fnGenErrors","getOuterHTML","outerHTML","container","cloneNode","innerHTML","camelizeRE","toUpperCase","hyphenateRE","SSR_ATTR","LIFECYCLE_HOOKS","optionMergeStrategies","silent","productionTip","performance","warnHandler","ignoredElements","isReservedAttr","_lifecycleHooks","freeze","hasProto","UA","navigator","userAgent","isEdge","isAndroid","isIOS","_isServer","_Set","env","VUE_ENV","__VUE_DEVTOOLS_GLOBAL_HOOK__","Symbol","nextTickHandler","pending","copies","callbacks","timerFunc","Promise","logError","catch","MutationObserver","counter","observer","textNode","characterData","_resolve","Set","uid","subs","addSub","sub","removeSub","addDep","arrayProto","arrayMethods","method","original","observeArray","arrayKeys","getOwnPropertyNames","walk","items","raw","prototypeAccessors","defineProperties","uid$2","expOrFn","deep","user","active","deps","newDeps","depIds","newDepIds","cleanupDeps","this$1","tmp","teardown","init","$mount","keepAlive","mountedNode","prepatch","insert","destroy","uid$1","_uid","_self","dataDef","propsDef","$set","$delete","immediate","hookRE","cbs","prevEl","prevVnode","prevActiveInstance","__patch__","__vue__","$nextTick","_o","_n","_s","_l","_t","_q","_i","_m","_f","_k","_b","_v","_e","_u","_g","patternTypes","KeepAlive","include","exclude","created","destroyed","builtInComponents","configDef","util","defineReactive","delete","version","emptyStyle","acceptValue","svg","math","isHTMLTag","nodeOps","hooks","baseModules","klass","cssText","listDelimiter","propertyDelimiter","cssVarRE","importantRE","setProperty","normalizedName","normalize","vendorNames","capName","hasTransition","ontransitionend","onwebkittransitionend","onanimationend","onwebkitanimationend","requestAnimationFrame","activate","platformModules","patch","backend","emptyNodeAt","createRmCb","childElm","removeNode","createElm","insertedVnodeQueue","nested","setScope","createChildren","invokeCreateHooks","isReactivated","initComponent","reactivateComponent","pendingInsert","isPatchable","innerNode","ref$$1","ancestor","_scopeId","addVnodes","startIdx","invokeDestroyHook","removeVnodes","ch","removeAndInvokeRemoveHook","updateChildren","oldCh","newCh","removeOnly","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","canMove","patchVnode","hydrate","postpatch","invokeInsertHook","initial","hasChildNodes","childrenMatch","firstChild","isRenderedModule","isInitialPatch","isRealElement","hasAttribute","oldElm","parentElm$1","isTextInputType","vmodel","model$1","_vOptions","prevOptions","transition$$1","originalDisplay","__vOriginalDisplay","display","unbind","platformDirectives","transitionProps","mode","Transition","_leaving","oldRawChild","delayedLeave","moveClass","TransitionGroup","prevChildren","rawChildren","transitionData","kept","removed","c$1","beforeUpdate","updated","hasMove","body","offsetHeight","propertyName","_hasMove","clone","platformComponents","decoder","content","encoded","div","regexEscapeRE","open","close","klass$1","style$1","modules$1","directives$1","baseOptions","reduce","he","decode","singleAttrIdentifier","singleAttrAssign","singleAttrValues","ncname","qnameCapture","g","&lt;","&gt;","&quot;","&amp;","&#10;","isIgnoreNewlineTag","esc","tab","space","up","right","down","genGuard","stop","prevent","self","ctrl","alt","meta","middle","baseDirectives","cloak","createCompiler","baseCompile","finalOptions","tips","tip","compileToFunctions","ref$1","idToTemplate","mount","documentElement","__WEBPACK_IMPORTED_MODULE_0_tone__","__WEBPACK_IMPORTED_MODULE_0_tone___default","base_note","notes","num","den","log","synth","Synth","toMaster","makeSound","fraction","freq","Frequency","toFrequency","playFreq","triggerAttackRelease","__WEBPACK_IMPORTED_MODULE_0_vue__","__WEBPACK_IMPORTED_MODULE_1__Main_vue__","__WEBPACK_IMPORTED_MODULE_1__Main_vue___default","NotFound","routes","/","currentRoute","location","pathname","ViewComponent","mediaQuery","alreadyImportedModules","__WEBPACK_AMD_DEFINE_RESULT__","Module","func","Tone","inputs","outputs","input","createGain","output","params","rampTime","isString","tmpObj","paramLoop","attrSplit","innerParam","param","Signal","Param","rampTo","AudioParam","_collectDefaults","subRet","subAttr","isFunction","constr","defaults","_super","superDefs","className","isLetter","sameConstructor","dispose","AudioNode","disconnect","connect","unit","outputNum","inputNum","defaultArg","destination","isNumber","connectSeries","currentUnit","toUnit","chain","fan","given","givenProp","fallbackProp","optionsObject","values","isBoolean","noOp","_readOnly","_writable","State","Started","Stopped","Paused","equalPowerScale","percent","piFactor","PI","sin","dbToGain","db","pow","gainToDb","gain","LN10","intervalToFrequencyRatio","interval","now","TempConstructor","audioContext","Context","setContext","sampleRate","hasAudioContext","hasPromises","hasWorkers","TONE_SILENCE_VERSION_LOGGING","SignalBase","outputNumber","inputNumber","TimelineSignal","_param","cancelScheduledValues","overridden","WaveShaper","mapping","bufferLen","_shaper","createWaveShaper","_curve","curve","Float32Array","setMap","oversample","oversampling","RangeError","TimeBase","units","_expr","_noOp","copy","_defaultUnits","_primaryExpressions","_defaultExpr","exprString","_parseExprString","instance","time","regexp","_beatsToUnits","_timeSignature","t","_ticksToUnits","hz","_frequencyToUnits","tr","q","total","_secondsToUnits","samples","_binaryExpressions","+","precedence","lh","rh","-","*","_unaryExpressions","neg","_syntaxGlue","(",")","_tokenize","expr","position","token","expressions","group","opName","op","reg","SyntaxError","substr","peek","_matchGroup","prec","_parseBinary","lexer","_parseUnary","_parsePrimary","matching","beats","Transport","bpm","seconds","ticks","PPQ","timeSignature","_pushExpr","mult","valueOf","Time","_plusNow","quantize","nextSubdivision","subdiv","subdivision","toSeconds","round","addNow","toNotation","testNotations","retNotation","_toNotationHelper","testTripletNotations","retTripletNotation","threshold","_notationToUnits","notationTime","notation","primaryExprs","notationExprs","toBarsBeatsSixteenths","quarterTime","quarters","measures","sixteenths","toFixed","toTicks","toSamples","toMilliseconds","midi","midiToFrequency","note","pitch","octave","noteToScaleIndex","noteNumber","transpose","harmonize","intervals","toMidi","frequencyToMidi","toNote","A4","LN2","scaleIndexToNote","cbb","c#","cx","dbb","d#","ebb","eb","e#","ex","fbb","fb","f","f#","fx","gbb","gb","g#","gx","abb","ab","a#","ax","bbb","bb","b#","bx","frequency","TransportTime","_secondsToTicks","ceil","Emitter","eventName","off","eventList","functions","emitterFunc","AudioContext","webkitAudioContext","_defineProperty","_latencyHint","_lookAhead","_updateInterval","_computedUpdateInterval","_worker","_createWorker","_constants","currentTime","URL","webkitURL","blob","Blob","blobUrl","createObjectURL","worker","Worker","_lastUpdate","diff","getConstant","buffer","createBuffer","getChannelData","constant","createBufferSource","channelCount","channelCountMode","loop","lA","blockTime","postMessage","hint","lookAhead","latencyHint","updateInterval","supported","toneConnect","B","outNum","inNum","nativeConnect","Error","toneDisconnect","nativeDisconnect","Type","Default","Ticks","NormalRange","AudioRange","Decibels","Interval","BPM","Positive","Cents","Degrees","MIDI","BarsBeatsSixteenths","Samples","Hertz","Note","Milliseconds","Seconds","Notation","convert","_lfo","lfo","_toUnits","LFO","convertedVal","_fromUnits","min","_minOutput","setValueAtTime","setRampPoint","currentVal","linearRampToValueAtTime","endTime","exponentialRampToValueAtTime","exponentialRampToValue","startTime","linearRampToValue","setTargetAtTime","timeConstant","setValueCurveAtTime","GainNode","createGainNode","Gain","_gainNode","createInsOuts","_gain","Timeline","_timeline","_toRemove","_iterating","memory","Infinity","_search","getAfter","getBefore","cancel","after","cancelBefore","beginning","midPoint","nextEvent","_iterate","lowerBound","upperBound","forEachBefore","forEachAfter","forEachFrom","forEachAtTime","_initial","Linear","Exponential","Target","Curve","getValueAtTime","beforeEvent","_searchBefore","setValue","sampleTime","scaling","floats","segmentTime","before","_searchAfter","linearRampToValueBetween","finish","exponentialRampToValueBetween","previouVal","previous","_exponentialApproach","_curveInterpolate","_linearInterpolate","_exponentialInterpolate","t0","v0","v1","t1","progress","lowerIndex","upperIndex","lowerVal","upperVal","Pow","_exp","_expScaler","_expFunc","abs","Envelope","attack","decay","sustain","release","_attackCurve","_releaseCurve","_sig","attackCurve","releaseCurve","In","curveDef","Out","triggerAttack","velocity","originalAttack","currentValue","percentComplete","sliceIndex","triggerRelease","invertCurve","out","k","cosineCurve","rippleCurve","curveLen","sineWave","stairsCurve","sineCurve","cos","bounceCurve","linear","exponential","bounce","cosine","reverse","step","ripple","sine","AmplitudeEnvelope","AnalyserNode","getFloatTimeDomainData","array","uint8","Uint8Array","getByteTimeDomainData","Analyser","_analyser","createAnalyser","_type","_returnType","returnType","_buffer","size","minDecibels","maxDecibels","smoothing","Waveform","FFT","ReturnType","Byte","Float","analyse","getByteFrequencyData","getFloatFrequencyData","frequencyBinCount","fftSize","TypeError","smoothingTimeConstant","Compressor","_compressor","createDynamicsCompressor","knee","ratio","Add","_sum","Multiply","_mult","Negate","_multiply","Subtract","_neg","GreaterThanZero","_thresh","_scale","GreaterThan","_gtz","Abs","_abs","Modulo","modulus","_subtract","_modSignal","_setWaveShaper","mod","AudioToGain","_norm","x","applyBinary","Constructor","_eval","applyUnary","getNumber","literalNumber","Expr","_replacements","inputCount","_parseInputs","_nodes","_parseTree","_disposeNodes","_Expressions","signal","glue",",","a2g","binary","!","NOT","inputArray","inputMax","matchSyntax","syn","matchGroup","groupName","parseExpression","parseUnary","operator","parsePrimary","parseFunctionCall","parseArgumentList","EqualPowerGain","_eqPower","CrossFade","initialFade","fade","_equalPowerA","_equalPowerB","_invert","Filter","_filters","detune","Q","_rolloff","rolloff","possibilities","cascadingCount","count","createBiquadFilter","connectionChain","MultibandSplit","low","_lowMidFilter","mid","high","lowFrequency","highFrequency","EQ3","_multibandSplit","_lowGain","_midGain","_highGain","Scale","outputMin","outputMax","_outputMin","_outputMax","_add","_setRange","ScaleExp","exponent","DelayNode","createDelay","createDelayNode","Delay","_delayNode","maxDelay","delayTime","FeedbackCombFilter","_delay","_feedback","resonance","Follower","_filter","_frequencyValues","_sub","_attack","_release","_setAttackRelease","minTime","ScaledEnvelope","FrequencyEnvelope","_octaves","octaves","baseFrequency","Gate","_follower","_gt","thresh","attackTime","releaseTime","TimelineState","setStateAtTime","Clock","_nextTick","_lastState","_state","_boundLoop","_loop","offset","pause","lagCompensation","lag","loopInterval","currentState","tickTime","getStateAtTime","IntervalTimeline","_root","IntervalNode","updateHeight","updateMax","_rebalance","results","search","_removeNode","_setRoot","_replaceNodeInParent","replacement","isLeftChild","temp","balance","getBalance","_rotateLeft","pivotNode","_rotateRight","allNodes","searchAfter","_left","_right","height","point","_loopStart","_loopEnd","_ppq","TransportConstructor","_clock","_processTick","_bindClockEvents","_scheduledEvents","_eventID","_repeatedEvents","_onceEvents","_syncedSignals","_swingTicks","_swingAmount","swing","swingSubdivision","loopStart","loopEnd","amount","schedule","timeline","scheduleRepeat","scheduleOnce","eventId","timeSig","startPosition","endPosition","setLoopPoints","ppq","transportPos","remainingTime","syncSignal","ratioSignal","unsyncSignal","syncedSignal","Volume","volume","_unmutedVolume","mute","Master","_volume","MasterConstructor","Source","_synced","_scheduled","_start","_stop","retrigger","sched","stateEvent","startOffset","unsync","OscillatorNode","noteOn","noteOff","setPeriodicWave","setWaveTable","createPeriodicWave","createWaveTable","Oscillator","_oscillator","_wave","_partials","partials","_phase","phase","Sine","Triangle","Sawtooth","Square","Custom","createOscillator","syncFrequency","unsyncFrequency","coefs","_getRealImaginary","periodicWave","periodicWaveSize","real","imag","partialCount","partial","_inverseFFT","sum","_getInitialValue","maxValue","twoPi","Zero","amplitude","_stoppedSignal","_zeros","_stoppedValue","_a2g","_scaler","_units","currentMin","currentMax","Limiter","LowpassCombFilter","_lowpass","dampening","Merge","_merger","createChannelMerger","Meter","_lastValue","Level","rms","sqrt","Split","_splitter","createChannelSplitter","MidSideSplit","_split","side","SQRT1_2","MidSideMerge","_merge","MidSideCompressor","_midSideSplit","_midSideMerge","Mono","MultibandCompressor","Panner","initialPan","_hasStereoPanner","_panner","createStereoPanner","pan","_crossFade","_zero","Panner3D","createPanner","panningModel","maxDistance","distanceModel","coneOuterGain","coneOuterAngle","coneInnerAngle","refDistance","rolloffFactor","_orientation","orientationX","orientationY","orientationZ","_position","positionX","positionY","positionZ","_rampTimeConstant","setPosition","y","z","setOrientation","_aliasProperty","PanVol","CtrlInterpolate","lowerPosition","lower","upper","_interpolate","retArray","retObj","_toNumber","CtrlMarkov","distribution","_getProbDistribution","rand","random","dist","chosen","needsNormalizing","probability","CtrlPattern","_shuffled","_direction","Up","Down","UpDown","DownUp","AlternateUp","AlternateDown","Random","RandomWalk","RandomOnce","_shuffleValues","randVal","CtrlRandom","integer","AudioBuffer","copyToChannel","chanNum","channel","copyFromChannel","dest","Buffer","_reversed","_xhr","url","onload","load","onerror","buff","_currentDownloads","abort","numberOfChannels","fromArray","isMultidimensional","channels","toMono","outputArray","numChannels","channelArray","sample","startSamples","endSamples","_reverse","loaded","rev","_downloadQueue","baseUrl","onError","onProgress","totalProgress","request","XMLHttpRequest","responseType","status","decodeAudioData","response","lengthComputable","send","cancelDownloads","supportsType","extension","canPlayType","removeEvents","success","fail","Buffers","urls","_buffers","_flattenUrls","_loadingCount","_bufferLoaded","isLoaded","buffName","toReturn","flatObject","Buses","channelName","sendKnob","receive","Draw","expiration","anticipation","_boundDrawLoop","_drawLoop","Listener","ListenerConstructor","forwardX","forwardY","forwardZ","upX","upY","upZ","listener","OfflineAudioContext","webkitOfflineAudioContext","OfflineContext","offlineContext","_duration","_currentTime","done","oncomplete","renderedBuffer","startRendering","Offline","originalContext","rendered","Effect","_dryWet","wet","effectSend","effectReturn","connectEffect","effect","AutoFilter","depth","oct","AutoPanner","AutoWah","follower","_sweepRange","_baseFrequency","_inputBoost","_bandpass","_peaking","_setSweepRange","sensitivity","baseFreq","sensitivy","BitCrusher","invStepSize","bits","_modulo","_bits","Chebyshev","_order","order","_getCoefficient","degree","memo","StereoEffect","effectSendL","effectSendR","effectReturnL","effectReturnR","FeedbackEffect","_feedbackGain","feedback","StereoXFeedbackEffect","_feedbackLR","_feedbackRL","Chorus","_depth","_delayTime","_lfoL","_lfoR","_delayNodeL","_delayNodeR","spread","deviation","Convolver","_convolver","createConvolver","Distortion","_distortion","distortion","deg","FeedbackDelay","combFilterTunings","allpassFilterFrequencies","Freeverb","roomSize","_combFilters","_allpassFiltersL","_allpassFiltersR","allpassL","r","allpassR","lfpf","al","ar","cf","combFilterDelayTimes","combFilterResonances","allpassFilterFreqs","JCReverb","_scaleRoomSize","_allpassFilters","_feedbackCombFilters","af","allpass","fbcf","apf","MidSideEffect","midSend","sideSend","midReturn","sideReturn","Phaser","_filtersL","_makeFilters","stages","_filtersR","connectToFreq","PingPongDelay","_leftDelay","maxDelayTime","_rightDelay","_rightPreDelay","PitchShift","_frequency","_delayA","_lfoA","_delayB","_lfoB","_crossFadeLFO","_feedbackDelay","_pitch","_windowSize","windowSize","factor","StereoFeedbackEffect","_feedbackL","_feedbackR","StereoWidener","width","_midMult","_sideMult","_two","Tremolo","_amplitudeL","_amplitudeR","Vibrato","Event","_playbackRate","_startOffset","humanize","playbackRate","_rescheduleEvents","startTick","_getLoopDuration","_tick","previousEvent","reschedulTime","variation","rate","lastEvent","loopDuration","Loop","_event","iterations","prob","iters","Part","_probability","_humanize","_forEach","_startNote","at","_restartEvent","removeAll","_setAll","_testLoopBoundries","Pattern","_pattern","vals","Sequence","_subdivision","_indexTime","subSubdivision","PulseOscillator","_widthGate","_sawtooth","PWMOscillator","_pulse","modulationFrequency","_modulator","FMOscillator","_carrier","modulationIndex","modulationType","harmonicity","_modulationNode","AMOscillator","_modulationScale","FatOscillator","_oscillators","_spread","osc","iterator","OmniOscillator","_sourceType","OmniOscType","Pulse","PWM","Osc","FM","AM","Fat","prefix","_createNewOscillator","oscType","OscillatorConstructor","oldOsc","mType","Instrument","Monophonic","portamento","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","currentNote","portTime","oscillator","envelope","AMSynth","modulation","modulationEnvelope","MonoSynth","filterEnvelope","DuoSynth","voice0","voice1","_vibrato","vibratoRate","_vibratoGain","vibratoAmount","FMSynth","carrier","modulator","MembraneSynth","pitchDecay","maxNote","inharmRatios","MetalSynth","_freqMultipliers","_amplitue","_highpass","_filterFreqScaler","vel","octs","AudioBufferSourceNode","noteGrainOn","BufferSource","onended","_startTime","_stopTime","_source","fadeIn","fadeOut","_onendedTimeout","fadeInTime","fadeOutTime","playbackState","clearTimeout","_onended","createBuffers","_noiseArrays","_noiseBuffers","Noise","pink","channelNum","b0","b1","b2","b3","b4","b5","b6","white","brown","lastOut","NoiseSynth","noise","PluckSynth","_noise","attackNoise","_lfcf","delayAmount","PolySynth","polyphony","MAX_POLYPHONY","voices","_triggers","voice","oldest","desc","releaseAll","Player","autostart","_onload","seek","Sampler","player","GainToAudio","Normalize","inputMin","_inputMin","_inputMax","_div","MultiPlayer","buffers","_activeSources","_makeSource","bufferName","startLoop","stopAll","sources","GrainPlayer","_player","_grainSize","grainSize","_overlap","overlap","drift","_offset","bufferDuration","originalFadeIn","endSegmentDuration","scrub","UserMedia","_mediaStream","_stream","_device","labelOrId","enumerateDevices","devices","device","find","label","deviceId","constraints","audio","echoCancellation","mediaDevices","getUserMedia","stream","createMediaStreamSource","getAudioTracks","track","kind","groupId","rawScriptExports","compiledTemplate","injectStyles","scopeId","moduleIdentifier","esModule","scriptExports","__VUE_SSR_CONTEXT__","_registeredComponents","_ssrRegister","beforeCreate","_vm","_h","tabindex","click","locals","addStylesToDom","domStyle","stylesInDom","parts","addStyle","createStyleElement","styleElement","head","isProduction","isOldIE","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","applyToTag","newObj","media","sourceMap","styleSheet","replaceText","cssNode","childNodes","btoa","unescape","encodeURIComponent","hasDocument","DEBUG","listToStyles","getElementsByTagName","parentId","_isProduction","newList","mayRemove","textStore","newStyles","part","eval"],"mappings":"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","file":"build.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction injectStyle (ssrContext) {\n  __webpack_require__(9)\n}\nvar Component = __webpack_require__(7)(\n  /* script */\n  __webpack_require__(2),\n  /* template */\n  __webpack_require__(8),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * Vue.js v2.4.2\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: \"production\" !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: \"production\" !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (false) {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (false) {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefix has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (false) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    \"production\" !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (false) {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      \"production\" !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (false) {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (false) {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (false) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (false) {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (false) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (false) {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (false) {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      \"production\" !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (false) {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      \"production\" !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                 false\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (false) {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (false) {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (false) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (false) {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listensers hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n  vm.$listeners = listeners;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (false) {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (false) {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (false) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression =  false\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      \"production\" !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (false) {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    \"production\" !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (false) {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      \"production\" !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  \"production\" !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (false) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (false) {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (false) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  \"production\" !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (false) {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  \"production\" !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (false) {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (false) {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (false) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (false) {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    \"production\" !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (false\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && \"production\" !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      \"production\" !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n  if (false) {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (false) {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (false) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (false) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (false) {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (false) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (false\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (false) {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (false) {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (false) {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.2';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      \"production\" !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (false) {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (false) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (false) {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (false\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (false) {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    false\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (modelRs.exp) + \", \" + (modelRs.idx) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (false) {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (false) {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (false) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    \"production\" !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (false) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (false\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (false) {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (false) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (false\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (false) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (false) {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (false) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (false\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        \"production\" !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (false) {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (false) {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (false) {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (false) {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      \"production\" !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (false) {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (false) {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (false) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (false) {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (false) {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      false\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (false\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (false) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      \"production\" !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (false\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (false) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el, state) || 'void 0'\n      : genElement(el, state)) + \"}}\"\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (false) {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (false) {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (false) {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (false) {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    \"production\" !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (false) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (false) {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (false) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Vue$3);\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(12)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tone__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_tone___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_tone__);\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'main',\n  created: function created() {\n    this.init();\n  },\n  data: function data() {\n    return {\n      msg: 'Welcome to Shruti',\n      base_note: \"C#4\",\n      notes: [{ id: 0, text: 'S', value: { num: 1, den: 1 } }, { id: 1, text: 'r1', value: { num: 256, den: 243 } }, { id: 2, text: 'r2', value: { num: 16, den: 15 } }, { id: 3, text: 'R1', value: { num: 10, den: 9 } }, { id: 4, text: 'R2', value: { num: 9, den: 8 } }, { id: 5, text: 'g1', value: { num: 32, den: 27 } }, { id: 6, text: 'g2', value: { num: 6, den: 5 } }, { id: 7, text: 'G1', value: { num: 5, den: 4 } }, { id: 8, text: 'G2', value: { num: 81, den: 64 } }, { id: 9, text: 'M1', value: { num: 4, den: 3 } }, { id: 10, text: 'M2', value: { num: 27, den: 20 } }, { id: 11, text: 'm1', value: { num: 45, den: 32 } }, { id: 12, text: 'm2', value: { num: 729, den: 512 } }, { id: 13, text: 'P', value: { num: 3, den: 2 } }, { id: 14, text: 'd1', value: { num: 128, den: 81 } }, { id: 15, text: 'd2', value: { num: 8, den: 5 } }, { id: 16, text: 'D1', value: { num: 5, den: 3 } }, { id: 17, text: 'D2', value: { num: 27, den: 16 } }, { id: 18, text: 'n1', value: { num: 16, den: 9 } }, { id: 19, text: 'n2', value: { num: 9, den: 5 } }, { id: 20, text: 'N1', value: { num: 15, den: 8 } }, { id: 21, text: 'N2', value: { num: 243, den: 128 } }, { id: 22, text: 'S\\'', value: { num: 2, den: 1 } }]\n    };\n  },\n\n  methods: {\n    init: function init() {\n      console.log(\"Initializing...\");\n      this.synth = new __WEBPACK_IMPORTED_MODULE_0_tone___default.a.Synth().toMaster();\n    },\n    makeSound: function makeSound(fraction) {\n      var freq = __WEBPACK_IMPORTED_MODULE_0_tone___default.a.Frequency(this.base_note).toFrequency();\n      var playFreq = __WEBPACK_IMPORTED_MODULE_0_tone___default.a.Frequency(freq / fraction.den * fraction.num);\n      this.synth.triggerAttackRelease(playFreq, \"6n\");\n    }\n  }\n});\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vue__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Main_vue__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Main_vue___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Main_vue__);\n\n\n\nvar NotFound = { template: '<p>Page not found</p>' };\nvar routes = {\n  '/': __WEBPACK_IMPORTED_MODULE_1__Main_vue___default.a\n};\n\nnew __WEBPACK_IMPORTED_MODULE_0_vue__[\"a\" /* default */]({\n  el: '#app',\n  install: function install(Vue) {},\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent: function ViewComponent() {\n      console.log(this.currentRoute);\n      return routes[this.currentRoute] || routes[this.currentRoute.replace('shruti-practice', '')] || routes[this.currentRoute.replace('shruti-practice/', '')] || NotFound;\n    }\n  },\n  render: function render(h) {\n    return h(this.ViewComponent);\n  }\n});\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = __webpack_require__(5)();\n// imports\n\n\n// module\nexports.push([module.i, \"#app{font-family:Avenir,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-align:center;color:#2c3e50;margin-top:60px}h1,h2{font-weight:400}ul{list-style-type:none;padding:0}li{display:inline-block;margin:0 10px}a,a:active,a:hover,a:visited{color:hotpink;text-decoration:underline}a:active,a:hover{color:#ff1493}\", \"\"]);\n\n// exports\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory){\n\n\t//UMD\n\tif ( true ) {\n\t\t!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {\n\t\t\treturn factory();\n\t\t}.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else if (typeof module === \"object\") {\n\t\tmodule.exports = factory();\n \t} else {\n\t\troot.Tone = factory();\n\t}\n\n}(this, function(){\n\n\t\"use strict\";\n\t\n\tvar Tone;\n\t//constructs the main Tone object\n\tfunction Main(func){\n\t\tTone = func();\n\t}\n\t//invokes each of the modules with the main Tone object as the argument\n\tfunction Module(func){\n\t\tfunc(Tone);\n\t}\t/**\n\t *  Tone.js\n\t *  @author Yotam Mann\n\t *  @license http://opensource.org/licenses/MIT MIT License\n\t *  @copyright 2014-2017 Yotam Mann\n\t */\n\tMain(function () {\n\t    \n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTONE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  @class  Tone is the base class of all other classes. It provides \n\t\t *          a lot of methods and functionality to all classes that extend\n\t\t *          it. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @alias Tone\n\t\t *  @param {number} [inputs=1] the number of input nodes\n\t\t *  @param {number} [outputs=1] the number of output nodes\n\t\t */\n\t    var Tone = function (inputs, outputs) {\n\t        /**\n\t\t\t *  the input node(s)\n\t\t\t *  @type {GainNode|Array}\n\t\t\t */\n\t        if (this.isUndef(inputs) || inputs === 1) {\n\t            this.input = this.context.createGain();\n\t        } else if (inputs > 1) {\n\t            this.input = new Array(inputs);\n\t        }\n\t        /**\n\t\t\t *  the output node(s)\n\t\t\t *  @type {GainNode|Array}\n\t\t\t */\n\t        if (this.isUndef(outputs) || outputs === 1) {\n\t            this.output = this.context.createGain();\n\t        } else if (outputs > 1) {\n\t            this.output = new Array(inputs);\n\t        }\n\t    };\n\t    /**\n\t\t *  Set the parameters at once. Either pass in an\n\t\t *  object mapping parameters to values, or to set a\n\t\t *  single parameter, by passing in a string and value.\n\t\t *  The last argument is an optional ramp time which \n\t\t *  will ramp any signal values to their destination value\n\t\t *  over the duration of the rampTime.\n\t\t *  @param {Object|string} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * //set values using an object\n\t\t * filter.set({\n\t\t * \t\"frequency\" : 300,\n\t\t * \t\"type\" : highpass\n\t\t * });\n\t\t *  @example\n\t\t * filter.set(\"type\", \"highpass\");\n\t\t *  @example\n\t\t * //ramp to the value 220 over 3 seconds. \n\t\t * oscillator.set({\n\t\t * \t\"frequency\" : 220\n\t\t * }, 3);\n\t\t */\n\t    Tone.prototype.set = function (params, value, rampTime) {\n\t        if (this.isObject(params)) {\n\t            rampTime = value;\n\t        } else if (this.isString(params)) {\n\t            var tmpObj = {};\n\t            tmpObj[params] = value;\n\t            params = tmpObj;\n\t        }\n\t        paramLoop:\n\t            for (var attr in params) {\n\t                value = params[attr];\n\t                var parent = this;\n\t                if (attr.indexOf('.') !== -1) {\n\t                    var attrSplit = attr.split('.');\n\t                    for (var i = 0; i < attrSplit.length - 1; i++) {\n\t                        parent = parent[attrSplit[i]];\n\t                        if (parent instanceof Tone) {\n\t                            attrSplit.splice(0, i + 1);\n\t                            var innerParam = attrSplit.join('.');\n\t                            parent.set(innerParam, value);\n\t                            continue paramLoop;\n\t                        }\n\t                    }\n\t                    attr = attrSplit[attrSplit.length - 1];\n\t                }\n\t                var param = parent[attr];\n\t                if (this.isUndef(param)) {\n\t                    continue;\n\t                }\n\t                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {\n\t                    if (param.value !== value) {\n\t                        if (this.isUndef(rampTime)) {\n\t                            param.value = value;\n\t                        } else {\n\t                            param.rampTo(value, rampTime);\n\t                        }\n\t                    }\n\t                } else if (param instanceof AudioParam) {\n\t                    if (param.value !== value) {\n\t                        param.value = value;\n\t                    }\n\t                } else if (param instanceof Tone) {\n\t                    param.set(value);\n\t                } else if (param !== value) {\n\t                    parent[attr] = value;\n\t                }\n\t            }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the object's attributes. Given no arguments get\n\t\t *  will return all available object properties and their corresponding\n\t\t *  values. Pass in a single attribute to retrieve or an array\n\t\t *  of attributes. The attribute strings can also include a \".\"\n\t\t *  to access deeper properties.\n\t\t *  @example\n\t\t * osc.get();\n\t\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t\t *  @example\n\t\t * osc.get(\"type\");\n\t\t * //returns { \"type\" : \"sine\"}\n\t\t * @example\n\t\t * //use dot notation to access deep properties\n\t\t * synth.get([\"envelope.attack\", \"envelope.release\"]);\n\t\t * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n\t\t *  @param {Array=|string|undefined} params the parameters to get, otherwise will return \n\t\t *  \t\t\t\t\t                  all available.\n\t\t *  @returns {Object}\n\t\t */\n\t    Tone.prototype.get = function (params) {\n\t        if (this.isUndef(params)) {\n\t            params = this._collectDefaults(this.constructor);\n\t        } else if (this.isString(params)) {\n\t            params = [params];\n\t        }\n\t        var ret = {};\n\t        for (var i = 0; i < params.length; i++) {\n\t            var attr = params[i];\n\t            var parent = this;\n\t            var subRet = ret;\n\t            if (attr.indexOf('.') !== -1) {\n\t                var attrSplit = attr.split('.');\n\t                for (var j = 0; j < attrSplit.length - 1; j++) {\n\t                    var subAttr = attrSplit[j];\n\t                    subRet[subAttr] = subRet[subAttr] || {};\n\t                    subRet = subRet[subAttr];\n\t                    parent = parent[subAttr];\n\t                }\n\t                attr = attrSplit[attrSplit.length - 1];\n\t            }\n\t            var param = parent[attr];\n\t            if (this.isObject(params[attr])) {\n\t                subRet[attr] = param.get();\n\t            } else if (Tone.Signal && param instanceof Tone.Signal) {\n\t                subRet[attr] = param.value;\n\t            } else if (Tone.Param && param instanceof Tone.Param) {\n\t                subRet[attr] = param.value;\n\t            } else if (param instanceof AudioParam) {\n\t                subRet[attr] = param.value;\n\t            } else if (param instanceof Tone) {\n\t                subRet[attr] = param.get();\n\t            } else if (!this.isFunction(param) && !this.isUndef(param)) {\n\t                subRet[attr] = param;\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  collect all of the default attributes in one\n\t\t *  @private\n\t\t *  @param {function} constr the constructor to find the defaults from\n\t\t *  @return {Array} all of the attributes which belong to the class\n\t\t */\n\t    Tone.prototype._collectDefaults = function (constr) {\n\t        var ret = [];\n\t        if (!this.isUndef(constr.defaults)) {\n\t            ret = Object.keys(constr.defaults);\n\t        }\n\t        if (!this.isUndef(constr._super)) {\n\t            var superDefs = this._collectDefaults(constr._super);\n\t            //filter out repeats\n\t            for (var i = 0; i < superDefs.length; i++) {\n\t                if (ret.indexOf(superDefs[i]) === -1) {\n\t                    ret.push(superDefs[i]);\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  @returns {string} returns the name of the class as a string\n\t\t */\n\t    Tone.prototype.toString = function () {\n\t        for (var className in Tone) {\n\t            var isLetter = className[0].match(/^[A-Z]$/);\n\t            var sameConstructor = Tone[className] === this.constructor;\n\t            if (this.isFunction(Tone[className]) && isLetter && sameConstructor) {\n\t                return className;\n\t            }\n\t        }\n\t        return 'Tone';\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCLASS VARS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The number of inputs feeding into the AudioNode. \n\t\t *  For source nodes, this will be 0.\n\t\t *  @memberOf Tone#\n\t\t *  @name numberOfInputs\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'numberOfInputs', {\n\t        get: function () {\n\t            if (this.input) {\n\t                if (this.isArray(this.input)) {\n\t                    return this.input.length;\n\t                } else {\n\t                    return 1;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of outputs coming out of the AudioNode. \n\t\t *  For source nodes, this will be 0.\n\t\t *  @memberOf Tone#\n\t\t *  @name numberOfInputs\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'numberOfOutputs', {\n\t        get: function () {\n\t            if (this.output) {\n\t                if (this.isArray(this.output)) {\n\t                    return this.output.length;\n\t                } else {\n\t                    return 1;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCONNECTIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  disconnect and dispose\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.dispose = function () {\n\t        if (!this.isUndef(this.input)) {\n\t            if (this.input instanceof AudioNode) {\n\t                this.input.disconnect();\n\t            }\n\t            this.input = null;\n\t        }\n\t        if (!this.isUndef(this.output)) {\n\t            if (this.output instanceof AudioNode) {\n\t                this.output.disconnect();\n\t            }\n\t            this.output = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode\n\t\t *  @param  {Tone | AudioParam | AudioNode} unit \n\t\t *  @param {number} [outputNum=0] optionally which output to connect from\n\t\t *  @param {number} [inputNum=0] optionally which input to connect to\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.connect = function (unit, outputNum, inputNum) {\n\t        if (Array.isArray(this.output)) {\n\t            outputNum = this.defaultArg(outputNum, 0);\n\t            this.output[outputNum].connect(unit, 0, inputNum);\n\t        } else {\n\t            this.output.connect(unit, outputNum, inputNum);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  disconnect the output\n\t\t *  @param {Number|AudioNode} output Either the output index to disconnect\n\t\t *                                   if the output is an array, or the\n\t\t *                                   node to disconnect from.\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.disconnect = function (destination, outputNum, inputNum) {\n\t        if (this.isArray(this.output)) {\n\t            if (this.isNumber(destination)) {\n\t                this.output[destination].disconnect();\n\t            } else {\n\t                outputNum = this.defaultArg(outputNum, 0);\n\t                this.output[outputNum].disconnect(destination, 0, inputNum);\n\t            }\n\t        } else {\n\t            this.output.disconnect.apply(this.output, arguments);\n\t        }\n\t    };\n\t    /**\n\t\t *  connect together all of the arguments in series\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.connectSeries = function () {\n\t        if (arguments.length > 1) {\n\t            var currentUnit = arguments[0];\n\t            for (var i = 1; i < arguments.length; i++) {\n\t                var toUnit = arguments[i];\n\t                currentUnit.connect(toUnit);\n\t                currentUnit = toUnit;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Connect the output of this node to the rest of the nodes in series.\n\t\t *  @example\n\t\t *  //connect a node to an effect, panVol and then to the master output\n\t\t *  node.chain(effect, panVol, Tone.Master);\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.chain = function () {\n\t        if (arguments.length > 0) {\n\t            var currentUnit = this;\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                var toUnit = arguments[i];\n\t                currentUnit.connect(toUnit);\n\t                currentUnit = toUnit;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the output of this node to the rest of the nodes in parallel.\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.fan = function () {\n\t        if (arguments.length > 0) {\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                this.connect(arguments[i]);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    //give native nodes chain and fan methods\n\t    AudioNode.prototype.chain = Tone.prototype.chain;\n\t    AudioNode.prototype.fan = Tone.prototype.fan;\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUTILITIES / HELPERS / MATHS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  If the `given` parameter is undefined, use the `fallback`. \n\t\t *  If both `given` and `fallback` are object literals, it will\n\t\t *  return a deep copy which includes all of the parameters from both \n\t\t *  objects. If a parameter is undefined in given, it will return\n\t\t *  the fallback property. \n\t\t *  <br><br>\n\t\t *  WARNING: if object is self referential, it will go into an an \n\t\t *  infinite recursive loop.\n\t\t *  \n\t\t *  @param  {*} given    \n\t\t *  @param  {*} fallback \n\t\t *  @return {*}          \n\t\t */\n\t    Tone.prototype.defaultArg = function (given, fallback) {\n\t        if (this.isObject(given) && this.isObject(fallback)) {\n\t            var ret = {};\n\t            //make a deep copy of the given object\n\t            for (var givenProp in given) {\n\t                ret[givenProp] = this.defaultArg(fallback[givenProp], given[givenProp]);\n\t            }\n\t            for (var fallbackProp in fallback) {\n\t                ret[fallbackProp] = this.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t            }\n\t            return ret;\n\t        } else {\n\t            return this.isUndef(given) ? fallback : given;\n\t        }\n\t    };\n\t    /**\n\t\t *  returns the args as an options object with given arguments\n\t\t *  mapped to the names provided. \n\t\t *\n\t\t *  if the args given is an array containing only one object, it is assumed\n\t\t *  that that's already the options object and will just return it. \n\t\t *  \n\t\t *  @param  {Array} values  the 'arguments' object of the function\n\t\t *  @param  {Array} keys the names of the arguments as they\n\t\t *                                 should appear in the options object\n\t\t *  @param {Object=} defaults optional defaults to mixin to the returned \n\t\t *                            options object                              \n\t\t *  @return {Object}       the options object with the names mapped to the arguments\n\t\t */\n\t    Tone.prototype.optionsObject = function (values, keys, defaults) {\n\t        var options = {};\n\t        if (values.length === 1 && this.isObject(values[0])) {\n\t            options = values[0];\n\t        } else {\n\t            for (var i = 0; i < keys.length; i++) {\n\t                options[keys[i]] = values[i];\n\t            }\n\t        }\n\t        if (!this.isUndef(defaults)) {\n\t            return this.defaultArg(options, defaults);\n\t        } else {\n\t            return options;\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // TYPE CHECKING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  test if the arg is undefined\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is undefined\n\t\t *  @function\n\t\t */\n\t    Tone.prototype.isUndef = function (val) {\n\t        return typeof val === 'undefined';\n\t    };\n\t    /**\n\t\t *  test if the arg is a function\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a function\n\t\t *  @function\n\t\t */\n\t    Tone.prototype.isFunction = function (val) {\n\t        return typeof val === 'function';\n\t    };\n\t    /**\n\t\t *  Test if the argument is a number.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a number\n\t\t */\n\t    Tone.prototype.isNumber = function (arg) {\n\t        return typeof arg === 'number';\n\t    };\n\t    /**\n\t\t *  Test if the given argument is an object literal (i.e. `{}`);\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is an object literal.\n\t\t */\n\t    Tone.prototype.isObject = function (arg) {\n\t        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;\n\t    };\n\t    /**\n\t\t *  Test if the argument is a boolean.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a boolean\n\t\t */\n\t    Tone.prototype.isBoolean = function (arg) {\n\t        return typeof arg === 'boolean';\n\t    };\n\t    /**\n\t\t *  Test if the argument is an Array\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is an array\n\t\t */\n\t    Tone.prototype.isArray = function (arg) {\n\t        return Array.isArray(arg);\n\t    };\n\t    /**\n\t\t *  Test if the argument is a string.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a string\n\t\t */\n\t    Tone.prototype.isString = function (arg) {\n\t        return typeof arg === 'string';\n\t    };\n\t    /**\n\t\t *  An empty function.\n\t\t *  @static\n\t\t */\n\t    Tone.noOp = function () {\n\t    };\n\t    /**\n\t\t *  Make the property not writable. Internal use only. \n\t\t *  @private\n\t\t *  @param  {string}  property  the property to make not writable\n\t\t */\n\t    Tone.prototype._readOnly = function (property) {\n\t        if (Array.isArray(property)) {\n\t            for (var i = 0; i < property.length; i++) {\n\t                this._readOnly(property[i]);\n\t            }\n\t        } else {\n\t            Object.defineProperty(this, property, {\n\t                writable: false,\n\t                enumerable: true\n\t            });\n\t        }\n\t    };\n\t    /**\n\t\t *  Make an attribute writeable. Interal use only. \n\t\t *  @private\n\t\t *  @param  {string}  property  the property to make writable\n\t\t */\n\t    Tone.prototype._writable = function (property) {\n\t        if (Array.isArray(property)) {\n\t            for (var i = 0; i < property.length; i++) {\n\t                this._writable(property[i]);\n\t            }\n\t        } else {\n\t            Object.defineProperty(this, property, { writable: true });\n\t        }\n\t    };\n\t    /**\n\t\t * Possible play states. \n\t\t * @enum {string}\n\t\t */\n\t    Tone.State = {\n\t        Started: 'started',\n\t        Stopped: 'stopped',\n\t        Paused: 'paused'\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Equal power gain scale. Good for cross-fading.\n\t\t *  @param  {NormalRange} percent (0-1)\n\t\t *  @return {Number}         output gain (0-1)\n\t\t */\n\t    Tone.prototype.equalPowerScale = function (percent) {\n\t        var piFactor = 0.5 * Math.PI;\n\t        return Math.sin(percent * piFactor);\n\t    };\n\t    /**\n\t\t *  Convert decibels into gain.\n\t\t *  @param  {Decibels} db\n\t\t *  @return {Number}   \n\t\t */\n\t    Tone.prototype.dbToGain = function (db) {\n\t        return Math.pow(2, db / 6);\n\t    };\n\t    /**\n\t\t *  Convert gain to decibels.\n\t\t *  @param  {Number} gain (0-1)\n\t\t *  @return {Decibels}   \n\t\t */\n\t    Tone.prototype.gainToDb = function (gain) {\n\t        return 20 * (Math.log(gain) / Math.LN10);\n\t    };\n\t    /**\n\t\t *  Convert an interval (in semitones) to a frequency ratio.\n\t\t *  @param  {Interval} interval the number of semitones above the base note\n\t\t *  @return {number}          the frequency ratio\n\t\t *  @example\n\t\t * tone.intervalToFrequencyRatio(0); // 1\n\t\t * tone.intervalToFrequencyRatio(12); // 2\n\t\t * tone.intervalToFrequencyRatio(-12); // 0.5\n\t\t */\n\t    Tone.prototype.intervalToFrequencyRatio = function (interval) {\n\t        return Math.pow(2, interval / 12);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTIMING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Return the current time of the AudioContext clock.\n\t\t *  @return {Number} the currentTime from the AudioContext\n\t\t */\n\t    Tone.prototype.now = function () {\n\t        return Tone.context.now();\n\t    };\n\t    /**\n\t\t *  Return the current time of the AudioContext clock.\n\t\t *  @return {Number} the currentTime from the AudioContext\n\t\t *  @static\n\t\t */\n\t    Tone.now = function () {\n\t        return Tone.context.now();\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tINHERITANCE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  have a child inherit all of Tone's (or a parent's) prototype\n\t\t *  to inherit the parent's properties, make sure to call \n\t\t *  Parent.call(this) in the child's constructor\n\t\t *\n\t\t *  based on closure library's inherit function\n\t\t *\n\t\t *  @static\n\t\t *  @param  {function} \tchild  \n\t\t *  @param  {function=} parent (optional) parent to inherit from\n\t\t *                             if no parent is supplied, the child\n\t\t *                             will inherit from Tone\n\t\t */\n\t    Tone.extend = function (child, parent) {\n\t        if (Tone.prototype.isUndef(parent)) {\n\t            parent = Tone;\n\t        }\n\t        function TempConstructor() {\n\t        }\n\t        TempConstructor.prototype = parent.prototype;\n\t        child.prototype = new TempConstructor();\n\t        /** @override */\n\t        child.prototype.constructor = child;\n\t        child._super = parent;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCONTEXT\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The private audio context shared by all Tone Nodes. \n\t\t *  @private\n\t\t *  @type {Tone.Context|undefined}\n\t\t */\n\t    var audioContext;\n\t    /**\n\t\t *  A static pointer to the audio context accessible as Tone.context. \n\t\t *  @type {Tone.Context}\n\t\t *  @name context\n\t\t *  @memberOf Tone\n\t\t */\n\t    Object.defineProperty(Tone, 'context', {\n\t        get: function () {\n\t            return audioContext;\n\t        },\n\t        set: function (context) {\n\t            if (Tone.Context && context instanceof Tone.Context) {\n\t                audioContext = context;\n\t            } else {\n\t                audioContext = new Tone.Context(context);\n\t            }\n\t            //initialize the new audio context\n\t            if (Tone.Context) {\n\t                Tone.Context.emit('init', audioContext);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The AudioContext\n\t\t *  @type {Tone.Context}\n\t\t *  @name context\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'context', {\n\t        get: function () {\n\t            return Tone.context;\n\t        }\n\t    });\n\t    /**\n\t\t *  Tone automatically creates a context on init, but if you are working\n\t\t *  with other libraries which also create an AudioContext, it can be\n\t\t *  useful to set your own. If you are going to set your own context, \n\t\t *  be sure to do it at the start of your code, before creating any objects.\n\t\t *  @static\n\t\t *  @param {AudioContext} ctx The new audio context to set\n\t\t */\n\t    Tone.setContext = function (ctx) {\n\t        Tone.context = ctx;\n\t    };\n\t    /**\n\t\t *  The number of seconds of 1 processing block (128 samples)\n\t\t *  @type {Number}\n\t\t *  @name blockTime\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'blockTime', {\n\t        get: function () {\n\t            return 128 / this.context.sampleRate;\n\t        }\n\t    });\n\t    /**\n\t\t *  The duration in seconds of one sample.\n\t\t *  @type {Number}\n\t\t *  @name sampleTime\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'sampleTime', {\n\t        get: function () {\n\t            return 1 / this.context.sampleRate;\n\t        }\n\t    });\n\t    /**\n\t\t *  Whether or not all the technologies that Tone.js relies on are supported by the current browser. \n\t\t *  @type {Boolean}\n\t\t *  @name supported\n\t\t *  @memberOf Tone\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone, 'supported', {\n\t        get: function () {\n\t            var hasAudioContext = window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext');\n\t            var hasPromises = window.hasOwnProperty('Promise');\n\t            var hasWorkers = window.hasOwnProperty('Worker');\n\t            return hasAudioContext && hasPromises && hasWorkers;\n\t        }\n\t    });\n\t    Tone.version = 'r10';\n\t    // allow optional silencing of this log\n\t    if (!window.TONE_SILENCE_VERSION_LOGGING) {\n\t        console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');\n\t    }\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base class for all Signals. Used Internally. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.SignalBase = function () {\n\t    };\n\t    Tone.extend(Tone.SignalBase);\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t */\n\t    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {\n\t        //zero it out so that the signal can have full control\n\t        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {\n\t            //cancel changes\n\t            node._param.cancelScheduledValues(0);\n\t            //reset the value\n\t            node._param.value = 0;\n\t            //mark the value as overridden\n\t            node.overridden = true;\n\t        } else if (node instanceof AudioParam) {\n\t            node.cancelScheduledValues(0);\n\t            node.value = 0;\n\t        }\n\t        Tone.prototype.connect.call(this, node, outputNumber, inputNumber);\n\t        return this;\n\t    };\n\t    return Tone.SignalBase;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Wraps the native Web Audio API \n\t\t *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {function|Array|Number} mapping The function used to define the values. \n\t\t *                                    The mapping function should take two arguments: \n\t\t *                                    the first is the value at the current position \n\t\t *                                    and the second is the array position. \n\t\t *                                    If the argument is an array, that array will be\n\t\t *                                    set as the wave shaping function. The input\n\t\t *                                    signal is an AudioRange [-1, 1] value and the output\n\t\t *                                    signal can take on any numerical values. \n\t\t *                                    \n\t\t *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.\n\t\t *  @example\n\t\t * var timesTwo = new Tone.WaveShaper(function(val){\n\t\t * \treturn val * 2;\n\t\t * }, 2048);\n\t\t *  @example\n\t\t * //a waveshaper can also be constructed with an array of values\n\t\t * var invert = new Tone.WaveShaper([1, -1]);\n\t\t */\n\t    Tone.WaveShaper = function (mapping, bufferLen) {\n\t        /**\n\t\t\t *  the waveshaper\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = this.input = this.output = this.context.createWaveShaper();\n\t        /**\n\t\t\t *  the waveshapers curve\n\t\t\t *  @type {Float32Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._curve = null;\n\t        if (Array.isArray(mapping)) {\n\t            this.curve = mapping;\n\t        } else if (isFinite(mapping) || this.isUndef(mapping)) {\n\t            this._curve = new Float32Array(this.defaultArg(mapping, 1024));\n\t        } else if (this.isFunction(mapping)) {\n\t            this._curve = new Float32Array(this.defaultArg(bufferLen, 1024));\n\t            this.setMap(mapping);\n\t        }\n\t    };\n\t    Tone.extend(Tone.WaveShaper, Tone.SignalBase);\n\t    /**\n\t\t *  Uses a mapping function to set the value of the curve. \n\t\t *  @param {function} mapping The function used to define the values. \n\t\t *                            The mapping function take two arguments: \n\t\t *                            the first is the value at the current position \n\t\t *                            which goes from -1 to 1 over the number of elements\n\t\t *                            in the curve array. The second argument is the array position. \n\t\t *  @returns {Tone.WaveShaper} this\n\t\t *  @example\n\t\t * //map the input signal from [-1, 1] to [0, 10]\n\t\t * shaper.setMap(function(val, index){\n\t\t * \treturn (val + 1) * 5;\n\t\t * })\n\t\t */\n\t    Tone.WaveShaper.prototype.setMap = function (mapping) {\n\t        for (var i = 0, len = this._curve.length; i < len; i++) {\n\t            var normalized = i / (len - 1) * 2 - 1;\n\t            this._curve[i] = mapping(normalized, i);\n\t        }\n\t        this._shaper.curve = this._curve;\n\t        return this;\n\t    };\n\t    /**\n\t\t * The array to set as the waveshaper curve. For linear curves\n\t\t * array length does not make much difference, but for complex curves\n\t\t * longer arrays will provide smoother interpolation. \n\t\t * @memberOf Tone.WaveShaper#\n\t\t * @type {Array}\n\t\t * @name curve\n\t\t */\n\t    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {\n\t        get: function () {\n\t            return this._shaper.curve;\n\t        },\n\t        set: function (mapping) {\n\t            this._curve = new Float32Array(mapping);\n\t            this._shaper.curve = this._curve;\n\t        }\n\t    });\n\t    /**\n\t\t * Specifies what type of oversampling (if any) should be used when \n\t\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\". \n\t\t * @memberOf Tone.WaveShaper#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            if ([\n\t                    'none',\n\t                    '2x',\n\t                    '4x'\n\t                ].indexOf(oversampling) !== -1) {\n\t                this._shaper.oversample = oversampling;\n\t            } else {\n\t                throw new RangeError('Tone.WaveShaper: oversampling must be either \\'none\\', \\'2x\\', or \\'4x\\'');\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.WaveShaper} this\n\t\t */\n\t    Tone.WaveShaper.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._shaper.disconnect();\n\t        this._shaper = null;\n\t        this._curve = null;\n\t        return this;\n\t    };\n\t    return Tone.WaveShaper;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.TimeBase is a flexible encoding of time\n\t\t *         which can be evaluated to and from a string.\n\t\t *         Parsing code modified from https://code.google.com/p/tapdigit/\n\t\t *         Copyright 2011 2012 Ariya Hidayat, New BSD License\n\t\t *  @extends {Tone}\n\t\t *  @param  {Time}  val    The time value as a number or string\n\t\t *  @param  {String=}  units  Unit values\n\t\t *  @example\n\t\t * Tone.TimeBase(4, \"n\")\n\t\t * Tone.TimeBase(2, \"t\")\n\t\t * Tone.TimeBase(\"2t\").add(\"1m\")\n\t\t * Tone.TimeBase(\"2t + 1m\");\n\t\t */\n\t    Tone.TimeBase = function (val, units) {\n\t        //allows it to be constructed with or without 'new'\n\t        if (this instanceof Tone.TimeBase) {\n\t            /**\n\t\t\t\t *  Any expressions parsed from the Time\n\t\t\t\t *  @type  {Array}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._expr = this._noOp;\n\t            if (val instanceof Tone.TimeBase) {\n\t                this.copy(val);\n\t            } else if (!this.isUndef(units) || this.isNumber(val)) {\n\t                //default units\n\t                units = this.defaultArg(units, this._defaultUnits);\n\t                var method = this._primaryExpressions[units].method;\n\t                this._expr = method.bind(this, val);\n\t            } else if (this.isString(val)) {\n\t                this.set(val);\n\t            } else if (this.isUndef(val)) {\n\t                //default expression\n\t                this._expr = this._defaultExpr();\n\t            }\n\t        } else {\n\t            return new Tone.TimeBase(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.TimeBase);\n\t    /**\n\t\t *  Repalce the current time value with the value\n\t\t *  given by the expression string.\n\t\t *  @param  {String}  exprString\n\t\t *  @return {Tone.TimeBase} this\n\t\t */\n\t    Tone.TimeBase.prototype.set = function (exprString) {\n\t        this._expr = this._parseExprString(exprString);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Return a clone of the TimeBase object.\n\t\t *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase\n\t\t */\n\t    Tone.TimeBase.prototype.clone = function () {\n\t        var instance = new this.constructor();\n\t        instance.copy(this);\n\t        return instance;\n\t    };\n\t    /**\n\t\t *  Copies the value of time to this Time\n\t\t *  @param {Tone.TimeBase} time\n\t\t *  @return  {TimeBase}\n\t\t */\n\t    Tone.TimeBase.prototype.copy = function (time) {\n\t        var val = time._expr();\n\t        return this.set(val);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tABSTRACT SYNTAX TREE PARSER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  All the primary expressions.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._primaryExpressions = {\n\t        'n': {\n\t            regexp: /^(\\d+)n/i,\n\t            method: function (value) {\n\t                value = parseInt(value);\n\t                if (value === 1) {\n\t                    return this._beatsToUnits(this._timeSignature());\n\t                } else {\n\t                    return this._beatsToUnits(4 / value);\n\t                }\n\t            }\n\t        },\n\t        't': {\n\t            regexp: /^(\\d+)t/i,\n\t            method: function (value) {\n\t                value = parseInt(value);\n\t                return this._beatsToUnits(8 / (parseInt(value) * 3));\n\t            }\n\t        },\n\t        'm': {\n\t            regexp: /^(\\d+)m/i,\n\t            method: function (value) {\n\t                return this._beatsToUnits(parseInt(value) * this._timeSignature());\n\t            }\n\t        },\n\t        'i': {\n\t            regexp: /^(\\d+)i/i,\n\t            method: function (value) {\n\t                return this._ticksToUnits(parseInt(value));\n\t            }\n\t        },\n\t        'hz': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?)hz/i,\n\t            method: function (value) {\n\t                return this._frequencyToUnits(parseFloat(value));\n\t            }\n\t        },\n\t        'tr': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t            method: function (m, q, s) {\n\t                var total = 0;\n\t                if (m && m !== '0') {\n\t                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));\n\t                }\n\t                if (q && q !== '0') {\n\t                    total += this._beatsToUnits(parseFloat(q));\n\t                }\n\t                if (s && s !== '0') {\n\t                    total += this._beatsToUnits(parseFloat(s) / 4);\n\t                }\n\t                return total;\n\t            }\n\t        },\n\t        's': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?s)/,\n\t            method: function (value) {\n\t                return this._secondsToUnits(parseFloat(value));\n\t            }\n\t        },\n\t        'samples': {\n\t            regexp: /^(\\d+)samples/,\n\t            method: function (value) {\n\t                return parseInt(value) / this.context.sampleRate;\n\t            }\n\t        },\n\t        'default': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?)/,\n\t            method: function (value) {\n\t                return this._primaryExpressions[this._defaultUnits].method.call(this, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  All the binary expressions that TimeBase can accept.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._binaryExpressions = {\n\t        '+': {\n\t            regexp: /^\\+/,\n\t            precedence: 2,\n\t            method: function (lh, rh) {\n\t                return lh() + rh();\n\t            }\n\t        },\n\t        '-': {\n\t            regexp: /^\\-/,\n\t            precedence: 2,\n\t            method: function (lh, rh) {\n\t                return lh() - rh();\n\t            }\n\t        },\n\t        '*': {\n\t            regexp: /^\\*/,\n\t            precedence: 1,\n\t            method: function (lh, rh) {\n\t                return lh() * rh();\n\t            }\n\t        },\n\t        '/': {\n\t            regexp: /^\\//,\n\t            precedence: 1,\n\t            method: function (lh, rh) {\n\t                return lh() / rh();\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  All the unary expressions.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._unaryExpressions = {\n\t        'neg': {\n\t            regexp: /^\\-/,\n\t            method: function (lh) {\n\t                return -lh();\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Syntactic glue which holds expressions together\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._syntaxGlue = {\n\t        '(': { regexp: /^\\(/ },\n\t        ')': { regexp: /^\\)/ }\n\t    };\n\t    /**\n\t\t *  tokenize the expression based on the Expressions object\n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}      returns two methods on the tokenized list, next and peek\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._tokenize = function (expr) {\n\t        var position = -1;\n\t        var tokens = [];\n\t        while (expr.length > 0) {\n\t            expr = expr.trim();\n\t            var token = getNextToken(expr, this);\n\t            tokens.push(token);\n\t            expr = expr.substr(token.value.length);\n\t        }\n\t        function getNextToken(expr, context) {\n\t            var expressions = [\n\t                '_binaryExpressions',\n\t                '_unaryExpressions',\n\t                '_primaryExpressions',\n\t                '_syntaxGlue'\n\t            ];\n\t            for (var i = 0; i < expressions.length; i++) {\n\t                var group = context[expressions[i]];\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    var reg = op.regexp;\n\t                    var match = expr.match(reg);\n\t                    if (match !== null) {\n\t                        return {\n\t                            method: op.method,\n\t                            precedence: op.precedence,\n\t                            regexp: op.regexp,\n\t                            value: match[0]\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);\n\t        }\n\t        return {\n\t            next: function () {\n\t                return tokens[++position];\n\t            },\n\t            peek: function () {\n\t                return tokens[position + 1];\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  Given a token, find the value within the groupName\n\t\t *  @param {Object} token\n\t\t *  @param {String} groupName\n\t\t *  @param {Number} precedence\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {\n\t        var ret = false;\n\t        if (!this.isUndef(token)) {\n\t            for (var opName in group) {\n\t                var op = group[opName];\n\t                if (op.regexp.test(token.value)) {\n\t                    if (!this.isUndef(prec)) {\n\t                        if (op.precedence === prec) {\n\t                            return op;\n\t                        }\n\t                    } else {\n\t                        return op;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  Match a binary expression given the token and the precedence\n\t\t *  @param {Lexer} lexer\n\t\t *  @param {Number} precedence\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {\n\t        if (this.isUndef(precedence)) {\n\t            precedence = 2;\n\t        }\n\t        var expr;\n\t        if (precedence < 0) {\n\t            expr = this._parseUnary(lexer);\n\t        } else {\n\t            expr = this._parseBinary(lexer, precedence - 1);\n\t        }\n\t        var token = lexer.peek();\n\t        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {\n\t            token = lexer.next();\n\t            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));\n\t            token = lexer.peek();\n\t        }\n\t        return expr;\n\t    };\n\t    /**\n\t\t *  Match a unary expression.\n\t\t *  @param {Lexer} lexer\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseUnary = function (lexer) {\n\t        var token, expr;\n\t        token = lexer.peek();\n\t        var op = this._matchGroup(token, this._unaryExpressions);\n\t        if (op) {\n\t            token = lexer.next();\n\t            expr = this._parseUnary(lexer);\n\t            return op.method.bind(this, expr);\n\t        }\n\t        return this._parsePrimary(lexer);\n\t    };\n\t    /**\n\t\t *  Match a primary expression (a value).\n\t\t *  @param {Lexer} lexer\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parsePrimary = function (lexer) {\n\t        var token, expr;\n\t        token = lexer.peek();\n\t        if (this.isUndef(token)) {\n\t            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');\n\t        }\n\t        if (this._matchGroup(token, this._primaryExpressions)) {\n\t            token = lexer.next();\n\t            var matching = token.value.match(token.regexp);\n\t            return token.method.bind(this, matching[1], matching[2], matching[3]);\n\t        }\n\t        if (token && token.value === '(') {\n\t            lexer.next();\n\t            expr = this._parseBinary(lexer);\n\t            token = lexer.next();\n\t            if (!(token && token.value === ')')) {\n\t                throw new SyntaxError('Expected )');\n\t            }\n\t            return expr;\n\t        }\n\t        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);\n\t    };\n\t    /**\n\t\t *  Recursively parse the string expression into a syntax tree.\n\t\t *  @param   {string} expr \n\t\t *  @return  {Function} the bound method to be evaluated later\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseExprString = function (exprString) {\n\t        if (!this.isString(exprString)) {\n\t            exprString = exprString.toString();\n\t        }\n\t        var lexer = this._tokenize(exprString);\n\t        var tree = this._parseBinary(lexer);\n\t        return tree;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tDEFAULTS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The initial expression value\n\t\t *  @return  {Number}  The initial value 0\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._noOp = function () {\n\t        return 0;\n\t    };\n\t    /**\n\t\t *  The default expression value if no arguments are given\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._defaultExpr = function () {\n\t        return this._noOp;\n\t    };\n\t    /**\n\t\t *  The default units if none are given.\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._defaultUnits = 's';\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value of a frequency in the current units\n\t\t *  @param {Frequency} freq\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {\n\t        return 1 / freq;\n\t    };\n\t    /**\n\t\t *  Return the value of the beats in the current units\n\t\t *  @param {Number} beats\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._beatsToUnits = function (beats) {\n\t        return 60 / Tone.Transport.bpm.value * beats;\n\t    };\n\t    /**\n\t\t *  Returns the value of a second in the current units\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {\n\t        return seconds;\n\t    };\n\t    /**\n\t\t *  Returns the value of a tick in the current time units\n\t\t *  @param {Ticks} ticks\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {\n\t        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Return the time signature.\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._timeSignature = function () {\n\t        return Tone.Transport.timeSignature;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Push an expression onto the expression list\n\t\t *  @param  {Time}  val\n\t\t *  @param  {String}  type\n\t\t *  @param  {String}  units\n\t\t *  @return  {Tone.TimeBase} \n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {\n\t        //create the expression\n\t        if (!(val instanceof Tone.TimeBase)) {\n\t            val = new this.constructor(val, units);\n\t        }\n\t        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add to the current value.\n\t\t *  @param  {Time}  val    The value to add\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").add(\"1m\"); //\"3m\"\n\t\t */\n\t    Tone.TimeBase.prototype.add = function (val, units) {\n\t        return this._pushExpr(val, '+', units);\n\t    };\n\t    /**\n\t\t *  Subtract the value from the current time.\n\t\t *  @param  {Time}  val    The value to subtract\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").sub(\"1m\"); //\"1m\"\n\t\t */\n\t    Tone.TimeBase.prototype.sub = function (val, units) {\n\t        return this._pushExpr(val, '-', units);\n\t    };\n\t    /**\n\t\t *  Multiply the current value by the given time.\n\t\t *  @param  {Time}  val    The value to multiply\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").mult(\"2\"); //\"4m\"\n\t\t */\n\t    Tone.TimeBase.prototype.mult = function (val, units) {\n\t        return this._pushExpr(val, '*', units);\n\t    };\n\t    /**\n\t\t *  Divide the current value by the given time.\n\t\t *  @param  {Time}  val    The value to divide by\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").div(2); //\"1m\"\n\t\t */\n\t    Tone.TimeBase.prototype.div = function (val, units) {\n\t        return this._pushExpr(val, '/', units);\n\t    };\n\t    /**\n\t\t *  Evaluate the time value. Returns the time\n\t\t *  in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.TimeBase.prototype.valueOf = function () {\n\t        return this._expr();\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return {Tone.TimeBase} this\n\t\t */\n\t    Tone.TimeBase.prototype.dispose = function () {\n\t        this._expr = null;\n\t    };\n\t    return Tone.TimeBase;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Time is a primitive type for encoding Time values. \n\t\t *         Eventually all time values are evaluated to seconds\n\t\t *         using the `eval` method. Tone.Time can be constructed\n\t\t *         with or without the `new` keyword. Tone.Time can be passed\n\t\t *         into the parameter of any method which takes time as an argument. \n\t\t *  @constructor\n\t\t *  @extends {Tone.TimeBase}\n\t\t *  @param  {String|Number}  val    The time value.\n\t\t *  @param  {String=}  units  The units of the value.\n\t\t *  @example\n\t\t * var t = Tone.Time(\"4n\");//encodes a quarter note\n\t\t * t.mult(4); // multiply that value by 4\n\t\t * t.toNotation(); //returns \"1m\"\n\t\t */\n\t    Tone.Time = function (val, units) {\n\t        if (this instanceof Tone.Time) {\n\t            /**\n\t\t\t\t *  If the current clock time should\n\t\t\t\t *  be added to the output\n\t\t\t\t *  @type  {Boolean}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._plusNow = false;\n\t            Tone.TimeBase.call(this, val, units);\n\t        } else {\n\t            return new Tone.Time(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Time, Tone.TimeBase);\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);\n\t    /*\n\t\t *  Adds an additional unary expression\n\t\t *  which quantizes values to the next subdivision\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._unaryExpressions.quantize = {\n\t        regexp: /^@/,\n\t        method: function (rh) {\n\t            return Tone.Transport.nextSubdivision(rh());\n\t        }\n\t    };\n\t    /*\n\t\t *  Adds an additional unary expression\n\t\t *  which adds the current clock time.\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._unaryExpressions.now = {\n\t        regexp: /^\\+/,\n\t        method: function (lh) {\n\t            this._plusNow = true;\n\t            return lh();\n\t        }\n\t    };\n\t    /**\n\t\t *  Quantize the time by the given subdivision. Optionally add a\n\t\t *  percentage which will move the time value towards the ideal\n\t\t *  quantized value by that percentage. \n\t\t *  @param  {Number|Time}  val    The subdivision to quantize to\n\t\t *  @param  {NormalRange}  [percent=1]  Move the time value\n\t\t *                                   towards the quantized value by\n\t\t *                                   a percentage.\n\t\t *  @return  {Tone.Time}  this\n\t\t *  @example\n\t\t * Tone.Time(21).quantize(2) //returns 22\n\t\t * Tone.Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t\t */\n\t    Tone.Time.prototype.quantize = function (subdiv, percent) {\n\t        percent = this.defaultArg(percent, 1);\n\t        this._expr = function (expr, subdivision, percent) {\n\t            expr = expr();\n\t            subdivision = subdivision.toSeconds();\n\t            var multiple = Math.round(expr / subdivision);\n\t            var ideal = multiple * subdivision;\n\t            var diff = ideal - expr;\n\t            return expr + diff * percent;\n\t        }.bind(this, this._expr, new this.constructor(subdiv), percent);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Adds the clock time to the time expression at the \n\t\t *  moment of evaluation. \n\t\t *  @return  {Tone.Time}  this\n\t\t */\n\t    Tone.Time.prototype.addNow = function () {\n\t        this._plusNow = true;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  @override\n\t\t *  Override the default value return when no arguments are passed in.\n\t\t *  The default value is 'now'\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._defaultExpr = function () {\n\t        this._plusNow = true;\n\t        return this._noOp;\n\t    };\n\t    /**\n\t\t *  Copies the value of time to this Time\n\t\t *  @param {Tone.Time} time\n\t\t *  @return  {Time}\n\t\t */\n\t    Tone.Time.prototype.copy = function (time) {\n\t        Tone.TimeBase.prototype.copy.call(this, time);\n\t        this._plusNow = time._plusNow;\n\t        return this;\n\t    };\n\t    //CONVERSIONS//////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. \n\t\t *  @return {Notation} \n\t\t *  @example\n\t\t * //if the Transport is at 120bpm:\n\t\t * Tone.Time(2).toNotation();//returns \"1m\"\n\t\t */\n\t    Tone.Time.prototype.toNotation = function () {\n\t        var time = this.toSeconds();\n\t        var testNotations = [\n\t            '1m',\n\t            '2n',\n\t            '4n',\n\t            '8n',\n\t            '16n',\n\t            '32n',\n\t            '64n',\n\t            '128n'\n\t        ];\n\t        var retNotation = this._toNotationHelper(time, testNotations);\n\t        //try the same thing but with tripelets\n\t        var testTripletNotations = [\n\t            '1m',\n\t            '2n',\n\t            '2t',\n\t            '4n',\n\t            '4t',\n\t            '8n',\n\t            '8t',\n\t            '16n',\n\t            '16t',\n\t            '32n',\n\t            '32t',\n\t            '64n',\n\t            '64t',\n\t            '128n'\n\t        ];\n\t        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);\n\t        //choose the simpler expression of the two\n\t        if (retTripletNotation.split('+').length < retNotation.split('+').length) {\n\t            return retTripletNotation;\n\t        } else {\n\t            return retNotation;\n\t        }\n\t    };\n\t    /**\n\t\t *  Helper method for Tone.toNotation\n\t\t *  @param {Number} units \n\t\t *  @param {Array} testNotations\n\t\t *  @return {String}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {\n\t        //the threshold is the last value in the array\n\t        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);\n\t        var retNotation = '';\n\t        for (var i = 0; i < testNotations.length; i++) {\n\t            var notationTime = this._notationToUnits(testNotations[i]);\n\t            //account for floating point errors (i.e. round up if the value is 0.999999)\n\t            var multiple = units / notationTime;\n\t            var floatingPointError = 0.000001;\n\t            if (1 - multiple % 1 < floatingPointError) {\n\t                multiple += floatingPointError;\n\t            }\n\t            multiple = Math.floor(multiple);\n\t            if (multiple > 0) {\n\t                if (multiple === 1) {\n\t                    retNotation += testNotations[i];\n\t                } else {\n\t                    retNotation += multiple.toString() + '*' + testNotations[i];\n\t                }\n\t                units -= multiple * notationTime;\n\t                if (units < threshold) {\n\t                    break;\n\t                } else {\n\t                    retNotation += ' + ';\n\t                }\n\t            }\n\t        }\n\t        if (retNotation === '') {\n\t            retNotation = '0';\n\t        }\n\t        return retNotation;\n\t    };\n\t    /**\n\t\t *  Convert a notation value to the current units\n\t\t *  @param  {Notation}  notation \n\t\t *  @return  {Number} \n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._notationToUnits = function (notation) {\n\t        var primaryExprs = this._primaryExpressions;\n\t        var notationExprs = [\n\t            primaryExprs.n,\n\t            primaryExprs.t,\n\t            primaryExprs.m\n\t        ];\n\t        for (var i = 0; i < notationExprs.length; i++) {\n\t            var expr = notationExprs[i];\n\t            var match = notation.match(expr.regexp);\n\t            if (match) {\n\t                return expr.method.call(this, match[1]);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t\t *  @return  {BarsBeatsSixteenths}\n\t\t */\n\t    Tone.Time.prototype.toBarsBeatsSixteenths = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.toSeconds() / quarterTime;\n\t        var measures = Math.floor(quarters / this._timeSignature());\n\t        var sixteenths = quarters % 1 * 4;\n\t        quarters = Math.floor(quarters) % this._timeSignature();\n\t        sixteenths = sixteenths.toString();\n\t        if (sixteenths.length > 3) {\n\t            sixteenths = parseFloat(sixteenths).toFixed(3);\n\t        }\n\t        var progress = [\n\t            measures,\n\t            quarters,\n\t            sixteenths\n\t        ];\n\t        return progress.join(':');\n\t    };\n\t    /**\n\t\t *  Return the time in ticks.\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.Time.prototype.toTicks = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.valueOf() / quarterTime;\n\t        return Math.floor(quarters * Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Return the time in samples\n\t\t *  @return  {Samples}  \n\t\t */\n\t    Tone.Time.prototype.toSamples = function () {\n\t        return this.toSeconds() * this.context.sampleRate;\n\t    };\n\t    /**\n\t\t *  Return the time as a frequency value\n\t\t *  @return  {Frequency} \n\t\t *  @example\n\t\t * Tone.Time(2).toFrequency(); //0.5\n\t\t */\n\t    Tone.Time.prototype.toFrequency = function () {\n\t        return 1 / this.toSeconds();\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.Time.prototype.toSeconds = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the time in milliseconds.\n\t\t *  @return  {Milliseconds} \n\t\t */\n\t    Tone.Time.prototype.toMilliseconds = function () {\n\t        return this.toSeconds() * 1000;\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.Time.prototype.valueOf = function () {\n\t        var val = this._expr();\n\t        return val + (this._plusNow ? this.now() : 0);\n\t    };\n\t    return Tone.Time;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Frequency is a primitive type for encoding Frequency values. \n\t\t *         Eventually all time values are evaluated to hertz\n\t\t *         using the `eval` method. \n\t\t *  @constructor\n\t\t *  @extends {Tone.TimeBase}\n\t\t *  @param  {String|Number}  val    The time value.\n\t\t *  @param  {String=}  units  The units of the value.\n\t\t *  @example\n\t\t * Tone.Frequency(\"C3\") // 261\n\t\t * Tone.Frequency(38, \"midi\") //\n\t\t * Tone.Frequency(\"C3\").transpose(4);\n\t\t */\n\t    Tone.Frequency = function (val, units) {\n\t        if (this instanceof Tone.Frequency) {\n\t            Tone.TimeBase.call(this, val, units);\n\t        } else {\n\t            return new Tone.Frequency(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Frequency, Tone.TimeBase);\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUGMENT BASE EXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);\n\t    /*\n\t\t *  midi type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.midi = {\n\t        regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t        method: function (value) {\n\t            return this.midiToFrequency(value);\n\t        }\n\t    };\n\t    /*\n\t\t *  note type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.note = {\n\t        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t        method: function (pitch, octave) {\n\t            var index = noteToScaleIndex[pitch.toLowerCase()];\n\t            var noteNumber = index + (parseInt(octave) + 1) * 12;\n\t            return this.midiToFrequency(noteNumber);\n\t        }\n\t    };\n\t    /*\n\t\t *  BeatsBarsSixteenths type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.tr = {\n\t        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t        method: function (m, q, s) {\n\t            var total = 1;\n\t            if (m && m !== '0') {\n\t                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));\n\t            }\n\t            if (q && q !== '0') {\n\t                total *= this._beatsToUnits(parseFloat(q));\n\t            }\n\t            if (s && s !== '0') {\n\t                total *= this._beatsToUnits(parseFloat(s) / 4);\n\t            }\n\t            return total;\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Transposes the frequency by the given number of semitones.\n\t\t *  @param  {Interval}  interval\n\t\t *  @return  {Tone.Frequency} this\n\t\t *  @example\n\t\t * Tone.Frequency(\"A4\").transpose(3); //\"C5\"\n\t\t */\n\t    Tone.Frequency.prototype.transpose = function (interval) {\n\t        this._expr = function (expr, interval) {\n\t            var val = expr();\n\t            return val * this.intervalToFrequencyRatio(interval);\n\t        }.bind(this, this._expr, interval);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Takes an array of semitone intervals and returns\n\t\t *  an array of frequencies transposed by those intervals.\n\t\t *  @param  {Array}  intervals\n\t\t *  @return  {Tone.Frequency} this\n\t\t *  @example\n\t\t * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t\t */\n\t    Tone.Frequency.prototype.harmonize = function (intervals) {\n\t        this._expr = function (expr, intervals) {\n\t            var val = expr();\n\t            var ret = [];\n\t            for (var i = 0; i < intervals.length; i++) {\n\t                ret[i] = val * this.intervalToFrequencyRatio(intervals[i]);\n\t            }\n\t            return ret;\n\t        }.bind(this, this._expr, intervals);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Return the value of the frequency as a MIDI note\n\t\t *  @return  {MIDI}\n\t\t *  @example\n\t\t * Tone.Frequency(\"C4\").toMidi(); //60\n\t\t */\n\t    Tone.Frequency.prototype.toMidi = function () {\n\t        return this.frequencyToMidi(this.valueOf());\n\t    };\n\t    /**\n\t\t *  Return the value of the frequency in Scientific Pitch Notation\n\t\t *  @return  {Note}\n\t\t *  @example\n\t\t * Tone.Frequency(69, \"midi\").toNote(); //\"A4\"\n\t\t */\n\t    Tone.Frequency.prototype.toNote = function () {\n\t        var freq = this.valueOf();\n\t        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;\n\t        var noteNumber = Math.round(12 * log) + 57;\n\t        var octave = Math.floor(noteNumber / 12);\n\t        if (octave < 0) {\n\t            noteNumber += -12 * octave;\n\t        }\n\t        var noteName = scaleIndexToNote[noteNumber % 12];\n\t        return noteName + octave.toString();\n\t    };\n\t    /**\n\t\t *  Return the duration of one cycle in seconds.\n\t\t *  @return  {Seconds}\n\t\t */\n\t    Tone.Frequency.prototype.toSeconds = function () {\n\t        return 1 / this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the value in Hertz\n\t\t *  @return  {Frequency}\n\t\t */\n\t    Tone.Frequency.prototype.toFrequency = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the duration of one cycle in ticks\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.Frequency.prototype.toTicks = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.valueOf() / quarterTime;\n\t        return Math.floor(quarters * Tone.Transport.PPQ);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS HELPERS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value of a frequency in the current units\n\t\t *  @param {Frequency} freq\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._frequencyToUnits = function (freq) {\n\t        return freq;\n\t    };\n\t    /**\n\t\t *  Returns the value of a tick in the current time units\n\t\t *  @param {Ticks} ticks\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._ticksToUnits = function (ticks) {\n\t        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));\n\t    };\n\t    /**\n\t\t *  Return the value of the beats in the current units\n\t\t *  @param {Number} beats\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._beatsToUnits = function (beats) {\n\t        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);\n\t    };\n\t    /**\n\t\t *  Returns the value of a second in the current units\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._secondsToUnits = function (seconds) {\n\t        return 1 / seconds;\n\t    };\n\t    /**\n\t\t *  The default units if none are given.\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._defaultUnits = 'hz';\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tFREQUENCY CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Note to scale index\n\t\t *  @type  {Object}\n\t\t */\n\t    var noteToScaleIndex = {\n\t        'cbb': -2,\n\t        'cb': -1,\n\t        'c': 0,\n\t        'c#': 1,\n\t        'cx': 2,\n\t        'dbb': 0,\n\t        'db': 1,\n\t        'd': 2,\n\t        'd#': 3,\n\t        'dx': 4,\n\t        'ebb': 2,\n\t        'eb': 3,\n\t        'e': 4,\n\t        'e#': 5,\n\t        'ex': 6,\n\t        'fbb': 3,\n\t        'fb': 4,\n\t        'f': 5,\n\t        'f#': 6,\n\t        'fx': 7,\n\t        'gbb': 5,\n\t        'gb': 6,\n\t        'g': 7,\n\t        'g#': 8,\n\t        'gx': 9,\n\t        'abb': 7,\n\t        'ab': 8,\n\t        'a': 9,\n\t        'a#': 10,\n\t        'ax': 11,\n\t        'bbb': 9,\n\t        'bb': 10,\n\t        'b': 11,\n\t        'b#': 12,\n\t        'bx': 13\n\t    };\n\t    /**\n\t\t *  scale index to note (sharps)\n\t\t *  @type  {Array}\n\t\t */\n\t    var scaleIndexToNote = [\n\t        'C',\n\t        'C#',\n\t        'D',\n\t        'D#',\n\t        'E',\n\t        'F',\n\t        'F#',\n\t        'G',\n\t        'G#',\n\t        'A',\n\t        'A#',\n\t        'B'\n\t    ];\n\t    /**\n\t\t *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)\n\t\t *  A4's values in Hertz. \n\t\t *  @type {Frequency}\n\t\t *  @static\n\t\t */\n\t    Tone.Frequency.A4 = 440;\n\t    /**\n\t\t *  Convert a MIDI note to frequency value. \n\t\t *  @param  {MIDI} midi The midi number to convert.\n\t\t *  @return {Frequency} the corresponding frequency value\n\t\t *  @example\n\t\t * tone.midiToFrequency(69); // returns 440\n\t\t */\n\t    Tone.Frequency.prototype.midiToFrequency = function (midi) {\n\t        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);\n\t    };\n\t    /**\n\t\t *  Convert a frequency value to a MIDI note.\n\t\t *  @param {Frequency} frequency The value to frequency value to convert.\n\t\t *  @returns  {MIDI}\n\t\t *  @example\n\t\t * tone.midiToFrequency(440); // returns 69\n\t\t */\n\t    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {\n\t        return 69 + 12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2;\n\t    };\n\t    return Tone.Frequency;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.TransportTime is a the time along the Transport's\n\t\t *         timeline. It is similar to Tone.Time, but instead of evaluating\n\t\t *         against the AudioContext's clock, it is evaluated against\n\t\t *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n\t\t *  @constructor\n\t\t *  @param  {Time}  val    The time value as a number or string\n\t\t *  @param  {String=}  units  Unit values\n\t\t *  @extends {Tone.Time}\n\t\t */\n\t    Tone.TransportTime = function (val, units) {\n\t        if (this instanceof Tone.TransportTime) {\n\t            Tone.Time.call(this, val, units);\n\t        } else {\n\t            return new Tone.TransportTime(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.TransportTime, Tone.Time);\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);\n\t    /**\n\t\t *  Adds an additional unary expression\n\t\t *  which quantizes values to the next subdivision\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.TransportTime.prototype._unaryExpressions.quantize = {\n\t        regexp: /^@/,\n\t        method: function (rh) {\n\t            var subdivision = this._secondsToTicks(rh());\n\t            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);\n\t            return this._ticksToUnits(multiple * subdivision);\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert seconds into ticks\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Ticks}\n\t\t *  @private\n\t\t */\n\t    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = seconds / quarterTime;\n\t        return Math.round(quarters * Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Evaluate the time expression. Returns values in ticks\n\t\t *  @return {Ticks}\n\t\t */\n\t    Tone.TransportTime.prototype.valueOf = function () {\n\t        var val = this._secondsToTicks(this._expr());\n\t        return val + (this._plusNow ? Tone.Transport.ticks : 0);\n\t    };\n\t    /**\n\t\t *  Return the time in ticks.\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.TransportTime.prototype.toTicks = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds}\n\t\t */\n\t    Tone.TransportTime.prototype.toSeconds = function () {\n\t        var val = this._expr();\n\t        return val + (this._plusNow ? Tone.Transport.seconds : 0);\n\t    };\n\t    /**\n\t\t *  Return the time as a frequency value\n\t\t *  @return  {Frequency} \n\t\t */\n\t    Tone.TransportTime.prototype.toFrequency = function () {\n\t        return 1 / this.toSeconds();\n\t    };\n\t    return Tone.TransportTime;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Emitter gives classes which extend it\n\t\t *         the ability to listen for and emit events. \n\t\t *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n\t\t *         MIT (c) 2011 Jerome Etienne.\n\t\t *         \n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Emitter = function () {\n\t        /**\n\t\t\t *  Contains all of the events.\n\t\t\t *  @private\n\t\t\t *  @type  {Object}\n\t\t\t */\n\t        this._events = {};\n\t    };\n\t    Tone.extend(Tone.Emitter);\n\t    /**\n\t\t *  Bind a callback to a specific event.\n\t\t *  @param  {String}    event     The name of the event to listen for.\n\t\t *  @param  {Function}  callback  The callback to invoke when the\n\t\t *                                event is emitted\n\t\t *  @return  {Tone.Emitter}    this\n\t\t */\n\t    Tone.Emitter.prototype.on = function (event, callback) {\n\t        //split the event\n\t        var events = event.split(/\\W+/);\n\t        for (var i = 0; i < events.length; i++) {\n\t            var eventName = events[i];\n\t            if (!this._events.hasOwnProperty(eventName)) {\n\t                this._events[eventName] = [];\n\t            }\n\t            this._events[eventName].push(callback);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove the event listener.\n\t\t *  @param  {String}    event     The event to stop listening to.\n\t\t *  @param  {Function=}  callback  The callback which was bound to \n\t\t *                                the event with Tone.Emitter.on.\n\t\t *                                If no callback is given, all callbacks\n\t\t *                                events are removed.\n\t\t *  @return  {Tone.Emitter}    this\n\t\t */\n\t    Tone.Emitter.prototype.off = function (event, callback) {\n\t        var events = event.split(/\\W+/);\n\t        for (var ev = 0; ev < events.length; ev++) {\n\t            event = events[ev];\n\t            if (this._events.hasOwnProperty(event)) {\n\t                if (Tone.prototype.isUndef(callback)) {\n\t                    this._events[event] = [];\n\t                } else {\n\t                    var eventList = this._events[event];\n\t                    for (var i = 0; i < eventList.length; i++) {\n\t                        if (eventList[i] === callback) {\n\t                            eventList.splice(i, 1);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Invoke all of the callbacks bound to the event\n\t\t *  with any arguments passed in. \n\t\t *  @param  {String}  event  The name of the event.\n\t\t *  @param {*...} args The arguments to pass to the functions listening.\n\t\t *  @return  {Tone.Emitter}  this\n\t\t */\n\t    Tone.Emitter.prototype.emit = function (event) {\n\t        if (this._events) {\n\t            var args = Array.apply(null, arguments).slice(1);\n\t            if (this._events.hasOwnProperty(event)) {\n\t                var eventList = this._events[event];\n\t                for (var i = 0, len = eventList.length; i < len; i++) {\n\t                    eventList[i].apply(this, args);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add Emitter functions (on/off/emit) to the object\n\t\t *  @param  {Object|Function}  object  The object or class to extend.\n\t\t */\n\t    Tone.Emitter.mixin = function (object) {\n\t        var functions = [\n\t            'on',\n\t            'off',\n\t            'emit'\n\t        ];\n\t        object._events = {};\n\t        for (var i = 0; i < functions.length; i++) {\n\t            var func = functions[i];\n\t            var emitterFunc = Tone.Emitter.prototype[func];\n\t            object[func] = emitterFunc;\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Emitter}  this\n\t\t */\n\t    Tone.Emitter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._events = null;\n\t        return this;\n\t    };\n\t    return Tone.Emitter;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  shim\n\t\t *  @private\n\t\t */\n\t    if (!window.hasOwnProperty('AudioContext') && window.hasOwnProperty('webkitAudioContext')) {\n\t        window.AudioContext = window.webkitAudioContext;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the native AudioContext.\n\t\t *  @extends {Tone.Emitter}\n\t\t *  @param {AudioContext=} context optionally pass in a context\n\t\t */\n\t    Tone.Context = function (context) {\n\t        Tone.Emitter.call(this);\n\t        if (!context) {\n\t            context = new window.AudioContext();\n\t        }\n\t        this._context = context;\n\t        // extend all of the methods\n\t        for (var prop in this._context) {\n\t            this._defineProperty(this._context, prop);\n\t        }\n\t        ///////////////////////////////////////////////////////////////////////\n\t        // WORKER\n\t        ///////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  The default latency hint\n\t\t\t *  @type  {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._latencyHint = 'interactive';\n\t        /**\n\t\t\t *  The amount of time events are scheduled\n\t\t\t *  into the future\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lookAhead = 0.1;\n\t        /**\n\t\t\t *  How often the update look runs\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._updateInterval = this._lookAhead / 3;\n\t        /**\n\t\t\t *  A reference to the actual computed update interval\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._computedUpdateInterval = 0;\n\t        /**\n\t\t\t *  The web worker which is used to update Tone.Clock\n\t\t\t *  @private\n\t\t\t *  @type  {WebWorker}\n\t\t\t */\n\t        this._worker = this._createWorker();\n\t        /**\n\t\t\t *  An object containing all of the constants AudioBufferSourceNodes\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._constants = {};\n\t    };\n\t    Tone.extend(Tone.Context, Tone.Emitter);\n\t    Tone.Emitter.mixin(Tone.Context);\n\t    /**\n\t\t *  Define a property on this Tone.Context. \n\t\t *  This is used to extend the native AudioContext\n\t\t *  @param  {AudioContext}  context\n\t\t *  @param  {String}  prop \n\t\t *  @private\n\t\t */\n\t    Tone.Context.prototype._defineProperty = function (context, prop) {\n\t        if (this.isUndef(this[prop])) {\n\t            Object.defineProperty(this, prop, {\n\t                get: function () {\n\t                    if (typeof context[prop] === 'function') {\n\t                        return context[prop].bind(context);\n\t                    } else {\n\t                        return context[prop];\n\t                    }\n\t                },\n\t                set: function (val) {\n\t                    context[prop] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    /**\n\t\t *  The current audio context time\n\t\t *  @return  {Number}\n\t\t */\n\t    Tone.Context.prototype.now = function () {\n\t        return this._context.currentTime;\n\t    };\n\t    /**\n\t\t *  Generate a web worker\n\t\t *  @return  {WebWorker}\n\t\t *  @private\n\t\t */\n\t    Tone.Context.prototype._createWorker = function () {\n\t        //URL Shim\n\t        window.URL = window.URL || window.webkitURL;\n\t        var blob = new Blob([//the initial timeout time\n\t            'var timeoutTime = ' + (this._updateInterval * 1000).toFixed(1) + ';' + //onmessage callback\n\t            'self.onmessage = function(msg){' + '\\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message\n\t            //and schedules a new tick\n\t            'function tick(){' + '\\tsetTimeout(tick, timeoutTime);' + '\\tself.postMessage(\\'tick\\');' + '}' + //call tick initially\n\t            'tick();']);\n\t        var blobUrl = URL.createObjectURL(blob);\n\t        var worker = new Worker(blobUrl);\n\t        worker.addEventListener('message', function () {\n\t            // tick the clock\n\t            this.emit('tick');\n\t        }.bind(this));\n\t        //lag compensation\n\t        worker.addEventListener('message', function () {\n\t            var now = this.now();\n\t            if (this.isNumber(this._lastUpdate)) {\n\t                var diff = now - this._lastUpdate;\n\t                this._computedUpdateInterval = Math.max(diff, this._computedUpdateInterval * 0.97);\n\t            }\n\t            this._lastUpdate = now;\n\t        }.bind(this));\n\t        return worker;\n\t    };\n\t    /**\n\t\t *  Generate a looped buffer at some constant value.\n\t\t *  @param  {Number}  val\n\t\t *  @return  {BufferSourceNode}\n\t\t */\n\t    Tone.Context.prototype.getConstant = function (val) {\n\t        if (this._constants[val]) {\n\t            return this._constants[val];\n\t        } else {\n\t            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t            var arr = buffer.getChannelData(0);\n\t            for (var i = 0; i < arr.length; i++) {\n\t                arr[i] = val;\n\t            }\n\t            var constant = this._context.createBufferSource();\n\t            constant.channelCount = 1;\n\t            constant.channelCountMode = 'explicit';\n\t            constant.buffer = buffer;\n\t            constant.loop = true;\n\t            constant.start(0);\n\t            this._constants[val] = constant;\n\t            return constant;\n\t        }\n\t    };\n\t    /**\n\t\t *  This is the time that the clock is falling behind\n\t\t *  the scheduled update interval. The Context automatically\n\t\t *  adjusts for the lag and schedules further in advance.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name lag\n\t\t *  @static\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'lag', {\n\t        get: function () {\n\t            var diff = this._computedUpdateInterval - this._updateInterval;\n\t            diff = Math.max(diff, 0);\n\t            return diff;\n\t        }\n\t    });\n\t    /**\n\t\t *  The amount of time in advance that events are scheduled.\n\t\t *  The lookAhead will adjust slightly in response to the \n\t\t *  measured update time to try to avoid clicks.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name lookAhead\n\t\t *  @static\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'lookAhead', {\n\t        get: function () {\n\t            return this._lookAhead;\n\t        },\n\t        set: function (lA) {\n\t            this._lookAhead = lA;\n\t        }\n\t    });\n\t    /**\n\t\t *  How often the Web Worker callback is invoked.\n\t\t *  This number corresponds to how responsive the scheduling\n\t\t *  can be. Context.updateInterval + Context.lookAhead gives you the\n\t\t *  total latency between scheduling an event and hearing it.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name updateInterval\n\t\t *  @static\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'updateInterval', {\n\t        get: function () {\n\t            return this._updateInterval;\n\t        },\n\t        set: function (interval) {\n\t            this._updateInterval = Math.max(interval, Tone.prototype.blockTime);\n\t            this._worker.postMessage(Math.max(interval * 1000, 1));\n\t        }\n\t    });\n\t    /**\n\t\t *  The type of playback, which affects tradeoffs between audio \n\t\t *  output latency and responsiveness. \n\t\t *  \n\t\t *  In addition to setting the value in seconds, the latencyHint also\n\t\t *  accepts the strings \"interactive\" (prioritizes low latency), \n\t\t *  \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t\t *  latency and performance), and \"fastest\" (lowest latency, might glitch more often). \n\t\t *  @type {String|Seconds}\n\t\t *  @memberOf Tone.Context#\n\t\t *  @name latencyHint\n\t\t *  @static\n\t\t *  @example\n\t\t * //set the lookAhead to 0.3 seconds\n\t\t * Tone.context.latencyHint = 0.3;\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'latencyHint', {\n\t        get: function () {\n\t            return this._latencyHint;\n\t        },\n\t        set: function (hint) {\n\t            var lookAhead = hint;\n\t            this._latencyHint = hint;\n\t            if (this.isString(hint)) {\n\t                switch (hint) {\n\t                case 'interactive':\n\t                    lookAhead = 0.1;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'playback':\n\t                    lookAhead = 0.8;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'balanced':\n\t                    lookAhead = 0.25;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'fastest':\n\t                    lookAhead = 0.01;\n\t                    break;\n\t                }\n\t            }\n\t            this.lookAhead = lookAhead;\n\t            this.updateInterval = lookAhead / 3;\n\t        }\n\t    });\n\t    /**\n\t\t *  Shim all connect/disconnect and some deprecated methods which are still in\n\t\t *  some older implementations.\n\t\t *  @private\n\t\t */\n\t    function shimConnect() {\n\t        var nativeConnect = AudioNode.prototype.connect;\n\t        var nativeDisconnect = AudioNode.prototype.disconnect;\n\t        //replace the old connect method\n\t        function toneConnect(B, outNum, inNum) {\n\t            if (B.input) {\n\t                if (Array.isArray(B.input)) {\n\t                    if (Tone.prototype.isUndef(inNum)) {\n\t                        inNum = 0;\n\t                    }\n\t                    this.connect(B.input[inNum]);\n\t                } else {\n\t                    this.connect(B.input, outNum, inNum);\n\t                }\n\t            } else {\n\t                try {\n\t                    if (B instanceof AudioNode) {\n\t                        nativeConnect.call(this, B, outNum, inNum);\n\t                    } else {\n\t                        nativeConnect.call(this, B, outNum);\n\t                    }\n\t                } catch (e) {\n\t                    throw new Error('error connecting to node: ' + B + '\\n' + e);\n\t                }\n\t            }\n\t        }\n\t        //replace the old disconnect method\n\t        function toneDisconnect(B, outNum, inNum) {\n\t            if (B && B.input && Array.isArray(B.input)) {\n\t                if (Tone.prototype.isUndef(inNum)) {\n\t                    inNum = 0;\n\t                }\n\t                this.disconnect(B.input[inNum], outNum, inNum);\n\t            } else if (B && B.input) {\n\t                this.disconnect(B.input, outNum, inNum);\n\t            } else {\n\t                try {\n\t                    nativeDisconnect.apply(this, arguments);\n\t                } catch (e) {\n\t                    throw new Error('error disconnecting node: ' + B + '\\n' + e);\n\t                }\n\t            }\n\t        }\n\t        if (AudioNode.prototype.connect !== toneConnect) {\n\t            AudioNode.prototype.connect = toneConnect;\n\t            AudioNode.prototype.disconnect = toneDisconnect;\n\t        }\n\t    }\n\t    // set the audio context initially\n\t    if (Tone.supported) {\n\t        shimConnect();\n\t        Tone.context = new Tone.Context();\n\t    } else {\n\t        console.warn('This browser does not support Tone.js');\n\t    }\n\t    return Tone.Context;\n\t});\n\tModule(function (Tone) {\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTYPES\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t * Units which a value can take on.\n\t\t * @enum {String}\n\t\t */\n\t    Tone.Type = {\n\t        /** \n\t\t\t *  Default units\n\t\t\t *  @typedef {Default}\n\t\t\t */\n\t        Default: 'number',\n\t        /**\n\t\t\t *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).\n\t\t\t *\n\t\t\t *  <ul>\n\t\t\t *  <li>Numbers, which will be taken literally as the time (in seconds).</li>\n\t\t\t *  <li>Notation, (\"4n\", \"8t\") describes time in BPM and time signature relative values.</li>\n\t\t\t *  <li>TransportTime, (\"4:3:2\") will also provide tempo and time signature relative times \n\t\t\t *  in the form BARS:QUARTERS:SIXTEENTHS.</li>\n\t\t\t *  <li>Frequency, (\"8hz\") is converted to the length of the cycle in seconds.</li>\n\t\t\t *  <li>Now-Relative, (\"+1\") prefix any of the above with \"+\" and it will be interpreted as \n\t\t\t *  \"the current time plus whatever expression follows\".</li>\n\t\t\t *  <li>Expressions, (\"3:0 + 2 - (1m / 7)\") any of the above can also be combined \n\t\t\t *  into a mathematical expression which will be evaluated to compute the desired time.</li>\n\t\t\t *  <li>No Argument, for methods which accept time, no argument will be interpreted as \n\t\t\t *  \"now\" (i.e. the currentTime).</li>\n\t\t\t *  </ul>\n\t\t\t *  \n\t\t\t *  @typedef {Time}\n\t\t\t */\n\t        Time: 'time',\n\t        /**\n\t\t\t *  Frequency can be described similar to time, except ultimately the\n\t\t\t *  values are converted to frequency instead of seconds. A number\n\t\t\t *  is taken literally as the value in hertz. Additionally any of the \n\t\t\t *  Time encodings can be used. Note names in the form\n\t\t\t *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their\n\t\t\t *  frequency value. \n\t\t\t *  @typedef {Frequency}\n\t\t\t */\n\t        Frequency: 'frequency',\n\t        /**\n\t\t\t *  TransportTime describes a position along the Transport's timeline. It is\n\t\t\t *  similar to Time in that it uses all the same encodings, but TransportTime specifically\n\t\t\t *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable. \n\t\t\t *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)\n\t\t\t *  @typedef {TransportTime}\n\t\t\t */\n\t        TransportTime: 'transportTime',\n\t        /** \n\t\t\t *  Ticks are the basic subunit of the Transport. They are\n\t\t\t *  the smallest unit of time that the Transport supports.\n\t\t\t *  @typedef {Ticks}\n\t\t\t */\n\t        Ticks: 'ticks',\n\t        /** \n\t\t\t *  Normal values are within the range [0, 1].\n\t\t\t *  @typedef {NormalRange}\n\t\t\t */\n\t        NormalRange: 'normalRange',\n\t        /** \n\t\t\t *  AudioRange values are between [-1, 1].\n\t\t\t *  @typedef {AudioRange}\n\t\t\t */\n\t        AudioRange: 'audioRange',\n\t        /** \n\t\t\t *  Decibels are a logarithmic unit of measurement which is useful for volume\n\t\t\t *  because of the logarithmic way that we perceive loudness. 0 decibels \n\t\t\t *  means no change in volume. -10db is approximately half as loud and 10db \n\t\t\t *  is twice is loud. \n\t\t\t *  @typedef {Decibels}\n\t\t\t */\n\t        Decibels: 'db',\n\t        /** \n\t\t\t *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.\n\t\t\t *  @typedef {Interval}\n\t\t\t */\n\t        Interval: 'interval',\n\t        /** \n\t\t\t *  Beats per minute. \n\t\t\t *  @typedef {BPM}\n\t\t\t */\n\t        BPM: 'bpm',\n\t        /** \n\t\t\t *  The value must be greater than or equal to 0.\n\t\t\t *  @typedef {Positive}\n\t\t\t */\n\t        Positive: 'positive',\n\t        /** \n\t\t\t *  A cent is a hundredth of a semitone. \n\t\t\t *  @typedef {Cents}\n\t\t\t */\n\t        Cents: 'cents',\n\t        /** \n\t\t\t *  Angle between 0 and 360. \n\t\t\t *  @typedef {Degrees}\n\t\t\t */\n\t        Degrees: 'degrees',\n\t        /** \n\t\t\t *  A number representing a midi note.\n\t\t\t *  @typedef {MIDI}\n\t\t\t */\n\t        MIDI: 'midi',\n\t        /** \n\t\t\t *  A colon-separated representation of time in the form of\n\t\t\t *  Bars:Beats:Sixteenths. \n\t\t\t *  @typedef {BarsBeatsSixteenths}\n\t\t\t */\n\t        BarsBeatsSixteenths: 'barsBeatsSixteenths',\n\t        /** \n\t\t\t *  Sampling is the reduction of a continuous signal to a discrete signal.\n\t\t\t *  Audio is typically sampled 44100 times per second. \n\t\t\t *  @typedef {Samples}\n\t\t\t */\n\t        Samples: 'samples',\n\t        /** \n\t\t\t *  Hertz are a frequency representation defined as one cycle per second.\n\t\t\t *  @typedef {Hertz}\n\t\t\t */\n\t        Hertz: 'hertz',\n\t        /** \n\t\t\t *  A frequency represented by a letter name, \n\t\t\t *  accidental and octave. This system is known as\n\t\t\t *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).\n\t\t\t *  @typedef {Note}\n\t\t\t */\n\t        Note: 'note',\n\t        /** \n\t\t\t *  One millisecond is a thousandth of a second. \n\t\t\t *  @typedef {Milliseconds}\n\t\t\t */\n\t        Milliseconds: 'milliseconds',\n\t        /** \n\t\t\t *  Seconds are the time unit of the AudioContext. In the end, \n\t\t\t *  all values need to be evaluated to seconds. \n\t\t\t *  @typedef {Seconds}\n\t\t\t */\n\t        Seconds: 'seconds',\n\t        /** \n\t\t\t *  A string representing a duration relative to a measure. \n\t\t\t *  <ul>\n\t\t\t *  \t<li>\"4n\" = quarter note</li>\n\t\t\t *   \t<li>\"2m\" = two measures</li>\n\t\t\t *    \t<li>\"8t\" = eighth-note triplet</li>\n\t\t\t *  </ul>\n\t\t\t *  @typedef {Notation}\n\t\t\t */\n\t        Notation: 'notation'\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // AUGMENT TONE's PROTOTYPE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Convert Time into seconds.\n\t\t *  \n\t\t *  Unlike the method which it overrides, this takes into account \n\t\t *  transporttime and musical notation.\n\t\t *\n\t\t *  Time : 1.40\n\t\t *  Notation: 4n|1m|2t\n\t\t *  Now Relative: +3n\n\t\t *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)\n\t\t *\n\t\t *  @param  {Time} time \n\t\t *  @return {Seconds} \n\t\t */\n\t    Tone.prototype.toSeconds = function (time) {\n\t        if (this.isNumber(time)) {\n\t            return time;\n\t        } else if (this.isUndef(time)) {\n\t            return this.now();\n\t        } else if (this.isString(time)) {\n\t            return new Tone.Time(time).toSeconds();\n\t        } else if (time instanceof Tone.TimeBase) {\n\t            return time.toSeconds();\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert a frequency representation into a number.\n\t\t *  @param  {Frequency} freq \n\t\t *  @return {Hertz}      the frequency in hertz\n\t\t */\n\t    Tone.prototype.toFrequency = function (freq) {\n\t        if (this.isNumber(freq)) {\n\t            return freq;\n\t        } else if (this.isString(freq) || this.isUndef(freq)) {\n\t            return new Tone.Frequency(freq).valueOf();\n\t        } else if (freq instanceof Tone.TimeBase) {\n\t            return freq.toFrequency();\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert a time representation into ticks.\n\t\t *  @param  {Time} time\n\t\t *  @return {Ticks}  the time in ticks\n\t\t */\n\t    Tone.prototype.toTicks = function (time) {\n\t        if (this.isNumber(time) || this.isString(time)) {\n\t            return new Tone.TransportTime(time).toTicks();\n\t        } else if (this.isUndef(time)) {\n\t            return Tone.Transport.ticks;\n\t        } else if (time instanceof Tone.TimeBase) {\n\t            return time.toTicks();\n\t        }\n\t    };\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Param wraps the native Web Audio's AudioParam to provide\n\t\t *         additional unit conversion functionality. It also\n\t\t *         serves as a base-class for classes which have a single,\n\t\t *         automatable parameter. \n\t\t *  @extends {Tone}\n\t\t *  @param  {AudioParam}  param  The parameter to wrap.\n\t\t *  @param  {Tone.Type} units The units of the audio param.\n\t\t *  @param  {Boolean} convert If the param should be converted.\n\t\t */\n\t    Tone.Param = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'param',\n\t            'units',\n\t            'convert'\n\t        ], Tone.Param.defaults);\n\t        /**\n\t\t\t *  The native parameter to control\n\t\t\t *  @type  {AudioParam}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input = options.param;\n\t        /**\n\t\t\t *  The units of the parameter\n\t\t\t *  @type {Tone.Type}\n\t\t\t */\n\t        this.units = options.units;\n\t        /**\n\t\t\t *  If the value should be converted or not\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.convert = options.convert;\n\t        /**\n\t\t\t *  True if the signal value is being overridden by \n\t\t\t *  a connected signal.\n\t\t\t *  @readOnly\n\t\t\t *  @type  {boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this.overridden = false;\n\t        /**\n\t\t\t *  If there is an LFO, this is where it is held.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = null;\n\t        if (this.isObject(options.lfo)) {\n\t            this.value = options.lfo;\n\t        } else if (!this.isUndef(options.value)) {\n\t            this.value = options.value;\n\t        }\n\t    };\n\t    Tone.extend(Tone.Param);\n\t    /**\n\t\t *  Defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Param.defaults = {\n\t        'units': Tone.Type.Default,\n\t        'convert': true,\n\t        'param': undefined\n\t    };\n\t    /**\n\t\t * The current value of the parameter. \n\t\t * @memberOf Tone.Param#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Param.prototype, 'value', {\n\t        get: function () {\n\t            return this._toUnits(this._param.value);\n\t        },\n\t        set: function (value) {\n\t            if (this.isObject(value)) {\n\t                //throw an error if the LFO needs to be included\n\t                if (this.isUndef(Tone.LFO)) {\n\t                    throw new Error('Include \\'Tone.LFO\\' to use an LFO as a Param value.');\n\t                }\n\t                //remove the old one\n\t                if (this._lfo) {\n\t                    this._lfo.dispose();\n\t                }\n\t                this._lfo = new Tone.LFO(value).start();\n\t                this._lfo.connect(this.input);\n\t            } else {\n\t                var convertedVal = this._fromUnits(value);\n\t                this._param.cancelScheduledValues(0);\n\t                this._param.value = convertedVal;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Convert the given value from the type specified by Tone.Param.units\n\t\t *  into the destination value (such as Gain or Frequency).\n\t\t *  @private\n\t\t *  @param  {*} val the value to convert\n\t\t *  @return {number}     the number which the value should be set to\n\t\t */\n\t    Tone.Param.prototype._fromUnits = function (val) {\n\t        if (this.convert || this.isUndef(this.convert)) {\n\t            switch (this.units) {\n\t            case Tone.Type.Time:\n\t                return this.toSeconds(val);\n\t            case Tone.Type.Frequency:\n\t                return this.toFrequency(val);\n\t            case Tone.Type.Decibels:\n\t                return this.dbToGain(val);\n\t            case Tone.Type.NormalRange:\n\t                return Math.min(Math.max(val, 0), 1);\n\t            case Tone.Type.AudioRange:\n\t                return Math.min(Math.max(val, -1), 1);\n\t            case Tone.Type.Positive:\n\t                return Math.max(val, 0);\n\t            default:\n\t                return val;\n\t            }\n\t        } else {\n\t            return val;\n\t        }\n\t    };\n\t    /**\n\t\t * Convert the parameters value into the units specified by Tone.Param.units.\n\t\t * @private\n\t\t * @param  {number} val the value to convert\n\t\t * @return {number}\n\t\t */\n\t    Tone.Param.prototype._toUnits = function (val) {\n\t        if (this.convert || this.isUndef(this.convert)) {\n\t            switch (this.units) {\n\t            case Tone.Type.Decibels:\n\t                return this.gainToDb(val);\n\t            default:\n\t                return val;\n\t            }\n\t        } else {\n\t            return val;\n\t        }\n\t    };\n\t    /**\n\t\t *  the minimum output value\n\t\t *  @type {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Param.prototype._minOutput = 0.00001;\n\t    /**\n\t\t *  Schedules a parameter value change at the given time.\n\t\t *  @param {*}\tvalue The value to set the signal.\n\t\t *  @param {Time}  time The time when the change should occur.\n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //set the frequency to \"G4\" in exactly 1 second from now. \n\t\t * freq.setValueAtTime(\"G4\", \"+1\");\n\t\t */\n\t    Tone.Param.prototype.setValueAtTime = function (value, time) {\n\t        value = this._fromUnits(value);\n\t        time = this.toSeconds(time);\n\t        if (time <= this.now() + this.blockTime) {\n\t            this._param.value = value;\n\t        } else {\n\t            this._param.setValueAtTime(value, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Creates a schedule point with the current value at the current time.\n\t\t *  This is useful for creating an automation anchor point in order to \n\t\t *  schedule changes from the current value. \n\t\t *\n\t\t *  @param {number=} now (Optionally) pass the now value in. \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.setRampPoint = function (now) {\n\t        now = this.defaultArg(now, this.now());\n\t        var currentVal = this._param.value;\n\t        // exponentialRampToValueAt cannot ever ramp from or to 0\n\t        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2\n\t        if (currentVal === 0) {\n\t            currentVal = this._minOutput;\n\t        }\n\t        this._param.setValueAtTime(currentVal, now);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules a linear continuous change in parameter value from the \n\t\t *  previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        this._param.linearRampToValueAtTime(value, this.toSeconds(endTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        value = Math.max(this._minOutput, value);\n\t        this._param.exponentialRampToValueAtTime(value, this.toSeconds(endTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the current time and current value to the given value over the \n\t\t *  duration of the rampTime.\n\t\t *  \n\t\t *  @param  {number} value   The value to ramp to.\n\t\t *  @param  {Time} rampTime the time that it takes the \n\t\t *                               value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //exponentially ramp to the value 2 over 4 seconds. \n\t\t * signal.exponentialRampToValue(2, 4);\n\t\t */\n\t    Tone.Param.prototype.exponentialRampToValue = function (value, rampTime, startTime) {\n\t        startTime = this.toSeconds(startTime);\n\t        this.setRampPoint(startTime);\n\t        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an linear continuous change in parameter value from \n\t\t *  the current time and current value to the given value over the \n\t\t *  duration of the rampTime.\n\t\t *  \n\t\t *  @param  {number} value   The value to ramp to.\n\t\t *  @param  {Time} rampTime the time that it takes the \n\t\t *                               value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //linearly ramp to the value 4 over 3 seconds. \n\t\t * signal.linearRampToValue(4, 3);\n\t\t */\n\t    Tone.Param.prototype.linearRampToValue = function (value, rampTime, startTime) {\n\t        startTime = this.toSeconds(startTime);\n\t        this.setRampPoint(startTime);\n\t        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start exponentially approaching the target value at the given time with\n\t\t *  a rate having the given time constant.\n\t\t *  @param {number} value        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {number} timeConstant \n\t\t *  @returns {Tone.Param} this \n\t\t */\n\t    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n\t        value = this._fromUnits(value);\n\t        // The value will never be able to approach without timeConstant > 0.\n\t        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation\n\t        // is described. 0 results in a division by 0.\n\t        value = Math.max(this._minOutput, value);\n\t        timeConstant = Math.max(this._minOutput, timeConstant);\n\t        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets an array of arbitrary parameter values starting at the given time\n\t\t *  for the given duration.\n\t\t *  \t\n\t\t *  @param {Array} values    \n\t\t *  @param {Time} startTime \n\t\t *  @param {Time} duration  \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {\n\t        for (var i = 0; i < values.length; i++) {\n\t            values[i] = this._fromUnits(values[i]);\n\t        }\n\t        this._param.setValueCurveAtTime(values, this.toSeconds(startTime), this.toSeconds(duration));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled parameter changes with times greater than or \n\t\t *  equal to startTime.\n\t\t *  \n\t\t *  @param  {Time} startTime\n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.cancelScheduledValues = function (startTime) {\n\t        this._param.cancelScheduledValues(this.toSeconds(startTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Ramps to the given value over the duration of the rampTime. \n\t\t *  Automatically selects the best ramp type (exponential or linear)\n\t\t *  depending on the `units` of the signal\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} rampTime \tThe time that it takes the \n\t\t *                              value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //ramp to the value either linearly or exponentially \n\t\t * //depending on the \"units\" value of the signal\n\t\t * signal.rampTo(0, 10);\n\t\t *  @example\n\t\t * //schedule it to ramp starting at a specific time\n\t\t * signal.rampTo(0, 10, 5)\n\t\t */\n\t    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {\n\t        rampTime = this.defaultArg(rampTime, 0);\n\t        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {\n\t            this.exponentialRampToValue(value, rampTime, startTime);\n\t        } else {\n\t            this.linearRampToValue(value, rampTime, startTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The LFO created by the signal instance. If none\n\t\t *  was created, this is null.\n\t\t *  @type {Tone.LFO}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Param#\n\t\t *  @name lfo\n\t\t */\n\t    Object.defineProperty(Tone.Param.prototype, 'lfo', {\n\t        get: function () {\n\t            return this._lfo;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._param = null;\n\t        if (this._lfo) {\n\t            this._lfo.dispose();\n\t            this._lfo = null;\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Param;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  createGain shim\n\t\t *  @private\n\t\t */\n\t    if (window.GainNode && !AudioContext.prototype.createGain) {\n\t        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n\t    }\n\t    /**\n\t\t *  @class A thin wrapper around the Native Web Audio GainNode.\n\t\t *         The GainNode is a basic building block of the Web Audio\n\t\t *         API and is useful for routing audio and adjusting gains. \n\t\t *  @extends {Tone}\n\t\t *  @param  {Number=}  gain  The initial gain of the GainNode\n\t\t *  @param {Tone.Type=} units The units of the gain parameter. \n\t\t */\n\t    Tone.Gain = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'gain',\n\t            'units'\n\t        ], Tone.Gain.defaults);\n\t        /**\n\t\t\t *  The GainNode\n\t\t\t *  @type  {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = this.output = this._gainNode = this.context.createGain();\n\t        /**\n\t\t\t *  The gain parameter of the gain node.\n\t\t\t *  @type {Tone.Param}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.gain = new Tone.Param({\n\t            'param': this._gainNode.gain,\n\t            'units': options.units,\n\t            'value': options.gain,\n\t            'convert': options.convert\n\t        });\n\t        this._readOnly('gain');\n\t    };\n\t    Tone.extend(Tone.Gain);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Gain.defaults = {\n\t        'gain': 1,\n\t        'convert': true\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Gain}  this\n\t\t */\n\t    Tone.Gain.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._gainNode.disconnect();\n\t        this._gainNode = null;\n\t        this._writable('gain');\n\t        this.gain.dispose();\n\t        this.gain = null;\n\t    };\n\t    //STATIC///////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Create input and outputs for this object.\n\t\t *  @param  {Number}  input   The number of inputs\n\t\t *  @param  {Number=}  outputs  The number of outputs\n\t\t *  @return  {Tone}  this\n\t\t *  @internal\n\t\t */\n\t    Tone.prototype.createInsOuts = function (inputs, outputs) {\n\t        if (inputs === 1) {\n\t            this.input = new Tone.Gain();\n\t        } else if (inputs > 1) {\n\t            this.input = new Array(inputs);\n\t        }\n\t        if (outputs === 1) {\n\t            this.output = new Tone.Gain();\n\t        } else if (outputs > 1) {\n\t            this.output = new Array(inputs);\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    return Tone.Gain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.\n\t\t *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n\t\t *          has all of the methods available to native Web Audio \n\t\t *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n\t\t *          as well as additional conveniences. Read more about working with signals \n\t\t *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Param}\n\t\t *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam\n\t\t *                                     is passed in, that parameter will be wrapped\n\t\t *                                     and controlled by the Signal. \n\t\t *  @param {string} [units=Number] unit The units the signal is in. \n\t\t *  @example\n\t\t * var signal = new Tone.Signal(10);\n\t\t */\n\t    Tone.Signal = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'value',\n\t            'units'\n\t        ], Tone.Signal.defaults);\n\t        /**\n\t\t\t * The node where the constant signal value is scaled.\n\t\t\t * @type {GainNode}\n\t\t\t * @private\n\t\t\t */\n\t        this.output = this._gain = this.context.createGain();\n\t        options.param = this._gain.gain;\n\t        Tone.Param.call(this, options);\n\t        /**\n\t\t\t * The node where the value is set.\n\t\t\t * @type {Tone.Param}\n\t\t\t * @private\n\t\t\t */\n\t        this.input = this._param = this._gain.gain;\n\t        //connect the const output to the node output\n\t        this.context.getConstant(1).chain(this._gain);\n\t    };\n\t    Tone.extend(Tone.Signal, Tone.Param);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Signal.defaults = {\n\t        'value': 0,\n\t        'units': Tone.Type.Default,\n\t        'convert': true\n\t    };\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t *  @method\n\t\t */\n\t    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;\n\t    /**\n\t\t *  dispose and disconnect\n\t\t *  @returns {Tone.Signal} this\n\t\t */\n\t    Tone.Signal.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._param = null;\n\t        this._gain.disconnect();\n\t        this._gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Signal;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A Timeline class for scheduling and maintaining state\n\t\t *         along a timeline. All events must have a \"time\" property. \n\t\t *         Internally, events are stored in time order for fast \n\t\t *         retrieval.\n\t\t *  @extends {Tone}\n\t\t *  @param {Positive} [memory=Infinity] The number of previous events that are retained.\n\t\t */\n\t    Tone.Timeline = function () {\n\t        var options = this.optionsObject(arguments, ['memory'], Tone.Timeline.defaults);\n\t        /**\n\t\t\t *  The array of scheduled timeline events\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeline = [];\n\t        /**\n\t\t\t *  An array of items to remove from the list. \n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._toRemove = [];\n\t        /**\n\t\t\t *  Flag if the tieline is mid iteration\n\t\t\t *  @private\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this._iterating = false;\n\t        /**\n\t\t\t *  The memory of the timeline, i.e.\n\t\t\t *  how many events in the past it will retain\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this.memory = options.memory;\n\t    };\n\t    Tone.extend(Tone.Timeline);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Timeline.defaults = { 'memory': Infinity };\n\t    /**\n\t\t *  The number of items in the timeline.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Timeline#\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Timeline.prototype, 'length', {\n\t        get: function () {\n\t            return this._timeline.length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t\t *  @param  {Object}  event  The event object to insert into the \n\t\t *                           timeline. \n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.add = function (event) {\n\t        //the event needs to have a time attribute\n\t        if (this.isUndef(event.time)) {\n\t            throw new Error('Tone.Timeline: events must have a time attribute');\n\t        }\n\t        if (this._timeline.length) {\n\t            var index = this._search(event.time);\n\t            this._timeline.splice(index + 1, 0, event);\n\t        } else {\n\t            this._timeline.push(event);\n\t        }\n\t        //if the length is more than the memory, remove the previous ones\n\t        if (this.length > this.memory) {\n\t            var diff = this.length - this.memory;\n\t            this._timeline.splice(0, diff);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove an event from the timeline.\n\t\t *  @param  {Object}  event  The event object to remove from the list.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.remove = function (event) {\n\t        if (this._iterating) {\n\t            this._toRemove.push(event);\n\t        } else {\n\t            var index = this._timeline.indexOf(event);\n\t            if (index !== -1) {\n\t                this._timeline.splice(index, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the nearest event whose time is less than or equal to the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object set after that time.\n\t\t */\n\t    Tone.Timeline.prototype.get = function (time) {\n\t        var index = this._search(time);\n\t        if (index !== -1) {\n\t            return this._timeline[index];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Return the first event in the timeline without removing it\n\t\t *  @returns {Object} The first event object\n\t\t */\n\t    Tone.Timeline.prototype.peek = function () {\n\t        return this._timeline[0];\n\t    };\n\t    /**\n\t\t *  Return the first event in the timeline and remove it\n\t\t *  @returns {Object} The first event object\n\t\t */\n\t    Tone.Timeline.prototype.shift = function () {\n\t        return this._timeline.shift();\n\t    };\n\t    /**\n\t\t *  Get the event which is scheduled after the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object after the given time\n\t\t */\n\t    Tone.Timeline.prototype.getAfter = function (time) {\n\t        var index = this._search(time);\n\t        if (index + 1 < this._timeline.length) {\n\t            return this._timeline[index + 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Get the event before the event at the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object before the given time\n\t\t */\n\t    Tone.Timeline.prototype.getBefore = function (time) {\n\t        var len = this._timeline.length;\n\t        //if it's after the last item, return the last item\n\t        if (len > 0 && this._timeline[len - 1].time < time) {\n\t            return this._timeline[len - 1];\n\t        }\n\t        var index = this._search(time);\n\t        if (index - 1 >= 0) {\n\t            return this._timeline[index - 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Cancel events after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.cancel = function (after) {\n\t        if (this._timeline.length > 1) {\n\t            var index = this._search(after);\n\t            if (index >= 0) {\n\t                if (this._timeline[index].time === after) {\n\t                    //get the first item with that time\n\t                    for (var i = index; i >= 0; i--) {\n\t                        if (this._timeline[i].time === after) {\n\t                            index = i;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    }\n\t                    this._timeline = this._timeline.slice(0, index);\n\t                } else {\n\t                    this._timeline = this._timeline.slice(0, index + 1);\n\t                }\n\t            } else {\n\t                this._timeline = [];\n\t            }\n\t        } else if (this._timeline.length === 1) {\n\t            //the first item's time\n\t            if (this._timeline[0].time >= after) {\n\t                this._timeline = [];\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel events before or equal to the given time.\n\t\t *  @param  {Number}  time  The time to cancel before.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.cancelBefore = function (time) {\n\t        if (this._timeline.length) {\n\t            var index = this._search(time);\n\t            if (index >= 0) {\n\t                this._timeline = this._timeline.slice(index + 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Does a binary serach on the timeline array and returns the \n\t\t *  nearest event index whose time is after or equal to the given time.\n\t\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t\t *  If the time is after the end, the index of the last item is returned.\n\t\t *  @param  {Number}  time  \n\t\t *  @return  {Number} the index in the timeline array \n\t\t *  @private\n\t\t */\n\t    Tone.Timeline.prototype._search = function (time) {\n\t        var beginning = 0;\n\t        var len = this._timeline.length;\n\t        var end = len;\n\t        if (len > 0 && this._timeline[len - 1].time <= time) {\n\t            return len - 1;\n\t        }\n\t        while (beginning < end) {\n\t            // calculate the midpoint for roughly equal partition\n\t            var midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t            var event = this._timeline[midPoint];\n\t            var nextEvent = this._timeline[midPoint + 1];\n\t            if (event.time === time) {\n\t                //choose the last one that has the same time\n\t                for (var i = midPoint; i < this._timeline.length; i++) {\n\t                    var testEvent = this._timeline[i];\n\t                    if (testEvent.time === time) {\n\t                        midPoint = i;\n\t                    }\n\t                }\n\t                return midPoint;\n\t            } else if (event.time < time && nextEvent.time > time) {\n\t                return midPoint;\n\t            } else if (event.time > time) {\n\t                //search lower\n\t                end = midPoint;\n\t            } else if (event.time < time) {\n\t                //search upper\n\t                beginning = midPoint + 1;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t\t *  Internal iterator. Applies extra safety checks for \n\t\t *  removing items from the array. \n\t\t *  @param  {Function}  callback \n\t\t *  @param  {Number=}    lowerBound     \n\t\t *  @param  {Number=}    upperBound    \n\t\t *  @private\n\t\t */\n\t    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {\n\t        this._iterating = true;\n\t        lowerBound = this.defaultArg(lowerBound, 0);\n\t        upperBound = this.defaultArg(upperBound, this._timeline.length - 1);\n\t        for (var i = lowerBound; i <= upperBound; i++) {\n\t            callback(this._timeline[i]);\n\t        }\n\t        this._iterating = false;\n\t        if (this._toRemove.length > 0) {\n\t            for (var j = 0; j < this._toRemove.length; j++) {\n\t                var index = this._timeline.indexOf(this._toRemove[j]);\n\t                if (index !== -1) {\n\t                    this._timeline.splice(index, 1);\n\t                }\n\t            }\n\t            this._toRemove = [];\n\t        }\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEach = function (callback) {\n\t        this._iterate(callback);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at or before the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachBefore = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var upperBound = this._search(time);\n\t        if (upperBound !== -1) {\n\t            this._iterate(callback, 0, upperBound);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array after the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachAfter = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var lowerBound = this._search(time);\n\t        this._iterate(callback, lowerBound + 1);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at or after the given time. Similar to \n\t\t *  forEachAfter, but includes the item(s) at the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachFrom = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var lowerBound = this._search(time);\n\t        //work backwards until the event time is less than time\n\t        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t            lowerBound--;\n\t        }\n\t        this._iterate(callback, lowerBound + 1);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at the given time\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var upperBound = this._search(time);\n\t        if (upperBound !== -1) {\n\t            this._iterate(function (event) {\n\t                if (event.time === time) {\n\t                    callback(event);\n\t                }\n\t            }, 0, upperBound);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Timeline}  this\n\t\t */\n\t    Tone.Timeline.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._timeline = null;\n\t        this._toRemove = null;\n\t    };\n\t    return Tone.Timeline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A signal which adds the method getValueAtTime. \n\t\t *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline\n\t\t *  @extends {Tone.Param}\n\t\t *  @param {Number=} value The initial value of the signal\n\t\t *  @param {String=} units The conversion units of the signal.\n\t\t */\n\t    Tone.TimelineSignal = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'value',\n\t            'units'\n\t        ], Tone.Signal.defaults);\n\t        /**\n\t\t\t *  The scheduled events\n\t\t\t *  @type {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = new Tone.Timeline(10);\n\t        //constructors\n\t        Tone.Signal.apply(this, options);\n\t        options.param = this._param;\n\t        Tone.Param.call(this, options);\n\t        /**\n\t\t\t *  The initial scheduled value\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._initial = this._fromUnits(this._param.value);\n\t    };\n\t    Tone.extend(Tone.TimelineSignal, Tone.Param);\n\t    /**\n\t\t *  The event types of a schedulable signal.\n\t\t *  @enum {String}\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.Type = {\n\t        Linear: 'linear',\n\t        Exponential: 'exponential',\n\t        Target: 'target',\n\t        Curve: 'curve',\n\t        Set: 'set'\n\t    };\n\t    /**\n\t\t * The current value of the signal. \n\t\t * @memberOf Tone.TimelineSignal#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {\n\t        get: function () {\n\t            var now = this.now();\n\t            var val = this.getValueAtTime(now);\n\t            return this._toUnits(val);\n\t        },\n\t        set: function (value) {\n\t            var convertedVal = this._fromUnits(value);\n\t            this._initial = convertedVal;\n\t            this.cancelScheduledValues();\n\t            this._param.value = convertedVal;\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tSCHEDULING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Schedules a parameter value change at the given time.\n\t\t *  @param {*}\tvalue The value to set the signal.\n\t\t *  @param {Time}  time The time when the change should occur.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t *  @example\n\t\t * //set the frequency to \"G4\" in exactly 1 second from now. \n\t\t * freq.setValueAtTime(\"G4\", \"+1\");\n\t\t */\n\t    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {\n\t        value = this._fromUnits(value);\n\t        startTime = this.toSeconds(startTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Set,\n\t            'value': value,\n\t            'time': startTime\n\t        });\n\t        //invoke the original event\n\t        this._param.setValueAtTime(value, startTime);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules a linear continuous change in parameter value from the \n\t\t *  previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        endTime = this.toSeconds(endTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Linear,\n\t            'value': value,\n\t            'time': endTime\n\t        });\n\t        this._param.linearRampToValueAtTime(value, endTime);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n\t        //get the previous event and make sure it's not starting from 0\n\t        endTime = this.toSeconds(endTime);\n\t        var beforeEvent = this._searchBefore(endTime);\n\t        if (beforeEvent && beforeEvent.value === 0) {\n\t            //reschedule that event\n\t            this.setValueAtTime(this._minOutput, beforeEvent.time);\n\t        }\n\t        value = this._fromUnits(value);\n\t        var setValue = Math.max(value, this._minOutput);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Exponential,\n\t            'value': setValue,\n\t            'time': endTime\n\t        });\n\t        //if the ramped to value is 0, make it go to the min output, and then set to 0.\n\t        if (value < this._minOutput) {\n\t            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);\n\t            this.setValueAtTime(0, endTime);\n\t        } else {\n\t            this._param.exponentialRampToValueAtTime(value, endTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start exponentially approaching the target value at the given time with\n\t\t *  a rate having the given time constant.\n\t\t *  @param {number} value        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {number} timeConstant \n\t\t *  @returns {Tone.TimelineSignal} this \n\t\t */\n\t    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n\t        value = this._fromUnits(value);\n\t        value = Math.max(this._minOutput, value);\n\t        timeConstant = Math.max(this._minOutput, timeConstant);\n\t        startTime = this.toSeconds(startTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Target,\n\t            'value': value,\n\t            'time': startTime,\n\t            'constant': timeConstant\n\t        });\n\t        this._param.setTargetAtTime(value, startTime, timeConstant);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set an array of arbitrary values starting at the given time for the given duration.\n\t\t *  @param {Float32Array} values        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {Time} duration\n\t\t *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value\n\t\t *  @returns {Tone.TimelineSignal} this \n\t\t */\n\t    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {\n\t        scaling = this.defaultArg(scaling, 1);\n\t        //copy the array\n\t        var floats = new Array(values.length);\n\t        for (var i = 0; i < floats.length; i++) {\n\t            floats[i] = this._fromUnits(values[i]) * scaling;\n\t        }\n\t        startTime = this.toSeconds(startTime);\n\t        duration = this.toSeconds(duration);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Curve,\n\t            'value': floats,\n\t            'time': startTime,\n\t            'duration': duration\n\t        });\n\t        //set the first value\n\t        this._param.setValueAtTime(floats[0], startTime);\n\t        //schedule a lienar ramp for each of the segments\n\t        for (var j = 1; j < floats.length; j++) {\n\t            var segmentTime = startTime + j / (floats.length - 1) * duration;\n\t            this._param.linearRampToValueAtTime(floats[j], segmentTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled parameter changes with times greater than or \n\t\t *  equal to startTime.\n\t\t *  \n\t\t *  @param  {Time} startTime\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {\n\t        after = this.toSeconds(after);\n\t        this._events.cancel(after);\n\t        this._param.cancelScheduledValues(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the computed value at the given time. This provides\n\t\t *  a point from which a linear or exponential curve\n\t\t *  can be scheduled after. Will cancel events after \n\t\t *  the given time and shorten the currently scheduled\n\t\t *  linear or exponential ramp so that it ends at `time` .\n\t\t *  This is to avoid discontinuities and clicks in envelopes. \n\t\t *  @param {Time} time When to set the ramp point\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.setRampPoint = function (time) {\n\t        time = this.toSeconds(time);\n\t        //get the value at the given time\n\t        var val = this._toUnits(this.getValueAtTime(time));\n\t        //if there is an event at the given time\n\t        //and that even is not a \"set\"\n\t        var before = this._searchBefore(time);\n\t        if (before && before.time === time) {\n\t            //remove everything after\n\t            this.cancelScheduledValues(time + this.sampleTime);\n\t        } else if (before && before.type === Tone.TimelineSignal.Type.Curve && before.time + before.duration > time) {\n\t            //if the curve is still playing\n\t            //cancel the curve\n\t            this.cancelScheduledValues(time);\n\t            this.linearRampToValueAtTime(val, time);\n\t        } else {\n\t            //reschedule the next event to end at the given time\n\t            var after = this._searchAfter(time);\n\t            if (after) {\n\t                //cancel the next event(s)\n\t                this.cancelScheduledValues(time);\n\t                if (after.type === Tone.TimelineSignal.Type.Linear) {\n\t                    this.linearRampToValueAtTime(val, time);\n\t                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {\n\t                    this.exponentialRampToValueAtTime(val, time);\n\t                }\n\t            }\n\t            this.setValueAtTime(val, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Do a linear ramp to the given value between the start and finish times.\n\t\t *  @param {Number} value The value to ramp to.\n\t\t *  @param {Time} start The beginning anchor point to do the linear ramp\n\t\t *  @param {Time} finish The ending anchor point by which the value of\n\t\t *                       the signal will equal the given value.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {\n\t        this.setRampPoint(start);\n\t        this.linearRampToValueAtTime(value, finish);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Do a exponential ramp to the given value between the start and finish times.\n\t\t *  @param {Number} value The value to ramp to.\n\t\t *  @param {Time} start The beginning anchor point to do the exponential ramp\n\t\t *  @param {Time} finish The ending anchor point by which the value of\n\t\t *                       the signal will equal the given value.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {\n\t        this.setRampPoint(start);\n\t        this.exponentialRampToValueAtTime(value, finish);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tGETTING SCHEDULED VALUES\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value before or equal to the given time\n\t\t *  @param  {Number}  time  The time to query\n\t\t *  @return  {Object}  The event at or before the given time.\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._searchBefore = function (time) {\n\t        return this._events.get(time);\n\t    };\n\t    /**\n\t\t *  The event after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @return  {Object}  The next event after the given time\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._searchAfter = function (time) {\n\t        return this._events.getAfter(time);\n\t    };\n\t    /**\n\t\t *  Get the scheduled value at the given time. This will\n\t\t *  return the unconverted (raw) value.\n\t\t *  @param  {Number}  time  The time in seconds.\n\t\t *  @return  {Number}  The scheduled value at the given time.\n\t\t */\n\t    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {\n\t        time = this.toSeconds(time);\n\t        var after = this._searchAfter(time);\n\t        var before = this._searchBefore(time);\n\t        var value = this._initial;\n\t        //if it was set by\n\t        if (before === null) {\n\t            value = this._initial;\n\t        } else if (before.type === Tone.TimelineSignal.Type.Target) {\n\t            var previous = this._events.getBefore(before.time);\n\t            var previouVal;\n\t            if (previous === null) {\n\t                previouVal = this._initial;\n\t            } else {\n\t                previouVal = previous.value;\n\t            }\n\t            value = this._exponentialApproach(before.time, previouVal, before.value, before.constant, time);\n\t        } else if (before.type === Tone.TimelineSignal.Type.Curve) {\n\t            value = this._curveInterpolate(before.time, before.value, before.duration, time);\n\t        } else if (after === null) {\n\t            value = before.value;\n\t        } else if (after.type === Tone.TimelineSignal.Type.Linear) {\n\t            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);\n\t        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {\n\t            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);\n\t        } else {\n\t            value = before.value;\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t *  @method\n\t\t */\n\t    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUTOMATION CURVE CALCULATIONS\n\t    //\tMIT License, copyright (c) 2014 Jordan Santell\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Calculates the the value along the curve produced by setTargetAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {\n\t        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by linearRampToValueAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {\n\t        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {\n\t        v0 = Math.max(this._minOutput, v0);\n\t        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by setValueCurveAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._curveInterpolate = function (start, curve, duration, time) {\n\t        var len = curve.length;\n\t        // If time is after duration, return the last curve value\n\t        if (time >= start + duration) {\n\t            return curve[len - 1];\n\t        } else if (time <= start) {\n\t            return curve[0];\n\t        } else {\n\t            var progress = (time - start) / duration;\n\t            var lowerIndex = Math.floor((len - 1) * progress);\n\t            var upperIndex = Math.ceil((len - 1) * progress);\n\t            var lowerVal = curve[lowerIndex];\n\t            var upperVal = curve[upperIndex];\n\t            if (upperIndex === lowerIndex) {\n\t                return lowerVal;\n\t            } else {\n\t                return this._linearInterpolate(lowerIndex, lowerVal, upperIndex, upperVal, progress * (len - 1));\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.dispose = function () {\n\t        Tone.Signal.prototype.dispose.call(this);\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._events.dispose();\n\t        this._events = null;\n\t    };\n\t    return Tone.TimelineSignal;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Pow applies an exponent to the incoming signal. The incoming signal\n\t\t *         must be AudioRange.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. \n\t\t *  @example\n\t\t * var pow = new Tone.Pow(2);\n\t\t * var sig = new Tone.Signal(0.5).connect(pow);\n\t\t * //output of pow is 0.25. \n\t\t */\n\t    Tone.Pow = function (exp) {\n\t        /**\n\t\t\t * the exponent\n\t\t\t * @private\n\t\t\t * @type {number}\n\t\t\t */\n\t        this._exp = this.defaultArg(exp, 1);\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);\n\t    };\n\t    Tone.extend(Tone.Pow, Tone.SignalBase);\n\t    /**\n\t\t * The value of the exponent.\n\t\t * @memberOf Tone.Pow#\n\t\t * @type {number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Pow.prototype, 'value', {\n\t        get: function () {\n\t            return this._exp;\n\t        },\n\t        set: function (exp) {\n\t            this._exp = exp;\n\t            this._expScaler.setMap(this._expFunc(this._exp));\n\t        }\n\t    });\n\t    /**\n\t\t *  the function which maps the waveshaper\n\t\t *  @param   {number} exp\n\t\t *  @return {function}\n\t\t *  @private\n\t\t */\n\t    Tone.Pow.prototype._expFunc = function (exp) {\n\t        return function (val) {\n\t            return Math.pow(Math.abs(val), exp);\n\t        };\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Pow} this\n\t\t */\n\t    Tone.Pow.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._expScaler.dispose();\n\t        this._expScaler = null;\n\t        return this;\n\t    };\n\t    return Tone.Pow;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n\t\t *          envelope generator. Tone.Envelope outputs a signal which \n\t\t *          can be connected to an AudioParam or Tone.Signal. \n\t\t *          <img src=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Time} [attack] The amount of time it takes for the envelope to go from \n\t\t *                         0 to it's maximum value. \n\t\t *  @param {Time} [decay]\tThe period of time after the attack that it takes for the envelope\n\t\t *                       \tto fall to the sustain value. \n\t\t *  @param {NormalRange} [sustain]\tThe percent of the maximum value that the envelope rests at until\n\t\t *                                \tthe release is triggered. \n\t\t *  @param {Time} [release]\tThe amount of time after the release is triggered it takes to reach 0. \n\t\t *  @example\n\t\t * //an amplitude envelope\n\t\t * var gainNode = Tone.context.createGain();\n\t\t * var env = new Tone.Envelope({\n\t\t * \t\"attack\" : 0.1,\n\t\t * \t\"decay\" : 0.2,\n\t\t * \t\"sustain\" : 1,\n\t\t * \t\"release\" : 0.8,\n\t\t * });\n\t\t * env.connect(gainNode.gain);\n\t\t */\n\t    Tone.Envelope = function () {\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        /** \n\t\t\t *  When triggerAttack is called, the attack time is the amount of\n\t\t\t *  time it takes for the envelope to reach it's maximum value. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.attack = options.attack;\n\t        /**\n\t\t\t *  After the attack portion of the envelope, the value will fall\n\t\t\t *  over the duration of the decay time to it's sustain value. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.decay = options.decay;\n\t        /**\n\t\t\t * \tThe sustain value is the value \n\t\t\t * \twhich the envelope rests at after triggerAttack is\n\t\t\t * \tcalled, but before triggerRelease is invoked. \n\t\t\t *  @type {NormalRange}\n\t\t\t */\n\t        this.sustain = options.sustain;\n\t        /**\n\t\t\t *  After triggerRelease is called, the envelope's\n\t\t\t *  value will fall to it's miminum value over the\n\t\t\t *  duration of the release time. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.release = options.release;\n\t        /**\n\t\t\t *  the next time the envelope is at standby\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._attackCurve = 'linear';\n\t        /**\n\t\t\t *  the next time the envelope is at standby\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._releaseCurve = 'exponential';\n\t        /**\n\t\t\t *  the signal\n\t\t\t *  @type {Tone.TimelineSignal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sig = this.output = new Tone.TimelineSignal();\n\t        this._sig.setValueAtTime(0, 0);\n\t        //set the attackCurve initially\n\t        this.attackCurve = options.attackCurve;\n\t        this.releaseCurve = options.releaseCurve;\n\t    };\n\t    Tone.extend(Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Envelope.defaults = {\n\t        'attack': 0.01,\n\t        'decay': 0.1,\n\t        'sustain': 0.5,\n\t        'release': 1,\n\t        'attackCurve': 'linear',\n\t        'releaseCurve': 'exponential'\n\t    };\n\t    /**\n\t\t * Read the current value of the envelope. Useful for \n\t\t * syncronizing visual output to the envelope. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'value', {\n\t        get: function () {\n\t            return this.getValueAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t * The shape of the attack. \n\t\t * Can be any of these strings:\n\t\t * <ul>\n\t\t *   <li>linear</li>\n\t\t *   <li>exponential</li>\n\t\t *   <li>sine</li>\n\t\t *   <li>cosine</li>\n\t\t *   <li>bounce</li>\n\t\t *   <li>ripple</li>\n\t\t *   <li>step</li>\n\t\t * </ul>\n\t\t * Can also be an array which describes the curve. Values\n\t\t * in the array are evenly subdivided and linearly\n\t\t * interpolated over the duration of the attack. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {String|Array}\n\t\t * @name attackCurve\n\t\t * @example\n\t\t * env.attackCurve = \"linear\";\n\t\t * @example\n\t\t * //can also be an array\n\t\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {\n\t        get: function () {\n\t            if (this.isString(this._attackCurve)) {\n\t                return this._attackCurve;\n\t            } else if (this.isArray(this._attackCurve)) {\n\t                //look up the name in the curves array\n\t                for (var type in Tone.Envelope.Type) {\n\t                    if (Tone.Envelope.Type[type].In === this._attackCurve) {\n\t                        return type;\n\t                    }\n\t                }\n\t                //otherwise just return the array\n\t                return this._attackCurve;\n\t            }\n\t        },\n\t        set: function (curve) {\n\t            //check if it's a valid type\n\t            if (Tone.Envelope.Type.hasOwnProperty(curve)) {\n\t                var curveDef = Tone.Envelope.Type[curve];\n\t                if (this.isObject(curveDef)) {\n\t                    this._attackCurve = curveDef.In;\n\t                } else {\n\t                    this._attackCurve = curveDef;\n\t                }\n\t            } else if (this.isArray(curve)) {\n\t                this._attackCurve = curve;\n\t            } else {\n\t                throw new Error('Tone.Envelope: invalid curve: ' + curve);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The shape of the release. See the attack curve types. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {String|Array}\n\t\t * @name releaseCurve\n\t\t * @example\n\t\t * env.releaseCurve = \"linear\";\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {\n\t        get: function () {\n\t            if (this.isString(this._releaseCurve)) {\n\t                return this._releaseCurve;\n\t            } else if (this.isArray(this._releaseCurve)) {\n\t                //look up the name in the curves array\n\t                for (var type in Tone.Envelope.Type) {\n\t                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {\n\t                        return type;\n\t                    }\n\t                }\n\t                //otherwise just return the array\n\t                return this._releaseCurve;\n\t            }\n\t        },\n\t        set: function (curve) {\n\t            //check if it's a valid type\n\t            if (Tone.Envelope.Type.hasOwnProperty(curve)) {\n\t                var curveDef = Tone.Envelope.Type[curve];\n\t                if (this.isObject(curveDef)) {\n\t                    this._releaseCurve = curveDef.Out;\n\t                } else {\n\t                    this._releaseCurve = curveDef;\n\t                }\n\t            } else if (this.isArray(curve)) {\n\t                this._releaseCurve = curve;\n\t            } else {\n\t                throw new Error('Tone.Envelope: invalid curve: ' + curve);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Trigger the attack/decay portion of the ADSR envelope. \n\t\t *  @param  {Time} [time=now] When the attack should start.\n\t\t *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.\n\t\t *                               number between 0-1\n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t *  //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t\t *  env.triggerAttack(\"+0.5\", 0.2);\n\t\t */\n\t    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        var originalAttack = this.toSeconds(this.attack);\n\t        var attack = originalAttack;\n\t        var decay = this.toSeconds(this.decay);\n\t        velocity = this.defaultArg(velocity, 1);\n\t        //check if it's not a complete attack\n\t        var currentValue = this.getValueAtTime(time);\n\t        if (currentValue > 0) {\n\t            //subtract the current value from the attack time\n\t            var attackRate = 1 / attack;\n\t            var remainingDistance = 1 - currentValue;\n\t            //the attack is now the remaining time\n\t            attack = remainingDistance / attackRate;\n\t        }\n\t        //attack\n\t        if (this._attackCurve === 'linear') {\n\t            this._sig.linearRampToValue(velocity, attack, time);\n\t        } else if (this._attackCurve === 'exponential') {\n\t            this._sig.exponentialRampToValue(velocity, attack, time);\n\t        } else if (attack > 0) {\n\t            this._sig.setRampPoint(time);\n\t            var curve = this._attackCurve;\n\t            //take only a portion of the curve\n\t            if (attack < originalAttack) {\n\t                var percentComplete = 1 - attack / originalAttack;\n\t                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);\n\t                curve = this._attackCurve.slice(sliceIndex);\n\t                //the first index is the current value\n\t                curve[0] = currentValue;\n\t            }\n\t            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t        }\n\t        //decay\n\t        this._sig.exponentialRampToValue(velocity * this.sustain, decay, attack + time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Triggers the release of the envelope.\n\t\t *  @param  {Time} [time=now] When the release portion of the envelope should start. \n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t *  //trigger release immediately\n\t\t *  env.triggerRelease();\n\t\t */\n\t    Tone.Envelope.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        var currentValue = this.getValueAtTime(time);\n\t        if (currentValue > 0) {\n\t            var release = this.toSeconds(this.release);\n\t            if (this._releaseCurve === 'linear') {\n\t                this._sig.linearRampToValue(0, release, time);\n\t            } else if (this._releaseCurve === 'exponential') {\n\t                this._sig.exponentialRampToValue(0, release, time);\n\t            } else {\n\t                var curve = this._releaseCurve;\n\t                if (this.isArray(curve)) {\n\t                    this._sig.setRampPoint(time);\n\t                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the scheduled value at the given time. This will\n\t\t *  return the unconverted (raw) value.\n\t\t *  @param  {Number}  time  The time in seconds.\n\t\t *  @return  {Number}  The scheduled value at the given time.\n\t\t */\n\t    Tone.Envelope.prototype.getValueAtTime = function (time) {\n\t        return this._sig.getValueAtTime(time);\n\t    };\n\t    /**\n\t\t *  triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t\t *  some duration, then triggerRelease. \n\t\t *  @param {Time} duration The duration of the sustain.\n\t\t *  @param {Time} [time=now] When the attack should be triggered.\n\t\t *  @param {number} [velocity=1] The velocity of the envelope. \n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t * //trigger the attack and then the release after 0.6 seconds.\n\t\t * env.triggerAttackRelease(0.6);\n\t\t */\n\t    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + this.toSeconds(duration));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled envelope changes after the given time.\n\t\t *  @param  {Time} after\n\t\t *  @returns {Tone.Envelope} this\n\t\t */\n\t    Tone.Envelope.prototype.cancel = function (after) {\n\t        this._sig.cancelScheduledValues(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Borrows the connect method from Tone.Signal. \n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;\n\t    /**\n\t \t *  Generate some complex envelope curves. \n\t \t */\n\t    (function _createCurves() {\n\t        var curveLen = 128;\n\t        var i, k;\n\t        //cosine curve\n\t        var cosineCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n\t        }\n\t        //ripple curve\n\t        var rippleCurve = [];\n\t        var rippleCurveFreq = 6.4;\n\t        for (i = 0; i < curveLen - 1; i++) {\n\t            k = i / (curveLen - 1);\n\t            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t            rippleCurve[i] = sineWave / 10 + k * 0.83;\n\t        }\n\t        rippleCurve[curveLen - 1] = 1;\n\t        //stairs curve\n\t        var stairsCurve = [];\n\t        var steps = 5;\n\t        for (i = 0; i < curveLen; i++) {\n\t            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n\t        }\n\t        //in-out easing curve\n\t        var sineCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            k = i / (curveLen - 1);\n\t            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t        }\n\t        //a bounce curve\n\t        var bounceCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            k = i / (curveLen - 1);\n\t            var freq = Math.pow(k, 3) * 4 + 0.2;\n\t            var val = Math.cos(freq * Math.PI * 2 * k);\n\t            bounceCurve[i] = Math.abs(val * (1 - k));\n\t        }\n\t        /**\n\t\t\t *  Invert a value curve to make it work for the release\n\t\t\t *  @private\n\t\t\t */\n\t        function invertCurve(curve) {\n\t            var out = new Array(curve.length);\n\t            for (var j = 0; j < curve.length; j++) {\n\t                out[j] = 1 - curve[j];\n\t            }\n\t            return out;\n\t        }\n\t        /**\n\t\t\t *  reverse the curve\n\t\t\t *  @private\n\t\t\t */\n\t        function reverseCurve(curve) {\n\t            return curve.slice(0).reverse();\n\t        }\n\t        /**\n\t\t\t *  attack and release curve arrays\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        Tone.Envelope.Type = {\n\t            'linear': 'linear',\n\t            'exponential': 'exponential',\n\t            'bounce': {\n\t                In: invertCurve(bounceCurve),\n\t                Out: bounceCurve\n\t            },\n\t            'cosine': {\n\t                In: cosineCurve,\n\t                Out: reverseCurve(cosineCurve)\n\t            },\n\t            'step': {\n\t                In: stairsCurve,\n\t                Out: invertCurve(stairsCurve)\n\t            },\n\t            'ripple': {\n\t                In: rippleCurve,\n\t                Out: invertCurve(rippleCurve)\n\t            },\n\t            'sine': {\n\t                In: sineCurve,\n\t                Out: invertCurve(sineCurve)\n\t            }\n\t        };\n\t    }());\n\t    /**\n\t\t *  Disconnect and dispose.\n\t\t *  @returns {Tone.Envelope} this\n\t\t */\n\t    Tone.Envelope.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sig.dispose();\n\t        this._sig = null;\n\t        this._attackCurve = null;\n\t        this._releaseCurve = null;\n\t        return this;\n\t    };\n\t    return Tone.Envelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node. \n\t\t *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts\n\t\t *          an audio signal as the input and will apply the envelope to the amplitude\n\t\t *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from \n\t\t *                               0 to it's maximum value. \n\t\t *  @param {Time} [decay]\tThe period of time after the attack that it takes for the envelope\n\t\t *                       \tto fall to the sustain value. \n\t\t *  @param {NormalRange} [sustain]\tThe percent of the maximum value that the envelope rests at until\n\t\t *                                \tthe release is triggered. \n\t\t *  @param {Time} [release]\tThe amount of time after the release is triggered it takes to reach 0. \n\t\t *  @example\n\t\t * var ampEnv = new Tone.AmplitudeEnvelope({\n\t\t * \t\"attack\": 0.1,\n\t\t * \t\"decay\": 0.2,\n\t\t * \t\"sustain\": 1.0,\n\t\t * \t\"release\": 0.8\n\t\t * }).toMaster();\n\t\t * //create an oscillator and connect it\n\t\t * var osc = new Tone.Oscillator().connect(ampEnv).start();\n\t\t * //trigger the envelopes attack and release \"8t\" apart\n\t\t * ampEnv.triggerAttackRelease(\"8t\");\n\t\t */\n\t    Tone.AmplitudeEnvelope = function () {\n\t        Tone.Envelope.apply(this, arguments);\n\t        /**\n\t\t\t *  the input node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = this.output = new Tone.Gain();\n\t        this._sig.connect(this.output.gain);\n\t    };\n\t    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.AmplitudeEnvelope}  this\n\t\t */\n\t    Tone.AmplitudeEnvelope.prototype.dispose = function () {\n\t        this.input.dispose();\n\t        this.input = null;\n\t        Tone.Envelope.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.AmplitudeEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  AnalyserNode.getFloatTimeDomainData polyfill\n\t\t *  @private\n\t\t */\n\t    if (window.AnalyserNode && !AnalyserNode.prototype.getFloatTimeDomainData) {\n\t        //referenced https://github.com/mohayonao/get-float-time-domain-data \n\t        AnalyserNode.prototype.getFloatTimeDomainData = function (array) {\n\t            var uint8 = new Uint8Array(array.length);\n\t            this.getByteTimeDomainData(uint8);\n\t            for (var i = 0; i < uint8.length; i++) {\n\t                array[i] = (uint8[i] - 128) / 128;\n\t            }\n\t        };\n\t    }\n\t    /**\n\t\t *  @class  Wrapper around the native Web Audio's \n\t\t *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n\t\t *          Extracts FFT or Waveform data from the incoming signal.\n\t\t *  @extends {Tone}\n\t\t *  @param {String=} type The return type of the analysis, either \"fft\", or \"waveform\". \n\t\t *  @param {Number=} size The size of the FFT. Value must be a power of \n\t\t *                       two in the range 32 to 32768.\n\t\t */\n\t    Tone.Analyser = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'type',\n\t            'size'\n\t        ], Tone.Analyser.defaults);\n\t        /**\n\t\t\t *  The analyser node.\n\t\t\t *  @private\n\t\t\t *  @type {AnalyserNode}\n\t\t\t */\n\t        this._analyser = this.input = this.output = this.context.createAnalyser();\n\t        /**\n\t\t\t *  The analysis type\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The return type of the analysis\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._returnType = options.returnType;\n\t        /**\n\t\t\t *  The buffer that the FFT data is written to\n\t\t\t *  @type {TypedArray}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = null;\n\t        //set the values initially\n\t        this.size = options.size;\n\t        this.type = options.type;\n\t        this.returnType = options.returnType;\n\t        this.minDecibels = options.minDecibels;\n\t        this.maxDecibels = options.maxDecibels;\n\t    };\n\t    Tone.extend(Tone.Analyser);\n\t    /**\n\t\t *  The default values.\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Analyser.defaults = {\n\t        'size': 1024,\n\t        'returnType': 'byte',\n\t        'type': 'fft',\n\t        'smoothing': 0.8,\n\t        'maxDecibels': -30,\n\t        'minDecibels': -100\n\t    };\n\t    /**\n\t\t *  Possible return types of Tone.Analyser.analyse()\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Analyser.Type = {\n\t        Waveform: 'waveform',\n\t        FFT: 'fft'\n\t    };\n\t    /**\n\t\t *  Possible return types of Tone.Analyser.analyse(). \n\t\t *  byte values are between [0,255]. float values are between \n\t\t *  [-1, 1] when the type is set to \"waveform\" and between \n\t\t *  [minDecibels,maxDecibels] when the type is \"fft\".\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Analyser.ReturnType = {\n\t        Byte: 'byte',\n\t        Float: 'float'\n\t    };\n\t    /**\n\t\t *  Run the analysis given the current settings and return the \n\t\t *  result as a TypedArray. \n\t\t *  @returns {TypedArray}\n\t\t */\n\t    Tone.Analyser.prototype.analyse = function () {\n\t        if (this._type === Tone.Analyser.Type.FFT) {\n\t            if (this._returnType === Tone.Analyser.ReturnType.Byte) {\n\t                this._analyser.getByteFrequencyData(this._buffer);\n\t            } else {\n\t                this._analyser.getFloatFrequencyData(this._buffer);\n\t            }\n\t        } else if (this._type === Tone.Analyser.Type.Waveform) {\n\t            if (this._returnType === Tone.Analyser.ReturnType.Byte) {\n\t                this._analyser.getByteTimeDomainData(this._buffer);\n\t            } else {\n\t                this._analyser.getFloatTimeDomainData(this._buffer);\n\t            }\n\t        }\n\t        return this._buffer;\n\t    };\n\t    /**\n\t\t *  The size of analysis. This must be a power of two in the range 32 to 32768.\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Number}\n\t\t *  @name size\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'size', {\n\t        get: function () {\n\t            return this._analyser.frequencyBinCount;\n\t        },\n\t        set: function (size) {\n\t            this._analyser.fftSize = size * 2;\n\t            this.type = this._type;\n\t        }\n\t    });\n\t    /**\n\t\t *  The return type of Tone.Analyser.analyse(), either \"byte\" or \"float\". \n\t\t *  When the type is set to \"byte\" the range of values returned in the array\n\t\t *  are between 0-255. \"float\" values are between \n\t\t *  [-1, 1] when the type is set to \"waveform\" and between \n\t\t *  [minDecibels,maxDecibels] when the type is \"fft\".\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {String}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'returnType', {\n\t        get: function () {\n\t            return this._returnType;\n\t        },\n\t        set: function (type) {\n\t            if (type === Tone.Analyser.ReturnType.Byte) {\n\t                this._buffer = new Uint8Array(this._analyser.frequencyBinCount);\n\t            } else if (type === Tone.Analyser.ReturnType.Float) {\n\t                this._buffer = new Float32Array(this._analyser.frequencyBinCount);\n\t            } else {\n\t                throw new TypeError('Tone.Analayser: invalid return type: ' + type);\n\t            }\n\t            this._returnType = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  The analysis function returned by Tone.Analyser.analyse(), either \"fft\" or \"waveform\". \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {String}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {\n\t                throw new TypeError('Tone.Analyser: invalid type: ' + type);\n\t            }\n\t            this._type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  0 represents no time averaging with the last analysis frame.\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {NormalRange}\n\t\t *  @name smoothing\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {\n\t        get: function () {\n\t            return this._analyser.smoothingTimeConstant;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.smoothingTimeConstant = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The smallest decibel value which is analysed by the FFT. \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Decibels}\n\t\t *  @name minDecibels\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'minDecibels', {\n\t        get: function () {\n\t            return this._analyser.minDecibels;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.minDecibels = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The largest decibel value which is analysed by the FFT. \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Decibels}\n\t\t *  @name maxDecibels\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'maxDecibels', {\n\t        get: function () {\n\t            return this._analyser.maxDecibels;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.maxDecibels = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Analyser}  this\n\t\t */\n\t    Tone.Analyser.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._analyser.disconnect();\n\t        this._analyser = null;\n\t        this._buffer = null;\n\t    };\n\t    return Tone.Analyser;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Compressor is a thin wrapper around the Web Audio \n\t\t *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n\t\t *         Compression reduces the volume of loud sounds or amplifies quiet sounds \n\t\t *         by narrowing or \"compressing\" an audio signal's dynamic range. \n\t\t *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.\n\t\t *  @param {Positive} [ratio] The gain reduction ratio.\n\t\t *  @example\n\t\t * var comp = new Tone.Compressor(-30, 3);\n\t\t */\n\t    Tone.Compressor = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'threshold',\n\t            'ratio'\n\t        ], Tone.Compressor.defaults);\n\t        /**\n\t\t\t *  the compressor node\n\t\t\t *  @type {DynamicsCompressorNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();\n\t        /**\n\t\t\t *  the threshold vaue\n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.threshold = new Tone.Param({\n\t            'param': this._compressor.threshold,\n\t            'units': Tone.Type.Decibels,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The attack parameter\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);\n\t        /**\n\t\t\t *  The release parameter\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);\n\t        /**\n\t\t\t *  The knee parameter\n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.knee = new Tone.Param({\n\t            'param': this._compressor.knee,\n\t            'units': Tone.Type.Decibels,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The ratio value\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.ratio = new Tone.Param({\n\t            'param': this._compressor.ratio,\n\t            'convert': false\n\t        });\n\t        //set the defaults\n\t        this._readOnly([\n\t            'knee',\n\t            'release',\n\t            'attack',\n\t            'ratio',\n\t            'threshold'\n\t        ]);\n\t        this.set(options);\n\t    };\n\t    Tone.extend(Tone.Compressor);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Compressor.defaults = {\n\t        'ratio': 12,\n\t        'threshold': -24,\n\t        'release': 0.25,\n\t        'attack': 0.003,\n\t        'knee': 30\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Compressor} this\n\t\t */\n\t    Tone.Compressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'knee',\n\t            'release',\n\t            'attack',\n\t            'ratio',\n\t            'threshold'\n\t        ]);\n\t        this._compressor.disconnect();\n\t        this._compressor = null;\n\t        this.attack.dispose();\n\t        this.attack = null;\n\t        this.release.dispose();\n\t        this.release = null;\n\t        this.threshold.dispose();\n\t        this.threshold = null;\n\t        this.ratio.dispose();\n\t        this.ratio = null;\n\t        this.knee.dispose();\n\t        this.knee = null;\n\t        return this;\n\t    };\n\t    return Tone.Compressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Add a signal and a number or two signals. When no value is\n\t\t *         passed into the constructor, Tone.Add will sum <code>input[0]</code>\n\t\t *         and <code>input[1]</code>. If a value is passed into the constructor, \n\t\t *         the it will be added to the input.\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number=} value If no value is provided, Tone.Add will sum the first\n\t\t *                         and second inputs. \n\t\t *  @example\n\t\t * var signal = new Tone.Signal(2);\n\t\t * var add = new Tone.Add(2);\n\t\t * signal.connect(add);\n\t\t * //the output of add equals 4\n\t\t *  @example\n\t\t * //if constructed with no arguments\n\t\t * //it will add the first and second inputs\n\t\t * var add = new Tone.Add();\n\t\t * var sig0 = new Tone.Signal(3).connect(add, 0, 0);\n\t\t * var sig1 = new Tone.Signal(4).connect(add, 0, 1);\n\t\t * //the output of add equals 7. \n\t\t */\n\t    Tone.Add = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the summing node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Signal}\n\t\t\t */\n\t        this._param = this.input[1] = new Tone.Signal(value);\n\t        this._param.connect(this._sum);\n\t    };\n\t    Tone.extend(Tone.Add, Tone.Signal);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Add} this\n\t\t */\n\t    Tone.Add.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sum.dispose();\n\t        this._sum = null;\n\t        this._param.dispose();\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Add;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, \n\t\t *          multiplies the incoming signal by that value. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number=} value Constant value to multiple. If no value is provided,\n\t\t *                         it will return the product of the first and second inputs\n\t\t *  @example\n\t\t * var mult = new Tone.Multiply();\n\t\t * var sigA = new Tone.Signal(3);\n\t\t * var sigB = new Tone.Signal(4);\n\t\t * sigA.connect(mult, 0, 0);\n\t\t * sigB.connect(mult, 0, 1);\n\t\t * //output of mult is 12.\n\t\t *  @example\n\t\t * var mult = new Tone.Multiply(10);\n\t\t * var sig = new Tone.Signal(2).connect(mult);\n\t\t * //the output of mult is 20. \n\t\t */\n\t    Tone.Multiply = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the input node is the same as the output node\n\t\t\t *  it is also the GainNode which handles the scaling of incoming signal\n\t\t\t *  \n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mult = this.input[0] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  the scaling parameter\n\t\t\t *  @type {AudioParam}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input[1] = this.output.gain;\n\t        this._param.value = this.defaultArg(value, 0);\n\t    };\n\t    Tone.extend(Tone.Multiply, Tone.Signal);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Multiply} this\n\t\t */\n\t    Tone.Multiply.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._mult.dispose();\n\t        this._mult = null;\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Multiply;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var neg = new Tone.Negate();\n\t\t * var sig = new Tone.Signal(-2).connect(neg);\n\t\t * //output of neg is positive 2. \n\t\t */\n\t    Tone.Negate = function () {\n\t        /**\n\t\t\t *  negation is done by multiplying by -1\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multiply = this.input = this.output = new Tone.Multiply(-1);\n\t    };\n\t    Tone.extend(Tone.Negate, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Negate} this\n\t\t */\n\t    Tone.Negate.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._multiply.dispose();\n\t        this._multiply = null;\n\t        return this;\n\t    };\n\t    return Tone.Negate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected \n\t\t *         to <code>input[0]</code>. If an argument is provided in the constructor, the \n\t\t *         signals <code>.value</code> will be subtracted from the incoming signal.\n\t\t *\n\t\t *  @extends {Tone.Signal}\n\t\t *  @constructor\n\t\t *  @param {number=} value The value to subtract from the incoming signal. If the value\n\t\t *                         is omitted, it will subtract the second signal from the first.\n\t\t *  @example\n\t\t * var sub = new Tone.Subtract(1);\n\t\t * var sig = new Tone.Signal(4).connect(sub);\n\t\t * //the output of sub is 3. \n\t\t *  @example\n\t\t * var sub = new Tone.Subtract();\n\t\t * var sigA = new Tone.Signal(10);\n\t\t * var sigB = new Tone.Signal(2.5);\n\t\t * sigA.connect(sub, 0, 0);\n\t\t * sigB.connect(sub, 0, 1);\n\t\t * //output of sub is 7.5\n\t\t */\n\t    Tone.Subtract = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the summing node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sum = this.input[0] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  negate the input of the second input before connecting it\n\t\t\t *  to the summing node.\n\t\t\t *  @type {Tone.Negate}\n\t\t\t *  @private\n\t\t\t */\n\t        this._neg = new Tone.Negate();\n\t        /**\n\t\t\t *  the node where the value is set\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Signal}\n\t\t\t */\n\t        this._param = this.input[1] = new Tone.Signal(value);\n\t        this._param.chain(this._neg, this._sum);\n\t    };\n\t    Tone.extend(Tone.Subtract, Tone.Signal);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t */\n\t    Tone.Subtract.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._neg.dispose();\n\t        this._neg = null;\n\t        this._sum.disconnect();\n\t        this._sum = null;\n\t        this._param.dispose();\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Subtract;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var gt0 = new Tone.GreaterThanZero();\n\t\t * var sig = new Tone.Signal(0.01).connect(gt0);\n\t\t * //the output of gt0 is 1. \n\t\t * sig.value = 0;\n\t\t * //the output of gt0 is 0. \n\t\t */\n\t    Tone.GreaterThanZero = function () {\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._thresh = this.output = new Tone.WaveShaper(function (val) {\n\t            if (val <= 0) {\n\t                return 0;\n\t            } else {\n\t                return 1;\n\t            }\n\t        }, 127);\n\t        /**\n\t\t\t *  scale the first thresholded signal by a large value.\n\t\t\t *  this will help with values which are very close to 0\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.input = new Tone.Multiply(10000);\n\t        //connections\n\t        this._scale.connect(this._thresh);\n\t    };\n\t    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.GreaterThanZero} this\n\t\t */\n\t    Tone.GreaterThanZero.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._thresh.dispose();\n\t        this._thresh = null;\n\t        return this;\n\t    };\n\t    return Tone.GreaterThanZero;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.\n\t\t *          can compare two signals or a signal and a number. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number} [value=0] the value to compare to the incoming signal\n\t\t *  @example\n\t\t * var gt = new Tone.GreaterThan(2);\n\t\t * var sig = new Tone.Signal(4).connect(gt);\n\t\t * //output of gt is equal 1. \n\t\t */\n\t    Tone.GreaterThan = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  subtract the amount from the incoming signal\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input[0] = new Tone.Subtract(value);\n\t        this.input[1] = this._param.input[1];\n\t        /**\n\t\t\t *  compare that amount to zero\n\t\t\t *  @type {Tone.GreaterThanZero}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gtz = this.output = new Tone.GreaterThanZero();\n\t        //connect\n\t        this._param.connect(this._gtz);\n\t    };\n\t    Tone.extend(Tone.GreaterThan, Tone.Signal);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.GreaterThan} this\n\t\t */\n\t    Tone.GreaterThan.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._param.dispose();\n\t        this._param = null;\n\t        this._gtz.dispose();\n\t        this._gtz = null;\n\t        return this;\n\t    };\n\t    return Tone.GreaterThan;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Return the absolute value of an incoming signal. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var signal = new Tone.Signal(-1);\n\t\t * var abs = new Tone.Abs();\n\t\t * signal.connect(abs);\n\t\t * //the output of abs is 1. \n\t\t */\n\t    Tone.Abs = function () {\n\t        /**\n\t\t\t *  @type {Tone.LessThan}\n\t\t\t *  @private\n\t\t\t */\n\t        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {\n\t            if (val === 0) {\n\t                return 0;\n\t            } else {\n\t                return Math.abs(val);\n\t            }\n\t        }, 127);\n\t    };\n\t    Tone.extend(Tone.Abs, Tone.SignalBase);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.Abs} this\n\t\t */\n\t    Tone.Abs.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._abs.dispose();\n\t        this._abs = null;\n\t        return this;\n\t    };\n\t    return Tone.Abs;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus\n\t\t *         values in the NormalRange. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {NormalRange} modulus The modulus to apply.\n\t\t *  @example\n\t\t * var mod = new Tone.Modulo(0.2)\n\t\t * var sig = new Tone.Signal(0.5).connect(mod);\n\t\t * //mod outputs 0.1\n\t\t */\n\t    Tone.Modulo = function (modulus) {\n\t        this.createInsOuts(1, 0);\n\t        /**\n\t\t\t *  A waveshaper gets the integer multiple of \n\t\t\t *  the input signal and the modulus.\n\t\t\t *  @private\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));\n\t        /**\n\t\t\t *  the integer multiple is multiplied by the modulus\n\t\t\t *  @type  {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multiply = new Tone.Multiply();\n\t        /**\n\t\t\t *  and subtracted from the input signal\n\t\t\t *  @type  {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subtract = this.output = new Tone.Subtract();\n\t        /**\n\t\t\t *  the modulus signal\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modSignal = new Tone.Signal(modulus);\n\t        //connections\n\t        this.input.fan(this._shaper, this._subtract);\n\t        this._modSignal.connect(this._multiply, 0, 0);\n\t        this._shaper.connect(this._multiply, 0, 1);\n\t        this._multiply.connect(this._subtract, 0, 1);\n\t        this._setWaveShaper(modulus);\n\t    };\n\t    Tone.extend(Tone.Modulo, Tone.SignalBase);\n\t    /**\n\t\t *  @param  {number}  mod  the modulus to apply\n\t\t *  @private\n\t\t */\n\t    Tone.Modulo.prototype._setWaveShaper = function (mod) {\n\t        this._shaper.setMap(function (val) {\n\t            var multiple = Math.floor((val + 0.0001) / mod);\n\t            return multiple;\n\t        });\n\t    };\n\t    /**\n\t\t * The modulus value.\n\t\t * @memberOf Tone.Modulo#\n\t\t * @type {NormalRange}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Modulo.prototype, 'value', {\n\t        get: function () {\n\t            return this._modSignal.value;\n\t        },\n\t        set: function (mod) {\n\t            this._modSignal.value = mod;\n\t            this._setWaveShaper(mod);\n\t        }\n\t    });\n\t    /**\n\t\t * clean up\n\t\t *  @returns {Tone.Modulo} this\n\t\t */\n\t    Tone.Modulo.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        this._multiply.dispose();\n\t        this._multiply = null;\n\t        this._subtract.dispose();\n\t        this._subtract = null;\n\t        this._modSignal.dispose();\n\t        this._modSignal = null;\n\t        return this;\n\t    };\n\t    return Tone.Modulo;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. \n\t\t *         See Tone.GainToAudio.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t *  var a2g = new Tone.AudioToGain();\n\t\t */\n\t    Tone.AudioToGain = function () {\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {\n\t            return (x + 1) / 2;\n\t        });\n\t    };\n\t    Tone.extend(Tone.AudioToGain, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AudioToGain} this\n\t\t */\n\t    Tone.AudioToGain.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._norm.dispose();\n\t        this._norm = null;\n\t        return this;\n\t    };\n\t    return Tone.AudioToGain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Evaluate an expression at audio rate. <br><br>\n\t\t *         Parsing code modified from https://code.google.com/p/tapdigit/\n\t\t *         Copyright 2011 2012 Ariya Hidayat, New BSD License\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {string} expr the expression to generate\n\t\t *  @example\n\t\t * //adds the signals from input[0] and input[1].\n\t\t * var expr = new Tone.Expr(\"$0 + $1\");\n\t\t */\n\t    Tone.Expr = function () {\n\t        var expr = this._replacements(Array.prototype.slice.call(arguments));\n\t        var inputCount = this._parseInputs(expr);\n\t        /**\n\t\t\t *  hold onto all of the nodes for disposal\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._nodes = [];\n\t        /**\n\t\t\t *  The inputs. The length is determined by the expression. \n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.input = new Array(inputCount);\n\t        //create a gain for each input\n\t        for (var i = 0; i < inputCount; i++) {\n\t            this.input[i] = this.context.createGain();\n\t        }\n\t        //parse the syntax tree\n\t        var tree = this._parseTree(expr);\n\t        //evaluate the results\n\t        var result;\n\t        try {\n\t            result = this._eval(tree);\n\t        } catch (e) {\n\t            this._disposeNodes();\n\t            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);\n\t        }\n\t        /**\n\t\t\t *  The output node is the result of the expression\n\t\t\t *  @type {Tone}\n\t\t\t */\n\t        this.output = result;\n\t    };\n\t    Tone.extend(Tone.Expr, Tone.SignalBase);\n\t    //some helpers to cut down the amount of code\n\t    function applyBinary(Constructor, args, self) {\n\t        var op = new Constructor();\n\t        self._eval(args[0]).connect(op, 0, 0);\n\t        self._eval(args[1]).connect(op, 0, 1);\n\t        return op;\n\t    }\n\t    function applyUnary(Constructor, args, self) {\n\t        var op = new Constructor();\n\t        self._eval(args[0]).connect(op, 0, 0);\n\t        return op;\n\t    }\n\t    function getNumber(arg) {\n\t        return arg ? parseFloat(arg) : undefined;\n\t    }\n\t    function literalNumber(arg) {\n\t        return arg && arg.args ? parseFloat(arg.args) : undefined;\n\t    }\n\t    /*\n\t\t *  the Expressions that Tone.Expr can parse.\n\t\t *\n\t\t *  each expression belongs to a group and contains a regexp \n\t\t *  for selecting the operator as well as that operators method\n\t\t *  \n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Expr._Expressions = {\n\t        //values\n\t        'value': {\n\t            'signal': {\n\t                regexp: /^\\d+\\.\\d+|^\\d+/,\n\t                method: function (arg) {\n\t                    var sig = new Tone.Signal(getNumber(arg));\n\t                    return sig;\n\t                }\n\t            },\n\t            'input': {\n\t                regexp: /^\\$\\d/,\n\t                method: function (arg, self) {\n\t                    return self.input[getNumber(arg.substr(1))];\n\t                }\n\t            }\n\t        },\n\t        //syntactic glue\n\t        'glue': {\n\t            '(': { regexp: /^\\(/ },\n\t            ')': { regexp: /^\\)/ },\n\t            ',': { regexp: /^,/ }\n\t        },\n\t        //functions\n\t        'func': {\n\t            'abs': {\n\t                regexp: /^abs/,\n\t                method: applyUnary.bind(this, Tone.Abs)\n\t            },\n\t            'mod': {\n\t                regexp: /^mod/,\n\t                method: function (args, self) {\n\t                    var modulus = literalNumber(args[1]);\n\t                    var op = new Tone.Modulo(modulus);\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            },\n\t            'pow': {\n\t                regexp: /^pow/,\n\t                method: function (args, self) {\n\t                    var exp = literalNumber(args[1]);\n\t                    var op = new Tone.Pow(exp);\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            },\n\t            'a2g': {\n\t                regexp: /^a2g/,\n\t                method: function (args, self) {\n\t                    var op = new Tone.AudioToGain();\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            }\n\t        },\n\t        //binary expressions\n\t        'binary': {\n\t            '+': {\n\t                regexp: /^\\+/,\n\t                precedence: 1,\n\t                method: applyBinary.bind(this, Tone.Add)\n\t            },\n\t            '-': {\n\t                regexp: /^\\-/,\n\t                precedence: 1,\n\t                method: function (args, self) {\n\t                    //both unary and binary op\n\t                    if (args.length === 1) {\n\t                        return applyUnary(Tone.Negate, args, self);\n\t                    } else {\n\t                        return applyBinary(Tone.Subtract, args, self);\n\t                    }\n\t                }\n\t            },\n\t            '*': {\n\t                regexp: /^\\*/,\n\t                precedence: 0,\n\t                method: applyBinary.bind(this, Tone.Multiply)\n\t            }\n\t        },\n\t        //unary expressions\n\t        'unary': {\n\t            '-': {\n\t                regexp: /^\\-/,\n\t                method: applyUnary.bind(this, Tone.Negate)\n\t            },\n\t            '!': {\n\t                regexp: /^\\!/,\n\t                method: applyUnary.bind(this, Tone.NOT)\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  @param   {string} expr the expression string\n\t\t *  @return  {number}      the input count\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._parseInputs = function (expr) {\n\t        var inputArray = expr.match(/\\$\\d/g);\n\t        var inputMax = 0;\n\t        if (inputArray !== null) {\n\t            for (var i = 0; i < inputArray.length; i++) {\n\t                var inputNum = parseInt(inputArray[i].substr(1)) + 1;\n\t                inputMax = Math.max(inputMax, inputNum);\n\t            }\n\t        }\n\t        return inputMax;\n\t    };\n\t    /**\n\t\t *  @param   {Array} args \tan array of arguments\n\t\t *  @return  {string} the results of the replacements being replaced\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._replacements = function (args) {\n\t        var expr = args.shift();\n\t        for (var i = 0; i < args.length; i++) {\n\t            expr = expr.replace(/\\%/i, args[i]);\n\t        }\n\t        return expr;\n\t    };\n\t    /**\n\t\t *  tokenize the expression based on the Expressions object\n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}      returns two methods on the tokenized list, next and peek\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._tokenize = function (expr) {\n\t        var position = -1;\n\t        var tokens = [];\n\t        while (expr.length > 0) {\n\t            expr = expr.trim();\n\t            var token = getNextToken(expr);\n\t            tokens.push(token);\n\t            expr = expr.substr(token.value.length);\n\t        }\n\t        function getNextToken(expr) {\n\t            for (var type in Tone.Expr._Expressions) {\n\t                var group = Tone.Expr._Expressions[type];\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    var reg = op.regexp;\n\t                    var match = expr.match(reg);\n\t                    if (match !== null) {\n\t                        return {\n\t                            type: type,\n\t                            value: match[0],\n\t                            method: op.method\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);\n\t        }\n\t        return {\n\t            next: function () {\n\t                return tokens[++position];\n\t            },\n\t            peek: function () {\n\t                return tokens[position + 1];\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  recursively parse the string expression into a syntax tree\n\t\t *  \n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._parseTree = function (expr) {\n\t        var lexer = this._tokenize(expr);\n\t        var isUndef = this.isUndef.bind(this);\n\t        function matchSyntax(token, syn) {\n\t            return !isUndef(token) && token.type === 'glue' && token.value === syn;\n\t        }\n\t        function matchGroup(token, groupName, prec) {\n\t            var ret = false;\n\t            var group = Tone.Expr._Expressions[groupName];\n\t            if (!isUndef(token)) {\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    if (op.regexp.test(token.value)) {\n\t                        if (!isUndef(prec)) {\n\t                            if (op.precedence === prec) {\n\t                                return true;\n\t                            }\n\t                        } else {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return ret;\n\t        }\n\t        function parseExpression(precedence) {\n\t            if (isUndef(precedence)) {\n\t                precedence = 5;\n\t            }\n\t            var expr;\n\t            if (precedence < 0) {\n\t                expr = parseUnary();\n\t            } else {\n\t                expr = parseExpression(precedence - 1);\n\t            }\n\t            var token = lexer.peek();\n\t            while (matchGroup(token, 'binary', precedence)) {\n\t                token = lexer.next();\n\t                expr = {\n\t                    operator: token.value,\n\t                    method: token.method,\n\t                    args: [\n\t                        expr,\n\t                        parseExpression(precedence - 1)\n\t                    ]\n\t                };\n\t                token = lexer.peek();\n\t            }\n\t            return expr;\n\t        }\n\t        function parseUnary() {\n\t            var token, expr;\n\t            token = lexer.peek();\n\t            if (matchGroup(token, 'unary')) {\n\t                token = lexer.next();\n\t                expr = parseUnary();\n\t                return {\n\t                    operator: token.value,\n\t                    method: token.method,\n\t                    args: [expr]\n\t                };\n\t            }\n\t            return parsePrimary();\n\t        }\n\t        function parsePrimary() {\n\t            var token, expr;\n\t            token = lexer.peek();\n\t            if (isUndef(token)) {\n\t                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');\n\t            }\n\t            if (token.type === 'func') {\n\t                token = lexer.next();\n\t                return parseFunctionCall(token);\n\t            }\n\t            if (token.type === 'value') {\n\t                token = lexer.next();\n\t                return {\n\t                    method: token.method,\n\t                    args: token.value\n\t                };\n\t            }\n\t            if (matchSyntax(token, '(')) {\n\t                lexer.next();\n\t                expr = parseExpression();\n\t                token = lexer.next();\n\t                if (!matchSyntax(token, ')')) {\n\t                    throw new SyntaxError('Expected )');\n\t                }\n\t                return expr;\n\t            }\n\t            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);\n\t        }\n\t        function parseFunctionCall(func) {\n\t            var token, args = [];\n\t            token = lexer.next();\n\t            if (!matchSyntax(token, '(')) {\n\t                throw new SyntaxError('Tone.Expr: Expected ( in a function call \"' + func.value + '\"');\n\t            }\n\t            token = lexer.peek();\n\t            if (!matchSyntax(token, ')')) {\n\t                args = parseArgumentList();\n\t            }\n\t            token = lexer.next();\n\t            if (!matchSyntax(token, ')')) {\n\t                throw new SyntaxError('Tone.Expr: Expected ) in a function call \"' + func.value + '\"');\n\t            }\n\t            return {\n\t                method: func.method,\n\t                args: args,\n\t                name: name\n\t            };\n\t        }\n\t        function parseArgumentList() {\n\t            var token, expr, args = [];\n\t            while (true) {\n\t                expr = parseExpression();\n\t                if (isUndef(expr)) {\n\t                    // TODO maybe throw exception?\n\t                    break;\n\t                }\n\t                args.push(expr);\n\t                token = lexer.peek();\n\t                if (!matchSyntax(token, ',')) {\n\t                    break;\n\t                }\n\t                lexer.next();\n\t            }\n\t            return args;\n\t        }\n\t        return parseExpression();\n\t    };\n\t    /**\n\t\t *  recursively evaluate the expression tree\n\t\t *  @param   {Object} tree \n\t\t *  @return  {AudioNode}      the resulting audio node from the expression\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._eval = function (tree) {\n\t        if (!this.isUndef(tree)) {\n\t            var node = tree.method(tree.args, this);\n\t            this._nodes.push(node);\n\t            return node;\n\t        }\n\t    };\n\t    /**\n\t\t *  dispose all the nodes\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._disposeNodes = function () {\n\t        for (var i = 0; i < this._nodes.length; i++) {\n\t            var node = this._nodes[i];\n\t            if (this.isFunction(node.dispose)) {\n\t                node.dispose();\n\t            } else if (this.isFunction(node.disconnect)) {\n\t                node.disconnect();\n\t            }\n\t            node = null;\n\t            this._nodes[i] = null;\n\t        }\n\t        this._nodes = null;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t */\n\t    Tone.Expr.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._disposeNodes();\n\t    };\n\t    return Tone.Expr;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t * var eqPowGain = new Tone.EqualPowerGain();\n\t\t */\n\t    Tone.EqualPowerGain = function () {\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {\n\t            if (Math.abs(val) < 0.001) {\n\t                //should output 0 when input is 0\n\t                return 0;\n\t            } else {\n\t                return this.equalPowerScale(val);\n\t            }\n\t        }.bind(this), 4096);\n\t    };\n\t    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.EqualPowerGain} this\n\t\t */\n\t    Tone.EqualPowerGain.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._eqPower.dispose();\n\t        this._eqPower = null;\n\t        return this;\n\t    };\n\t    return Tone.EqualPowerGain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * @class  Tone.Crossfade provides equal power fading between two inputs. \n\t\t *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n\t\t *\n\t\t * @constructor\n\t\t * @extends {Tone}\n\t\t * @param {NormalRange} [initialFade=0.5]\n\t\t * @example\n\t\t * var crossFade = new Tone.CrossFade(0.5);\n\t\t * //connect effect A to crossfade from\n\t\t * //effect output 0 to crossfade input 0\n\t\t * effectA.connect(crossFade, 0, 0);\n\t\t * //connect effect B to crossfade from\n\t\t * //effect output 0 to crossfade input 1\n\t\t * effectB.connect(crossFade, 0, 1);\n\t\t * crossFade.fade.value = 0;\n\t\t * // ^ only effectA is output\n\t\t * crossFade.fade.value = 1;\n\t\t * // ^ only effectB is output\n\t\t * crossFade.fade.value = 0.5;\n\t\t * // ^ the two signals are mixed equally. \n\t\t */\n\t    Tone.CrossFade = function (initialFade) {\n\t        this.createInsOuts(2, 1);\n\t        /**\n\t\t\t *  Alias for <code>input[0]</code>. \n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.a = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  Alias for <code>input[1]</code>. \n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.b = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t * \tThe mix between the two inputs. A fade value of 0\n\t\t\t * \twill output 100% <code>input[0]</code> and \n\t\t\t * \ta value of 1 will output 100% <code>input[1]</code>. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.fade = new Tone.Signal(this.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  equal power gain cross fade\n\t\t\t *  @private\n\t\t\t *  @type {Tone.EqualPowerGain}\n\t\t\t */\n\t        this._equalPowerA = new Tone.EqualPowerGain();\n\t        /**\n\t\t\t *  equal power gain cross fade\n\t\t\t *  @private\n\t\t\t *  @type {Tone.EqualPowerGain}\n\t\t\t */\n\t        this._equalPowerB = new Tone.EqualPowerGain();\n\t        /**\n\t\t\t *  invert the incoming signal\n\t\t\t *  @private\n\t\t\t *  @type {Tone}\n\t\t\t */\n\t        this._invert = new Tone.Expr('1 - $0');\n\t        //connections\n\t        this.a.connect(this.output);\n\t        this.b.connect(this.output);\n\t        this.fade.chain(this._equalPowerB, this.b.gain);\n\t        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);\n\t        this._readOnly('fade');\n\t    };\n\t    Tone.extend(Tone.CrossFade);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.CrossFade} this\n\t\t */\n\t    Tone.CrossFade.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('fade');\n\t        this._equalPowerA.dispose();\n\t        this._equalPowerA = null;\n\t        this._equalPowerB.dispose();\n\t        this._equalPowerB = null;\n\t        this.fade.dispose();\n\t        this.fade = null;\n\t        this._invert.dispose();\n\t        this._invert = null;\n\t        this.a.dispose();\n\t        this.a = null;\n\t        this.b.dispose();\n\t        this.b = null;\n\t        return this;\n\t    };\n\t    return Tone.CrossFade;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Filter is a filter which allows for all of the same native methods\n\t\t *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface). \n\t\t *          Tone.Filter has the added ability to set the filter rolloff at -12 \n\t\t *          (default), -24 and -48. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.\n\t\t *  @param {string=} type The type of filter.\n\t\t *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.\n\t\t *                            3 choices: -12, -24, and -48\n\t\t *  @example\n\t\t *  var filter = new Tone.Filter(200, \"highpass\");\n\t\t */\n\t    Tone.Filter = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'rolloff'\n\t        ], Tone.Filter.defaults);\n\t        /**\n\t\t\t *  the filter(s)\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filters = [];\n\t        /**\n\t\t\t *  The cutoff frequency of the filter. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune parameter\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(0, Tone.Type.Cents);\n\t        /**\n\t\t\t *  The gain of the filter, only used in certain filter types\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.gain = new Tone.Signal({\n\t            'value': options.gain,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The Q or Quality of the filter\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q);\n\t        /**\n\t\t\t *  the type of the filter\n\t\t\t *  @type {string}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  the rolloff value of the filter\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rolloff = options.rolloff;\n\t        //set the rolloff;\n\t        this.rolloff = options.rolloff;\n\t        this._readOnly([\n\t            'detune',\n\t            'frequency',\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Filter);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Filter.defaults = {\n\t        'type': 'lowpass',\n\t        'frequency': 350,\n\t        'rolloff': -12,\n\t        'Q': 1,\n\t        'gain': 0\n\t    };\n\t    /**\n\t\t * The type of the filter. Types: \"lowpass\", \"highpass\", \n\t\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\". \n\t\t * @memberOf Tone.Filter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Filter.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            var types = [\n\t                'lowpass',\n\t                'highpass',\n\t                'bandpass',\n\t                'lowshelf',\n\t                'highshelf',\n\t                'notch',\n\t                'allpass',\n\t                'peaking'\n\t            ];\n\t            if (types.indexOf(type) === -1) {\n\t                throw new TypeError('Tone.Filter: invalid type ' + type);\n\t            }\n\t            this._type = type;\n\t            for (var i = 0; i < this._filters.length; i++) {\n\t                this._filters[i].type = type;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The rolloff of the filter which is the drop in db\n\t\t * per octave. Implemented internally by cascading filters.\n\t\t * Only accepts the values -12, -24, -48 and -96.\n\t\t * @memberOf Tone.Filter#\n\t\t * @type {number}\n\t\t * @name rolloff\n\t\t */\n\t    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {\n\t        get: function () {\n\t            return this._rolloff;\n\t        },\n\t        set: function (rolloff) {\n\t            rolloff = parseInt(rolloff, 10);\n\t            var possibilities = [\n\t                -12,\n\t                -24,\n\t                -48,\n\t                -96\n\t            ];\n\t            var cascadingCount = possibilities.indexOf(rolloff);\n\t            //check the rolloff is valid\n\t            if (cascadingCount === -1) {\n\t                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');\n\t            }\n\t            cascadingCount += 1;\n\t            this._rolloff = rolloff;\n\t            //first disconnect the filters and throw them away\n\t            this.input.disconnect();\n\t            for (var i = 0; i < this._filters.length; i++) {\n\t                this._filters[i].disconnect();\n\t                this._filters[i] = null;\n\t            }\n\t            this._filters = new Array(cascadingCount);\n\t            for (var count = 0; count < cascadingCount; count++) {\n\t                var filter = this.context.createBiquadFilter();\n\t                filter.type = this._type;\n\t                this.frequency.connect(filter.frequency);\n\t                this.detune.connect(filter.detune);\n\t                this.Q.connect(filter.Q);\n\t                this.gain.connect(filter.gain);\n\t                this._filters[count] = filter;\n\t            }\n\t            //connect them up\n\t            var connectionChain = [this.input].concat(this._filters).concat([this.output]);\n\t            this.connectSeries.apply(this, connectionChain);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @return {Tone.Filter} this\n\t\t */\n\t    Tone.Filter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        for (var i = 0; i < this._filters.length; i++) {\n\t            this._filters[i].disconnect();\n\t            this._filters[i] = null;\n\t        }\n\t        this._filters = null;\n\t        this._writable([\n\t            'detune',\n\t            'frequency',\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.Q.dispose();\n\t        this.frequency = null;\n\t        this.Q = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.gain.dispose();\n\t        this.gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Filter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Split the incoming signal into three bands (low, mid, high)\n\t\t *         with two crossover frequency controls. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency\n\t\t *  @param {Frequency} [highFrequency] the mid/high crossover frequency\n\t\t */\n\t    Tone.MultibandSplit = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ], Tone.MultibandSplit.defaults);\n\t        /**\n\t\t\t *  the input\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = new Tone.Gain();\n\t        /**\n\t\t\t *  the outputs\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Array(3);\n\t        /**\n\t\t\t *  The low band. Alias for <code>output[0]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');\n\t        /**\n\t\t\t *  the lower filter of the mid band\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowMidFilter = new Tone.Filter(0, 'highpass');\n\t        /**\n\t\t\t *  The mid band output. Alias for <code>output[1]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');\n\t        /**\n\t\t\t *  The high band output. Alias for <code>output[2]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.high = this.output[2] = new Tone.Filter(0, 'highpass');\n\t        /**\n\t\t\t *  The low/mid crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The mid/high crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The quality of all the filters\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q);\n\t        this.input.fan(this.low, this.high);\n\t        this.input.chain(this._lowMidFilter, this.mid);\n\t        //the frequency control signal\n\t        this.lowFrequency.connect(this.low.frequency);\n\t        this.lowFrequency.connect(this._lowMidFilter.frequency);\n\t        this.highFrequency.connect(this.mid.frequency);\n\t        this.highFrequency.connect(this.high.frequency);\n\t        //the Q value\n\t        this.Q.connect(this.low.Q);\n\t        this.Q.connect(this._lowMidFilter.Q);\n\t        this.Q.connect(this.mid.Q);\n\t        this.Q.connect(this.high.Q);\n\t        this._readOnly([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MultibandSplit);\n\t    /**\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MultibandSplit.defaults = {\n\t        'lowFrequency': 400,\n\t        'highFrequency': 2500,\n\t        'Q': 1\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MultibandSplit} this\n\t\t */\n\t    Tone.MultibandSplit.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t        this.low.dispose();\n\t        this.low = null;\n\t        this._lowMidFilter.dispose();\n\t        this._lowMidFilter = null;\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.high.dispose();\n\t        this.high = null;\n\t        this.lowFrequency.dispose();\n\t        this.lowFrequency = null;\n\t        this.highFrequency.dispose();\n\t        this.highFrequency = null;\n\t        this.Q.dispose();\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.MultibandSplit;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as\n\t\t *         well as the low and high crossover frequencies.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  \n\t\t *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.\n\t\t *  @param {Decibels} [midLevel] The gain applied to the mid.\n\t\t *  @param {Decibels} [highLevel] The gain applied to the high.\n\t\t *  @example\n\t\t * var eq = new Tone.EQ3(-10, 3, -20);\n\t\t */\n\t    Tone.EQ3 = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'low',\n\t            'mid',\n\t            'high'\n\t        ], Tone.EQ3.defaults);\n\t        /**\n\t\t\t *  the output node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  the multiband split\n\t\t\t *  @type {Tone.MultibandSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multibandSplit = this.input = new Tone.MultibandSplit({\n\t            'lowFrequency': options.lowFrequency,\n\t            'highFrequency': options.highFrequency\n\t        });\n\t        /**\n\t\t\t *  The gain for the lower signals\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);\n\t        /**\n\t\t\t *  The gain for the mid signals\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The gain in decibels of the high part\n\t\t\t * @type {Tone.Gain}\n\t\t\t * @private\n\t\t\t */\n\t        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The gain in decibels of the low part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.low = this._lowGain.gain;\n\t        /**\n\t\t\t * The gain in decibels of the mid part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.mid = this._midGain.gain;\n\t        /**\n\t\t\t * The gain in decibels of the high part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.high = this._highGain.gain;\n\t        /**\n\t\t\t *  The Q value for all of the filters. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = this._multibandSplit.Q;\n\t        /**\n\t\t\t *  The low/mid crossover frequency. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = this._multibandSplit.lowFrequency;\n\t        /**\n\t\t\t *  The mid/high crossover frequency. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = this._multibandSplit.highFrequency;\n\t        //the frequency bands\n\t        this._multibandSplit.low.chain(this._lowGain, this.output);\n\t        this._multibandSplit.mid.chain(this._midGain, this.output);\n\t        this._multibandSplit.high.chain(this._highGain, this.output);\n\t        this._readOnly([\n\t            'low',\n\t            'mid',\n\t            'high',\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.EQ3);\n\t    /**\n\t\t *  the default values\n\t\t */\n\t    Tone.EQ3.defaults = {\n\t        'low': 0,\n\t        'mid': 0,\n\t        'high': 0,\n\t        'lowFrequency': 400,\n\t        'highFrequency': 2500\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.EQ3} this\n\t\t */\n\t    Tone.EQ3.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'low',\n\t            'mid',\n\t            'high',\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ]);\n\t        this._multibandSplit.dispose();\n\t        this._multibandSplit = null;\n\t        this.lowFrequency = null;\n\t        this.highFrequency = null;\n\t        this._lowGain.dispose();\n\t        this._lowGain = null;\n\t        this._midGain.dispose();\n\t        this._midGain = null;\n\t        this._highGain.dispose();\n\t        this._highGain = null;\n\t        this.low = null;\n\t        this.mid = null;\n\t        this.high = null;\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.EQ3;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Performs a linear scaling on an input signal.\n\t\t *          Scales a NormalRange input to between\n\t\t *          outputMin and outputMax.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {number} [outputMin=0] The output value when the input is 0. \n\t\t *  @param {number} [outputMax=1]\tThe output value when the input is 1. \n\t\t *  @example\n\t\t * var scale = new Tone.Scale(50, 100);\n\t\t * var signal = new Tone.Signal(0.5).connect(scale);\n\t\t * //the output of scale equals 75\n\t\t */\n\t    Tone.Scale = function (outputMin, outputMax) {\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._outputMin = this.defaultArg(outputMin, 0);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._outputMax = this.defaultArg(outputMax, 1);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.input = new Tone.Multiply(1);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {Tone.Add}\n\t\t\t *  @private\n\t\t\t */\n\t        this._add = this.output = new Tone.Add(0);\n\t        this._scale.connect(this._add);\n\t        this._setRange();\n\t    };\n\t    Tone.extend(Tone.Scale, Tone.SignalBase);\n\t    /**\n\t\t * The minimum output value. This number is output when \n\t\t * the value input value is 0. \n\t\t * @memberOf Tone.Scale#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.Scale.prototype, 'min', {\n\t        get: function () {\n\t            return this._outputMin;\n\t        },\n\t        set: function (min) {\n\t            this._outputMin = min;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output value. This number is output when \n\t\t * the value input value is 1. \n\t\t * @memberOf Tone.Scale#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.Scale.prototype, 'max', {\n\t        get: function () {\n\t            return this._outputMax;\n\t        },\n\t        set: function (max) {\n\t            this._outputMax = max;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t *  set the values\n\t\t *  @private\n\t\t */\n\t    Tone.Scale.prototype._setRange = function () {\n\t        this._add.value = this._outputMin;\n\t        this._scale.value = this._outputMax - this._outputMin;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Scale} this\n\t\t */\n\t    Tone.Scale.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._add.dispose();\n\t        this._add = null;\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        return this;\n\t    };\n\t    return Tone.Scale;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class  Performs an exponential scaling on an input signal.\n\t\t *          Scales a NormalRange value [0,1] exponentially\n\t\t *          to the output range of outputMin to outputMax.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {number} [outputMin=0] The output value when the input is 0. \n\t\t *  @param {number} [outputMax=1]\tThe output value when the input is 1. \n\t\t *  @param {number} [exponent=2] The exponent which scales the incoming signal.\n\t\t *  @example\n\t\t * var scaleExp = new Tone.ScaleExp(0, 100, 2);\n\t\t * var signal = new Tone.Signal(0.5).connect(scaleExp);\n\t\t */\n\t    Tone.ScaleExp = function (outputMin, outputMax, exponent) {\n\t        /**\n\t\t\t *  scale the input to the output range\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.output = new Tone.Scale(outputMin, outputMax);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Pow}\n\t\t\t *  @private\n\t\t\t */\n\t        this._exp = this.input = new Tone.Pow(this.defaultArg(exponent, 2));\n\t        this._exp.connect(this._scale);\n\t    };\n\t    Tone.extend(Tone.ScaleExp, Tone.SignalBase);\n\t    /**\n\t\t * Instead of interpolating linearly between the <code>min</code> and \n\t\t * <code>max</code> values, setting the exponent will interpolate between\n\t\t * the two values with an exponential curve. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t * The minimum output value. This number is output when \n\t\t * the value input value is 0. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output value. This number is output when \n\t\t * the value input value is 1. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {\n\t        get: function () {\n\t            return this._scale.max;\n\t        },\n\t        set: function (max) {\n\t            this._scale.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.ScaleExp} this\n\t\t */\n\t    Tone.ScaleExp.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._exp.dispose();\n\t        this._exp = null;\n\t        return this;\n\t    };\n\t    return Tone.ScaleExp;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  createDelay shim\n\t\t *  @private\n\t\t */\n\t    if (window.DelayNode && !AudioContext.prototype.createDelay) {\n\t        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface). \n\t\t *  @extends {Tone}\n\t\t *  @param {Time=} delayTime The delay applied to the incoming signal.\n\t\t *  @param {Time=} maxDelay The maximum delay time. \n\t\t */\n\t    Tone.Delay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'maxDelay'\n\t        ], Tone.Delay.defaults);\n\t        /**\n\t\t\t *  The native delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));\n\t        /**\n\t\t\t *  The amount of time the incoming signal is\n\t\t\t *  delayed. \n\t\t\t *  @type {Tone.Param}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = new Tone.Param({\n\t            'param': this._delayNode.delayTime,\n\t            'units': Tone.Type.Time,\n\t            'value': options.delayTime\n\t        });\n\t        this._readOnly('delayTime');\n\t    };\n\t    Tone.extend(Tone.Delay);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Delay.defaults = {\n\t        'maxDelay': 1,\n\t        'delayTime': 0\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Delay}  this\n\t\t */\n\t    Tone.Delay.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._delayNode.disconnect();\n\t        this._delayNode = null;\n\t        this._writable('delayTime');\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.Delay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Comb filters are basic building blocks for physical modeling. Read more\n\t\t *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [delayTime] The delay time of the filter. \n\t\t *  @param {NormalRange=} resonance The amount of feedback the filter has. \n\t\t */\n\t    Tone.FeedbackCombFilter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'resonance'\n\t        ], Tone.FeedbackCombFilter.defaults);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The amount of delay of the comb filter. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delay.delayTime;\n\t        /**\n\t\t\t *  the feedback node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of feedback of the delayed signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._feedback.gain;\n\t        this._delay.chain(this._feedback, this._delay);\n\t        this._readOnly([\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FeedbackCombFilter);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackCombFilter.defaults = {\n\t        'delayTime': 0.1,\n\t        'resonance': 0.5\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FeedbackCombFilter} this\n\t\t */\n\t    Tone.FeedbackCombFilter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this.delayTime = null;\n\t        this._feedback.dispose();\n\t        this._feedback = null;\n\t        this.resonance = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackCombFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Follower is a  crude envelope follower which will follow \n\t\t *          the amplitude of an incoming signal. \n\t\t *          Take care with small (< 0.02) attack or decay values \n\t\t *          as follower has some ripple which is exaggerated\n\t\t *          at these values. Read more about envelope followers (also known \n\t\t *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Time|Object} [attack] The rate at which the follower rises.\n\t\t *  @param {Time=} release The rate at which the folower falls. \n\t\t *  @example\n\t\t * var follower = new Tone.Follower(0.2, 0.4);\n\t\t */\n\t    Tone.Follower = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'release'\n\t        ], Tone.Follower.defaults);\n\t        /**\n\t\t\t *  @type {Tone.Abs}\n\t\t\t *  @private\n\t\t\t */\n\t        this._abs = new Tone.Abs();\n\t        /**\n\t\t\t *  the lowpass filter which smooths the input\n\t\t\t *  @type {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filter = this.context.createBiquadFilter();\n\t        this._filter.type = 'lowpass';\n\t        this._filter.frequency.value = 0;\n\t        this._filter.Q.value = -100;\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._frequencyValues = new Tone.WaveShaper();\n\t        /**\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sub = new Tone.Subtract();\n\t        /**\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = new Tone.Delay(this.blockTime);\n\t        /**\n\t\t\t *  this keeps it far from 0, even for very small differences\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mult = new Tone.Multiply(10000);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._attack = options.attack;\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._release = options.release;\n\t        //the smoothed signal to get the values\n\t        this.input.chain(this._abs, this._filter, this.output);\n\t        //the difference path\n\t        this._abs.connect(this._sub, 0, 1);\n\t        this._filter.chain(this._delay, this._sub);\n\t        //threshold the difference and use the thresh to set the frequency\n\t        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);\n\t        //set the attack and release values in the table\n\t        this._setAttackRelease(this._attack, this._release);\n\t    };\n\t    Tone.extend(Tone.Follower);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Follower.defaults = {\n\t        'attack': 0.05,\n\t        'release': 0.5\n\t    };\n\t    /**\n\t\t *  sets the attack and release times in the wave shaper\n\t\t *  @param   {Time} attack  \n\t\t *  @param   {Time} release \n\t\t *  @private\n\t\t */\n\t    Tone.Follower.prototype._setAttackRelease = function (attack, release) {\n\t        var minTime = this.blockTime;\n\t        attack = Tone.Time(attack).toFrequency();\n\t        release = Tone.Time(release).toFrequency();\n\t        attack = Math.max(attack, minTime);\n\t        release = Math.max(release, minTime);\n\t        this._frequencyValues.setMap(function (val) {\n\t            if (val <= 0) {\n\t                return attack;\n\t            } else {\n\t                return release;\n\t            }\n\t        });\n\t    };\n\t    /**\n\t\t * The attack time.\n\t\t * @memberOf Tone.Follower#\n\t\t * @type {Time}\n\t\t * @name attack\n\t\t */\n\t    Object.defineProperty(Tone.Follower.prototype, 'attack', {\n\t        get: function () {\n\t            return this._attack;\n\t        },\n\t        set: function (attack) {\n\t            this._attack = attack;\n\t            this._setAttackRelease(this._attack, this._release);\n\t        }\n\t    });\n\t    /**\n\t\t * The release time.\n\t\t * @memberOf Tone.Follower#\n\t\t * @type {Time}\n\t\t * @name release\n\t\t */\n\t    Object.defineProperty(Tone.Follower.prototype, 'release', {\n\t        get: function () {\n\t            return this._release;\n\t        },\n\t        set: function (release) {\n\t            this._release = release;\n\t            this._setAttackRelease(this._attack, this._release);\n\t        }\n\t    });\n\t    /**\n\t\t *  Borrows the connect method from Signal so that the output can be used\n\t\t *  as a Tone.Signal control signal.\n\t\t *  @function\n\t\t */\n\t    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;\n\t    /**\n\t\t *  dispose\n\t\t *  @returns {Tone.Follower} this\n\t\t */\n\t    Tone.Follower.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._filter.disconnect();\n\t        this._filter = null;\n\t        this._frequencyValues.disconnect();\n\t        this._frequencyValues = null;\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this._sub.disconnect();\n\t        this._sub = null;\n\t        this._abs.dispose();\n\t        this._abs = null;\n\t        this._mult.dispose();\n\t        this._mult = null;\n\t        this._curve = null;\n\t        return this;\n\t    };\n\t    return Tone.Follower;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.ScaledEnvelop is an envelope which can be scaled \n\t\t *         to any range. It's useful for applying an envelope \n\t\t *         to a frequency or any other non-NormalRange signal \n\t\t *         parameter. \n\t\t *\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [attack]\tthe attack time in seconds\n\t\t *  @param {Time} [decay]\tthe decay time in seconds\n\t\t *  @param {number} [sustain] \ta percentage (0-1) of the full amplitude\n\t\t *  @param {Time} [release]\tthe release time in seconds\n\t\t *  @example\n\t\t *  var scaledEnv = new Tone.ScaledEnvelope({\n\t\t *  \t\"attack\" : 0.2,\n\t\t *  \t\"min\" : 200,\n\t\t *  \t\"max\" : 2000\n\t\t *  });\n\t\t *  scaledEnv.connect(oscillator.frequency);\n\t\t */\n\t    Tone.ScaledEnvelope = function () {\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        Tone.Envelope.call(this, options);\n\t        options = this.defaultArg(options, Tone.ScaledEnvelope.defaults);\n\t        /** \n\t\t\t *  scale the incoming signal by an exponent\n\t\t\t *  @type {Tone.Pow}\n\t\t\t *  @private\n\t\t\t */\n\t        this._exp = this.output = new Tone.Pow(options.exponent);\n\t        /**\n\t\t\t *  scale the signal to the desired range\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.output = new Tone.Scale(options.min, options.max);\n\t        this._sig.chain(this._exp, this._scale);\n\t    };\n\t    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.ScaledEnvelope.defaults = {\n\t        'min': 0,\n\t        'max': 1,\n\t        'exponent': 1\n\t    };\n\t    /**\n\t\t * The envelope's min output value. This is the value which it\n\t\t * starts at. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's max output value. In other words, the value\n\t\t * at the peak of the attack portion of the envelope. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {\n\t        get: function () {\n\t            return this._scale.max;\n\t        },\n\t        set: function (max) {\n\t            this._scale.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's exponent value. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.ScaledEnvelope} this\n\t\t */\n\t    Tone.ScaledEnvelope.prototype.dispose = function () {\n\t        Tone.Envelope.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._exp.dispose();\n\t        this._exp = null;\n\t        return this;\n\t    };\n\t    return Tone.ScaledEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`\n\t\t *         it's got a `baseFrequency` and `octaves` parameter. \n\t\t *\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [attack]\tthe attack time in seconds\n\t\t *  @param {Time} [decay]\tthe decay time in seconds\n\t\t *  @param {number} [sustain] \ta percentage (0-1) of the full amplitude\n\t\t *  @param {Time} [release]\tthe release time in seconds\n\t\t *  @example\n\t\t *  var env = new Tone.FrequencyEnvelope({\n\t\t *  \t\"attack\" : 0.2,\n\t\t *  \t\"baseFrequency\" : \"C2\",\n\t\t *  \t\"octaves\" : 4\n\t\t *  });\n\t\t *  scaledEnv.connect(oscillator.frequency);\n\t\t */\n\t    Tone.FrequencyEnvelope = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        Tone.ScaledEnvelope.call(this, options);\n\t        options = this.defaultArg(options, Tone.FrequencyEnvelope.defaults);\n\t        /**\n\t\t\t *  Stores the octave value\n\t\t\t *  @type {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        //setup\n\t        this.baseFrequency = options.baseFrequency;\n\t        this.octaves = options.octaves;\n\t    };\n\t    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.FrequencyEnvelope.defaults = {\n\t        'baseFrequency': 200,\n\t        'octaves': 4,\n\t        'exponent': 2\n\t    };\n\t    /**\n\t\t * The envelope's mininum output value. This is the value which it\n\t\t * starts at. \n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {Frequency}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = this.toFrequency(min);\n\t            //also update the octaves\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t * The number of octaves above the baseFrequency that the\n\t\t * envelope will scale to.\n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            this._scale.max = this.baseFrequency * Math.pow(2, octaves);\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's exponent value. \n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FrequencyEnvelope} this\n\t\t */\n\t    Tone.FrequencyEnvelope.prototype.dispose = function () {\n\t        Tone.ScaledEnvelope.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.FrequencyEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Gate only passes a signal through when the incoming \n\t\t *          signal exceeds a specified threshold. To do this, Gate uses \n\t\t *          a Tone.Follower to follow the amplitude of the incoming signal. \n\t\t *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Decibels|Object} [threshold] The threshold above which the gate will open. \n\t\t *  @param {Time=} attack The follower's attack time\n\t\t *  @param {Time=} release The follower's release time\n\t\t *  @example\n\t\t * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();\n\t\t * var mic = new Tone.UserMedia().connect(gate);\n\t\t * //the gate will only pass through the incoming \n\t\t * //signal when it's louder than -30db\n\t\t */\n\t    Tone.Gate = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'threshold',\n\t            'attack',\n\t            'release'\n\t        ], Tone.Gate.defaults);\n\t        /**\n\t\t\t *  @type {Tone.Follower}\n\t\t\t *  @private\n\t\t\t */\n\t        this._follower = new Tone.Follower(options.attack, options.release);\n\t        /**\n\t\t\t *  @type {Tone.GreaterThan}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gt = new Tone.GreaterThan(this.dbToGain(options.threshold));\n\t        //the connections\n\t        this.input.connect(this.output);\n\t        //the control signal\n\t        this.input.chain(this._gt, this._follower, this.output.gain);\n\t    };\n\t    Tone.extend(Tone.Gate);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Gate.defaults = {\n\t        'attack': 0.1,\n\t        'release': 0.1,\n\t        'threshold': -40\n\t    };\n\t    /**\n\t\t * The threshold of the gate in decibels\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Decibels}\n\t\t * @name threshold\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'threshold', {\n\t        get: function () {\n\t            return this.gainToDb(this._gt.value);\n\t        },\n\t        set: function (thresh) {\n\t            this._gt.value = this.dbToGain(thresh);\n\t        }\n\t    });\n\t    /**\n\t\t * The attack speed of the gate\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Time}\n\t\t * @name attack\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'attack', {\n\t        get: function () {\n\t            return this._follower.attack;\n\t        },\n\t        set: function (attackTime) {\n\t            this._follower.attack = attackTime;\n\t        }\n\t    });\n\t    /**\n\t\t * The release speed of the gate\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Time}\n\t\t * @name release\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'release', {\n\t        get: function () {\n\t            return this._follower.release;\n\t        },\n\t        set: function (releaseTime) {\n\t            this._follower.release = releaseTime;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Gate} this\n\t\t */\n\t    Tone.Gate.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._follower.dispose();\n\t        this._gt.dispose();\n\t        this._follower = null;\n\t        this._gt = null;\n\t        return this;\n\t    };\n\t    return Tone.Gate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A Timeline State. Provides the methods: <code>setStateAtTime(\"state\", time)</code>\n\t\t *          and <code>getValueAtTime(time)</code>.\n\t\t *\n\t\t *  @extends {Tone.Timeline}\n\t\t *  @param {String} initial The initial state of the TimelineState. \n\t\t *                          Defaults to <code>undefined</code>\n\t\t */\n\t    Tone.TimelineState = function (initial) {\n\t        Tone.Timeline.call(this);\n\t        /**\n\t\t\t *  The initial state\n\t\t\t *  @private\n\t\t\t *  @type {String}\n\t\t\t */\n\t        this._initial = initial;\n\t    };\n\t    Tone.extend(Tone.TimelineState, Tone.Timeline);\n\t    /**\n\t\t *  Returns the scheduled state scheduled before or at\n\t\t *  the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @return  {String}  The name of the state input in setStateAtTime.\n\t\t */\n\t    Tone.TimelineState.prototype.getValueAtTime = function (time) {\n\t        var event = this.get(time);\n\t        if (event !== null) {\n\t            return event.state;\n\t        } else {\n\t            return this._initial;\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the scheduled state scheduled before or at\n\t\t *  the given time.\n\t\t *  @param  {String}  state The name of the state to set.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t */\n\t    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {\n\t        this.add({\n\t            'state': state,\n\t            'time': time\n\t        });\n\t    };\n\t    return Tone.TimelineState;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A sample accurate clock which provides a callback at the given rate. \n\t\t *          While the callback is not sample-accurate (it is still susceptible to\n\t\t *          loose JS timing), the time passed in as the argument to the callback\n\t\t *          is precise. For most applications, it is better to use Tone.Transport\n\t\t *          instead of the Clock by itself since you can synchronize multiple callbacks.\n\t\t *\n\t\t * \t@constructor\n\t\t *  @extends {Tone.Emitter}\n\t\t * \t@param {function} callback The callback to be invoked with the time of the audio event\n\t\t * \t@param {Frequency} frequency The rate of the callback\n\t\t * \t@example\n\t\t * //the callback will be invoked approximately once a second\n\t\t * //and will print the time exactly once a second apart.\n\t\t * var clock = new Tone.Clock(function(time){\n\t\t * \tconsole.log(time);\n\t\t * }, 1);\n\t\t */\n\t    Tone.Clock = function () {\n\t        Tone.Emitter.call(this);\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'frequency'\n\t        ], Tone.Clock.defaults);\n\t        /**\n\t\t\t *  The callback function to invoke at the scheduled tick.\n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  The next time the callback is scheduled.\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._nextTick = 0;\n\t        /**\n\t\t\t *  The last state of the clock.\n\t\t\t *  @type  {State}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lastState = Tone.State.Stopped;\n\t        /**\n\t\t\t *  The rate the callback function should be invoked. \n\t\t\t *  @type  {BPM}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.TimelineSignal(options.frequency, Tone.Type.Frequency);\n\t        this._readOnly('frequency');\n\t        /**\n\t\t\t *  The number of times the callback was invoked. Starts counting at 0\n\t\t\t *  and increments after the callback was invoked. \n\t\t\t *  @type {Ticks}\n\t\t\t *  @readOnly\n\t\t\t */\n\t        this.ticks = 0;\n\t        /**\n\t\t\t *  The state timeline\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  The loop function bound to its context. \n\t\t\t *  This is necessary to remove the event in the end.\n\t\t\t *  @type {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._boundLoop = this._loop.bind(this);\n\t        //bind a callback to the worker thread\n\t        this.context.on('tick', this._boundLoop);\n\t    };\n\t    Tone.extend(Tone.Clock, Tone.Emitter);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Clock.defaults = {\n\t        'callback': Tone.noOp,\n\t        'frequency': 1,\n\t        'lookAhead': 'auto'\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Clock#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Clock.prototype, 'state', {\n\t        get: function () {\n\t            return this._state.getValueAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the clock at the given time. Optionally pass in an offset\n\t\t *  of where to start the tick counter from.\n\t\t *  @param  {Time}  time    The time the clock should start\n\t\t *  @param  {Ticks=}  offset  Where the tick counter starts counting from.\n\t\t *  @return  {Tone.Clock}  this\n\t\t */\n\t    Tone.Clock.prototype.start = function (time, offset) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) !== Tone.State.Started) {\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': time,\n\t                'offset': offset\n\t            });\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t\t *  @param {Time} [time=now] The time when the clock should stop.\n\t\t *  @returns {Tone.Clock} this\n\t\t *  @example\n\t\t * clock.stop();\n\t\t */\n\t    Tone.Clock.prototype.stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._state.cancel(time);\n\t        this._state.setStateAtTime(Tone.State.Stopped, time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Pause the clock. Pausing does not reset the tick counter.\n\t\t *  @param {Time} [time=now] The time when the clock should stop.\n\t\t *  @returns {Tone.Clock} this\n\t\t */\n\t    Tone.Clock.prototype.pause = function (time) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this._state.setStateAtTime(Tone.State.Paused, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The scheduling loop.\n\t\t *  @param  {Number}  time  The current page time starting from 0\n\t\t *                          when the page was loaded.\n\t\t *  @private\n\t\t */\n\t    Tone.Clock.prototype._loop = function () {\n\t        //get the frequency value to compute the value of the next loop\n\t        var now = this.now();\n\t        //if it's started\n\t        var lookAhead = this.context.lookAhead;\n\t        var updateInterval = this.context.updateInterval;\n\t        var lagCompensation = this.context.lag * 2;\n\t        var loopInterval = now + lookAhead + updateInterval + lagCompensation;\n\t        while (loopInterval > this._nextTick && this._state) {\n\t            var currentState = this._state.getValueAtTime(this._nextTick);\n\t            if (currentState !== this._lastState) {\n\t                this._lastState = currentState;\n\t                var event = this._state.get(this._nextTick);\n\t                // emit an event\n\t                if (currentState === Tone.State.Started) {\n\t                    //correct the time\n\t                    this._nextTick = event.time;\n\t                    if (!this.isUndef(event.offset)) {\n\t                        this.ticks = event.offset;\n\t                    }\n\t                    this.emit('start', event.time, this.ticks);\n\t                } else if (currentState === Tone.State.Stopped) {\n\t                    this.ticks = 0;\n\t                    this.emit('stop', event.time);\n\t                } else if (currentState === Tone.State.Paused) {\n\t                    this.emit('pause', event.time);\n\t                }\n\t            }\n\t            var tickTime = this._nextTick;\n\t            if (this.frequency) {\n\t                this._nextTick += 1 / this.frequency.getValueAtTime(this._nextTick);\n\t                if (currentState === Tone.State.Started) {\n\t                    this.callback(tickTime);\n\t                    this.ticks++;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the scheduled state at the given time.\n\t\t *  @param  {Time}  time  The time to query.\n\t\t *  @return  {String}  The name of the state input in setStateAtTime.\n\t\t *  @example\n\t\t * clock.start(\"+0.1\");\n\t\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t\t */\n\t    Tone.Clock.prototype.getStateAtTime = function (time) {\n\t        time = this.toSeconds(time);\n\t        return this._state.getValueAtTime(time);\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.Clock} this\n\t\t */\n\t    Tone.Clock.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this.context.off('tick', this._boundLoop);\n\t        this._writable('frequency');\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._boundLoop = null;\n\t        this._nextTick = Infinity;\n\t        this.callback = null;\n\t        this._state.dispose();\n\t        this._state = null;\n\t    };\n\t    return Tone.Clock;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Similar to Tone.Timeline, but all events represent\n\t\t *         intervals with both \"time\" and \"duration\" times. The \n\t\t *         events are placed in a tree structure optimized\n\t\t *         for querying an intersection point with the timeline\n\t\t *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n\t\t *         to represent the data.\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.IntervalTimeline = function () {\n\t        /**\n\t\t\t *  The root node of the inteval tree\n\t\t\t *  @type  {IntervalNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._root = null;\n\t        /**\n\t\t\t *  Keep track of the length of the timeline.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._length = 0;\n\t    };\n\t    Tone.extend(Tone.IntervalTimeline);\n\t    /**\n\t\t *  The event to add to the timeline. All events must \n\t\t *  have a time and duration value\n\t\t *  @param  {Object}  event  The event to add to the timeline\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.add = function (event) {\n\t        if (this.isUndef(event.time) || this.isUndef(event.duration)) {\n\t            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');\n\t        }\n\t        var node = new IntervalNode(event.time, event.time + event.duration, event);\n\t        if (this._root === null) {\n\t            this._root = node;\n\t        } else {\n\t            this._root.insert(node);\n\t        }\n\t        this._length++;\n\t        // Restructure tree to be balanced\n\t        while (node !== null) {\n\t            node.updateHeight();\n\t            node.updateMax();\n\t            this._rebalance(node);\n\t            node = node.parent;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove an event from the timeline.\n\t\t *  @param  {Object}  event  The event to remove from the timeline\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.remove = function (event) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(event.time, results);\n\t            for (var i = 0; i < results.length; i++) {\n\t                var node = results[i];\n\t                if (node.event === event) {\n\t                    this._removeNode(node);\n\t                    this._length--;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The number of items in the timeline.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.IntervalTimeline#\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {\n\t        get: function () {\n\t            return this._length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Remove events whose time time is after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.cancel = function (after) {\n\t        this.forEachAfter(after, function (event) {\n\t            this.remove(event);\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the root node as the given node\n\t\t *  @param {IntervalNode} node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._setRoot = function (node) {\n\t        this._root = node;\n\t        if (this._root !== null) {\n\t            this._root.parent = null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Replace the references to the node in the node's parent\n\t\t *  with the replacement node.\n\t\t *  @param  {IntervalNode}  node        \n\t\t *  @param  {IntervalNode}  replacement \n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {\n\t        if (node.parent !== null) {\n\t            if (node.isLeftChild()) {\n\t                node.parent.left = replacement;\n\t            } else {\n\t                node.parent.right = replacement;\n\t            }\n\t            this._rebalance(node.parent);\n\t        } else {\n\t            this._setRoot(replacement);\n\t        }\n\t    };\n\t    /**\n\t\t *  Remove the node from the tree and replace it with \n\t\t *  a successor which follows the schema.\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._removeNode = function (node) {\n\t        if (node.left === null && node.right === null) {\n\t            this._replaceNodeInParent(node, null);\n\t        } else if (node.right === null) {\n\t            this._replaceNodeInParent(node, node.left);\n\t        } else if (node.left === null) {\n\t            this._replaceNodeInParent(node, node.right);\n\t        } else {\n\t            var balance = node.getBalance();\n\t            var replacement, temp;\n\t            if (balance > 0) {\n\t                if (node.left.right === null) {\n\t                    replacement = node.left;\n\t                    replacement.right = node.right;\n\t                    temp = replacement;\n\t                } else {\n\t                    replacement = node.left.right;\n\t                    while (replacement.right !== null) {\n\t                        replacement = replacement.right;\n\t                    }\n\t                    replacement.parent.right = replacement.left;\n\t                    temp = replacement.parent;\n\t                    replacement.left = node.left;\n\t                    replacement.right = node.right;\n\t                }\n\t            } else {\n\t                if (node.right.left === null) {\n\t                    replacement = node.right;\n\t                    replacement.left = node.left;\n\t                    temp = replacement;\n\t                } else {\n\t                    replacement = node.right.left;\n\t                    while (replacement.left !== null) {\n\t                        replacement = replacement.left;\n\t                    }\n\t                    replacement.parent = replacement.parent;\n\t                    replacement.parent.left = replacement.right;\n\t                    temp = replacement.parent;\n\t                    replacement.left = node.left;\n\t                    replacement.right = node.right;\n\t                }\n\t            }\n\t            if (node.parent !== null) {\n\t                if (node.isLeftChild()) {\n\t                    node.parent.left = replacement;\n\t                } else {\n\t                    node.parent.right = replacement;\n\t                }\n\t            } else {\n\t                this._setRoot(replacement);\n\t            }\n\t            // this._replaceNodeInParent(node, replacement);\n\t            this._rebalance(temp);\n\t        }\n\t        node.dispose();\n\t    };\n\t    /**\n\t\t *  Rotate the tree to the left\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {\n\t        var parent = node.parent;\n\t        var isLeftChild = node.isLeftChild();\n\t        // Make node.right the new root of this sub tree (instead of node)\n\t        var pivotNode = node.right;\n\t        node.right = pivotNode.left;\n\t        pivotNode.left = node;\n\t        if (parent !== null) {\n\t            if (isLeftChild) {\n\t                parent.left = pivotNode;\n\t            } else {\n\t                parent.right = pivotNode;\n\t            }\n\t        } else {\n\t            this._setRoot(pivotNode);\n\t        }\n\t    };\n\t    /**\n\t\t *  Rotate the tree to the right\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rotateRight = function (node) {\n\t        var parent = node.parent;\n\t        var isLeftChild = node.isLeftChild();\n\t        // Make node.left the new root of this sub tree (instead of node)\n\t        var pivotNode = node.left;\n\t        node.left = pivotNode.right;\n\t        pivotNode.right = node;\n\t        if (parent !== null) {\n\t            if (isLeftChild) {\n\t                parent.left = pivotNode;\n\t            } else {\n\t                parent.right = pivotNode;\n\t            }\n\t        } else {\n\t            this._setRoot(pivotNode);\n\t        }\n\t    };\n\t    /**\n\t\t *  Balance the BST\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rebalance = function (node) {\n\t        var balance = node.getBalance();\n\t        if (balance > 1) {\n\t            if (node.left.getBalance() < 0) {\n\t                this._rotateLeft(node.left);\n\t            } else {\n\t                this._rotateRight(node);\n\t            }\n\t        } else if (balance < -1) {\n\t            if (node.right.getBalance() > 0) {\n\t                this._rotateRight(node.right);\n\t            } else {\n\t                this._rotateLeft(node);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Get an event whose time and duration span the give time. Will\n\t\t *  return the match whose \"time\" value is closest to the given time.\n\t\t *  @param  {Object}  event  The event to add to the timeline\n\t\t *  @return  {Object}  The event which spans the desired time\n\t\t */\n\t    Tone.IntervalTimeline.prototype.get = function (time) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(time, results);\n\t            if (results.length > 0) {\n\t                var max = results[0];\n\t                for (var i = 1; i < results.length; i++) {\n\t                    if (results[i].low > max.low) {\n\t                        max = results[i];\n\t                    }\n\t                }\n\t                return max.event;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the timeline.\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEach = function (callback) {\n\t        if (this._root !== null) {\n\t            var allNodes = [];\n\t            if (this._root !== null) {\n\t                this._root.traverse(function (node) {\n\t                    allNodes.push(node);\n\t                });\n\t            }\n\t            for (var i = 0; i < allNodes.length; i++) {\n\t                var ev = allNodes[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array in which the given time\n\t\t *  overlaps with the time and duration time of the event.\n\t\t *  @param  {Number}  time The time to check if items are overlapping\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(time, results);\n\t            for (var i = results.length - 1; i >= 0; i--) {\n\t                var ev = results[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array in which the time is greater\n\t\t *  than the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.searchAfter(time, results);\n\t            for (var i = results.length - 1; i >= 0; i--) {\n\t                var ev = results[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.dispose = function () {\n\t        var allNodes = [];\n\t        if (this._root !== null) {\n\t            this._root.traverse(function (node) {\n\t                allNodes.push(node);\n\t            });\n\t        }\n\t        for (var i = 0; i < allNodes.length; i++) {\n\t            allNodes[i].dispose();\n\t        }\n\t        allNodes = null;\n\t        this._root = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tINTERVAL NODE HELPER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Represents a node in the binary search tree, with the addition\n\t\t *  of a \"high\" value which keeps track of the highest value of\n\t\t *  its children. \n\t\t *  References: \n\t\t *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n\t\t *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n\t\t *  @param {Number} low\n\t\t *  @param {Number} high\n\t\t *  @private\n\t\t */\n\t    var IntervalNode = function (low, high, event) {\n\t        //the event container\n\t        this.event = event;\n\t        //the low value\n\t        this.low = low;\n\t        //the high value\n\t        this.high = high;\n\t        //the high value for this and all child nodes\n\t        this.max = this.high;\n\t        //the nodes to the left\n\t        this._left = null;\n\t        //the nodes to the right\n\t        this._right = null;\n\t        //the parent node\n\t        this.parent = null;\n\t        //the number of child nodes\n\t        this.height = 0;\n\t    };\n\t    /** \n\t\t *  Insert a node into the correct spot in the tree\n\t\t *  @param  {IntervalNode}  node\n\t\t */\n\t    IntervalNode.prototype.insert = function (node) {\n\t        if (node.low <= this.low) {\n\t            if (this.left === null) {\n\t                this.left = node;\n\t            } else {\n\t                this.left.insert(node);\n\t            }\n\t        } else {\n\t            if (this.right === null) {\n\t                this.right = node;\n\t            } else {\n\t                this.right.insert(node);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Search the tree for nodes which overlap \n\t\t *  with the given point\n\t\t *  @param  {Number}  point  The point to query\n\t\t *  @param  {Array}  results  The array to put the results\n\t\t */\n\t    IntervalNode.prototype.search = function (point, results) {\n\t        // If p is to the right of the rightmost point of any interval\n\t        // in this node and all children, there won't be any matches.\n\t        if (point > this.max) {\n\t            return;\n\t        }\n\t        // Search left children\n\t        if (this.left !== null) {\n\t            this.left.search(point, results);\n\t        }\n\t        // Check this node\n\t        if (this.low <= point && this.high > point) {\n\t            results.push(this);\n\t        }\n\t        // If p is to the left of the time of this interval,\n\t        // then it can't be in any child to the right.\n\t        if (this.low > point) {\n\t            return;\n\t        }\n\t        // Search right children\n\t        if (this.right !== null) {\n\t            this.right.search(point, results);\n\t        }\n\t    };\n\t    /**\n\t\t *  Search the tree for nodes which are less \n\t\t *  than the given point\n\t\t *  @param  {Number}  point  The point to query\n\t\t *  @param  {Array}  results  The array to put the results\n\t\t */\n\t    IntervalNode.prototype.searchAfter = function (point, results) {\n\t        // Check this node\n\t        if (this.low >= point) {\n\t            results.push(this);\n\t            if (this.left !== null) {\n\t                this.left.searchAfter(point, results);\n\t            }\n\t        }\n\t        // search the right side\n\t        if (this.right !== null) {\n\t            this.right.searchAfter(point, results);\n\t        }\n\t    };\n\t    /**\n\t\t *  Invoke the callback on this element and both it's branches\n\t\t *  @param  {Function}  callback\n\t\t */\n\t    IntervalNode.prototype.traverse = function (callback) {\n\t        callback(this);\n\t        if (this.left !== null) {\n\t            this.left.traverse(callback);\n\t        }\n\t        if (this.right !== null) {\n\t            this.right.traverse(callback);\n\t        }\n\t    };\n\t    /**\n\t\t *  Update the height of the node\n\t\t */\n\t    IntervalNode.prototype.updateHeight = function () {\n\t        if (this.left !== null && this.right !== null) {\n\t            this.height = Math.max(this.left.height, this.right.height) + 1;\n\t        } else if (this.right !== null) {\n\t            this.height = this.right.height + 1;\n\t        } else if (this.left !== null) {\n\t            this.height = this.left.height + 1;\n\t        } else {\n\t            this.height = 0;\n\t        }\n\t    };\n\t    /**\n\t\t *  Update the height of the node\n\t\t */\n\t    IntervalNode.prototype.updateMax = function () {\n\t        this.max = this.high;\n\t        if (this.left !== null) {\n\t            this.max = Math.max(this.max, this.left.max);\n\t        }\n\t        if (this.right !== null) {\n\t            this.max = Math.max(this.max, this.right.max);\n\t        }\n\t    };\n\t    /**\n\t\t *  The balance is how the leafs are distributed on the node\n\t\t *  @return  {Number}  Negative numbers are balanced to the right\n\t\t */\n\t    IntervalNode.prototype.getBalance = function () {\n\t        var balance = 0;\n\t        if (this.left !== null && this.right !== null) {\n\t            balance = this.left.height - this.right.height;\n\t        } else if (this.left !== null) {\n\t            balance = this.left.height + 1;\n\t        } else if (this.right !== null) {\n\t            balance = -(this.right.height + 1);\n\t        }\n\t        return balance;\n\t    };\n\t    /**\n\t\t *  @returns {Boolean} true if this node is the left child\n\t\t *  of its parent\n\t\t */\n\t    IntervalNode.prototype.isLeftChild = function () {\n\t        return this.parent !== null && this.parent.left === this;\n\t    };\n\t    /**\n\t\t *  get/set the left node\n\t\t *  @type {IntervalNode}\n\t\t */\n\t    Object.defineProperty(IntervalNode.prototype, 'left', {\n\t        get: function () {\n\t            return this._left;\n\t        },\n\t        set: function (node) {\n\t            this._left = node;\n\t            if (node !== null) {\n\t                node.parent = this;\n\t            }\n\t            this.updateHeight();\n\t            this.updateMax();\n\t        }\n\t    });\n\t    /**\n\t\t *  get/set the right node\n\t\t *  @type {IntervalNode}\n\t\t */\n\t    Object.defineProperty(IntervalNode.prototype, 'right', {\n\t        get: function () {\n\t            return this._right;\n\t        },\n\t        set: function (node) {\n\t            this._right = node;\n\t            if (node !== null) {\n\t                node.parent = this;\n\t            }\n\t            this.updateHeight();\n\t            this.updateMax();\n\t        }\n\t    });\n\t    /**\n\t\t *  null out references.\n\t\t */\n\t    IntervalNode.prototype.dispose = function () {\n\t        this.parent = null;\n\t        this._left = null;\n\t        this._right = null;\n\t        this.event = null;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEND INTERVAL NODE HELPER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    return Tone.IntervalTimeline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Transport for timing musical events.\n\t\t *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n\t\t *          Tone.Transport timing events pass in the exact time of the scheduled event\n\t\t *          in the argument of the callback function. Pass that time value to the object\n\t\t *          you're scheduling. <br><br>\n\t\t *          A single transport is created for you when the library is initialized. \n\t\t *          <br><br>\n\t\t *          The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n\t\t *          called with the time of that event as the argument. \n\t\t *\n\t\t *  @extends {Tone.Emitter}\n\t\t *  @singleton\n\t\t *  @example\n\t\t * //repeated event every 8th note\n\t\t * Tone.Transport.scheduleRepeat(function(time){\n\t\t * \t//do something with the time\n\t\t * }, \"8n\");\n\t\t *  @example\n\t\t * //schedule an event on the 16th measure\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \t//do something with the time\n\t\t * }, \"16:0:0\");\n\t\t */\n\t    Tone.Transport = function () {\n\t        Tone.Emitter.call(this);\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tLOOPING\n\t        //////////////////////////////////////////////////////////////////////\n\t        /** \n\t\t\t * \tIf the transport loops or not.\n\t\t\t *  @type {boolean}\n\t\t\t */\n\t        this.loop = false;\n\t        /** \n\t\t\t * \tThe loop start position in ticks\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = 0;\n\t        /** \n\t\t\t * \tThe loop end position in ticks\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = 0;\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tCLOCK/TEMPO\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  Pulses per quarter is the number of ticks per quarter note.\n\t\t\t *  @private\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this._ppq = TransportConstructor.defaults.PPQ;\n\t        /**\n\t\t\t *  watches the main oscillator for timing ticks\n\t\t\t *  initially starts at 120bpm\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Clock}\n\t\t\t */\n\t        this._clock = new Tone.Clock({\n\t            'callback': this._processTick.bind(this),\n\t            'frequency': 0\n\t        });\n\t        this._bindClockEvents();\n\t        /**\n\t\t\t *  The Beats Per Minute of the Transport. \n\t\t\t *  @type {BPM}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * Tone.Transport.bpm.value = 80;\n\t\t\t * //ramp the bpm to 120 over 10 seconds\n\t\t\t * Tone.Transport.bpm.rampTo(120, 10);\n\t\t\t */\n\t        this.bpm = this._clock.frequency;\n\t        this.bpm._toUnits = this._toUnits.bind(this);\n\t        this.bpm._fromUnits = this._fromUnits.bind(this);\n\t        this.bpm.units = Tone.Type.BPM;\n\t        this.bpm.value = TransportConstructor.defaults.bpm;\n\t        this._readOnly('bpm');\n\t        /**\n\t\t\t *  The time signature, or more accurately the numerator\n\t\t\t *  of the time signature over a denominator of 4. \n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeSignature = TransportConstructor.defaults.timeSignature;\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tTIMELINE EVENTS\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  All the events in an object to keep track by ID\n\t\t\t *  @type {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scheduledEvents = {};\n\t        /**\n\t\t\t *  The event ID counter\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._eventID = 0;\n\t        /**\n\t\t\t * \tThe scheduled events.\n\t\t\t *  @type {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeline = new Tone.Timeline();\n\t        /**\n\t\t\t *  Repeated events\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._repeatedEvents = new Tone.IntervalTimeline();\n\t        /**\n\t\t\t *  Events that occur once\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._onceEvents = new Tone.Timeline();\n\t        /** \n\t\t\t *  All of the synced Signals\n\t\t\t *  @private \n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this._syncedSignals = [];\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tSWING\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  The subdivision of the swing\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._swingTicks = TransportConstructor.defaults.PPQ / 2;\n\t        //8n\n\t        /**\n\t\t\t *  The swing amount\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._swingAmount = 0;\n\t    };\n\t    Tone.extend(Tone.Transport, Tone.Emitter);\n\t    /**\n\t\t *  the defaults\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Transport.defaults = {\n\t        'bpm': 120,\n\t        'swing': 0,\n\t        'swingSubdivision': '8n',\n\t        'timeSignature': 4,\n\t        'loopStart': 0,\n\t        'loopEnd': '4m',\n\t        'PPQ': 192\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tTICKS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  called on every tick\n\t\t *  @param   {number} tickTime clock relative tick time\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._processTick = function (tickTime) {\n\t        var ticks = this._clock.ticks;\n\t        //handle swing\n\t        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat\n\t            ticks % (this._swingTicks * 2) !== 0) {\n\t            //add some swing\n\t            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\t            var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\t            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i') * amount;\n\t        }\n\t        //do the loop test\n\t        if (this.loop) {\n\t            if (ticks === this._loopEnd) {\n\t                this.emit('loopEnd', tickTime);\n\t                this._clock.ticks = this._loopStart;\n\t                ticks = this._loopStart;\n\t                this.emit('loopStart', tickTime, this.seconds);\n\t                this.emit('loop', tickTime);\n\t            }\n\t        }\n\t        //process the single occurrence events\n\t        this._onceEvents.forEachBefore(ticks, function (event) {\n\t            event.callback(tickTime);\n\t            //remove the event\n\t            delete this._scheduledEvents[event.id.toString()];\n\t        }.bind(this));\n\t        //and clear the single occurrence timeline\n\t        this._onceEvents.cancelBefore(ticks);\n\t        //fire the next tick events if their time has come\n\t        this._timeline.forEachAtTime(ticks, function (event) {\n\t            event.callback(tickTime);\n\t        });\n\t        //process the repeated events\n\t        this._repeatedEvents.forEachAtTime(ticks, function (event) {\n\t            if ((ticks - event.time) % event.interval === 0) {\n\t                event.callback(tickTime);\n\t            }\n\t        });\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSCHEDULABLE EVENTS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Schedule an event along the timeline.\n\t\t *  @param {Function} callback The callback to be invoked at the time.\n\t\t *  @param {TransportTime}  time The time to invoke the callback at.\n\t\t *  @return {Number} The id of the event which can be used for canceling the event. \n\t\t *  @example\n\t\t * //trigger the callback when the Transport reaches the desired time\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \tenvelope.triggerAttack(time);\n\t\t * }, \"128i\");\n\t\t */\n\t    Tone.Transport.prototype.schedule = function (callback, time) {\n\t        var event = {\n\t            'time': this.toTicks(time),\n\t            'callback': callback\n\t        };\n\t        var id = this._eventID++;\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._timeline\n\t        };\n\t        this._timeline.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Schedule a repeated event along the timeline. The event will fire\n\t\t *  at the `interval` starting at the `startTime` and for the specified\n\t\t *  `duration`. \n\t\t *  @param  {Function}  callback   The callback to invoke.\n\t\t *  @param  {Time}    interval   The duration between successive\n\t\t *                               callbacks.\n\t\t *  @param  {TimelinePosition=}    startTime  When along the timeline the events should\n\t\t *                               start being invoked.\n\t\t *  @param {Time} [duration=Infinity] How long the event should repeat. \n\t\t *  @return  {Number}    The ID of the scheduled event. Use this to cancel\n\t\t *                           the event. \n\t\t *  @example\n\t\t * //a callback invoked every eighth note after the first measure\n\t\t * Tone.Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t\t */\n\t    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {\n\t        if (interval <= 0) {\n\t            throw new Error('Tone.Transport: repeat events must have an interval larger than 0');\n\t        }\n\t        var event = {\n\t            'time': this.toTicks(startTime),\n\t            'duration': this.toTicks(this.defaultArg(duration, Infinity)),\n\t            'interval': this.toTicks(interval),\n\t            'callback': callback\n\t        };\n\t        var id = this._eventID++;\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._repeatedEvents\n\t        };\n\t        this._repeatedEvents.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Schedule an event that will be removed after it is invoked. \n\t\t *  Note that if the given time is less than the current transport time, \n\t\t *  the event will be invoked immediately. \n\t\t *  @param {Function} callback The callback to invoke once.\n\t\t *  @param {TransportTime} time The time the callback should be invoked.\n\t\t *  @returns {Number} The ID of the scheduled event. \n\t\t */\n\t    Tone.Transport.prototype.scheduleOnce = function (callback, time) {\n\t        var id = this._eventID++;\n\t        var event = {\n\t            'time': this.toTicks(time),\n\t            'callback': callback,\n\t            'id': id\n\t        };\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._onceEvents\n\t        };\n\t        this._onceEvents.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Clear the passed in event id from the timeline\n\t\t *  @param {Number} eventId The id of the event.\n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.clear = function (eventId) {\n\t        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t            var item = this._scheduledEvents[eventId.toString()];\n\t            item.timeline.remove(item.event);\n\t            delete this._scheduledEvents[eventId.toString()];\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove scheduled events from the timeline after\n\t\t *  the given time. Repeated events will be removed\n\t\t *  if their startTime is after the given time\n\t\t *  @param {TransportTime} [after=0] Clear all events after\n\t\t *                          this time. \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.cancel = function (after) {\n\t        after = this.defaultArg(after, 0);\n\t        after = this.toTicks(after);\n\t        this._timeline.cancel(after);\n\t        this._onceEvents.cancel(after);\n\t        this._repeatedEvents.cancel(after);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSTART/STOP/PAUSE\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Bind start/stop/pause events from the clock and emit them.\n\t\t */\n\t    Tone.Transport.prototype._bindClockEvents = function () {\n\t        this._clock.on('start', function (time, offset) {\n\t            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();\n\t            this.emit('start', time, offset);\n\t        }.bind(this));\n\t        this._clock.on('stop', function (time) {\n\t            this.emit('stop', time);\n\t        }.bind(this));\n\t        this._clock.on('pause', function (time) {\n\t            this.emit('pause', time);\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'state', {\n\t        get: function () {\n\t            return this._clock.getStateAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now] The time when the transport should start.\n\t\t *  @param  {TransportTime=} offset The timeline offset to start the transport.\n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * //start the transport in one second starting at beginning of the 5th measure. \n\t\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t\t */\n\t    Tone.Transport.prototype.start = function (time, offset) {\n\t        //start the clock\n\t        if (!this.isUndef(offset)) {\n\t            offset = this.toTicks(offset);\n\t        }\n\t        this._clock.start(time, offset);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now] The time when the transport should stop. \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * Tone.Transport.stop();\n\t\t */\n\t    Tone.Transport.prototype.stop = function (time) {\n\t        this._clock.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Pause the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now]\n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.pause = function (time) {\n\t        this._clock.pause(time);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSETTERS/GETTERS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The time signature as just the numerator over 4. \n\t\t *  For example 4/4 would be just 4 and 6/8 would be 3.\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Number|Array}\n\t\t *  @name timeSignature\n\t\t *  @example\n\t\t * //common time\n\t\t * Tone.Transport.timeSignature = 4;\n\t\t * // 7/8\n\t\t * Tone.Transport.timeSignature = [7, 8];\n\t\t * //this will be reduced to a single number\n\t\t * Tone.Transport.timeSignature; //returns 3.5\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {\n\t        get: function () {\n\t            return this._timeSignature;\n\t        },\n\t        set: function (timeSig) {\n\t            if (this.isArray(timeSig)) {\n\t                timeSig = timeSig[0] / timeSig[1] * 4;\n\t            }\n\t            this._timeSignature = timeSig;\n\t        }\n\t    });\n\t    /**\n\t\t * When the Tone.Transport.loop = true, this is the starting position of the loop.\n\t\t * @memberOf Tone.Transport#\n\t\t * @type {TransportTime}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toSeconds();\n\t        },\n\t        set: function (startPosition) {\n\t            this._loopStart = this.toTicks(startPosition);\n\t        }\n\t    });\n\t    /**\n\t\t * When the Tone.Transport.loop = true, this is the ending position of the loop.\n\t\t * @memberOf Tone.Transport#\n\t\t * @type {TransportTime}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();\n\t        },\n\t        set: function (endPosition) {\n\t            this._loopEnd = this.toTicks(endPosition);\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the loop start and stop at the same time. \n\t\t *  @param {TransportTime} startPosition \n\t\t *  @param {TransportTime} endPosition   \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * //loop over the first measure\n\t\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t\t * Tone.Transport.loop = true;\n\t\t */\n\t    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {\n\t        this.loopStart = startPosition;\n\t        this.loopEnd = endPosition;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The swing value. Between 0-1 where 1 equal to \n\t\t *  the note + half the subdivision.\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {NormalRange}\n\t\t *  @name swing\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'swing', {\n\t        get: function () {\n\t            return this._swingAmount;\n\t        },\n\t        set: function (amount) {\n\t            //scale the values to a normal range\n\t            this._swingAmount = amount;\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the subdivision which the swing will be applied to. \n\t\t *  The default value is an 8th note. Value must be less \n\t\t *  than a quarter note.\n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Time}\n\t\t *  @name swingSubdivision\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {\n\t        get: function () {\n\t            return Tone.Time(this._swingTicks, 'i').toNotation();\n\t        },\n\t        set: function (subdivision) {\n\t            this._swingTicks = this.toTicks(subdivision);\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t\t *  Setting the value will jump to that position right away. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {BarsBeatsSixteenths}\n\t\t *  @name position\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'position', {\n\t        get: function () {\n\t            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();\n\t        },\n\t        set: function (progress) {\n\t            var ticks = this.toTicks(progress);\n\t            this.ticks = ticks;\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's position in seconds\n\t\t *  Setting the value will jump to that position right away. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Seconds}\n\t\t *  @name seconds\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'seconds', {\n\t        get: function () {\n\t            return Tone.TransportTime(this.ticks, 'i').toSeconds();\n\t        },\n\t        set: function (progress) {\n\t            var ticks = this.toTicks(progress);\n\t            this.ticks = ticks;\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's loop position as a normalized value. Always\n\t\t *  returns 0 if the transport if loop is not true. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @name progress\n\t\t *  @type {NormalRange}\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'progress', {\n\t        get: function () {\n\t            if (this.loop) {\n\t                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The transports current tick position.\n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Ticks}\n\t\t *  @name ticks\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'ticks', {\n\t        get: function () {\n\t            return this._clock.ticks;\n\t        },\n\t        set: function (t) {\n\t            if (this._clock.ticks !== t) {\n\t                var now = this.now();\n\t                //stop everything synced to the transport\n\t                if (this.state === Tone.State.Started) {\n\t                    this.emit('stop', now);\n\t                    this._clock.ticks = t;\n\t                    //restart it with the new time\n\t                    this.emit('start', now, this.seconds);\n\t                } else {\n\t                    this._clock.ticks = t;\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Pulses Per Quarter note. This is the smallest resolution\n\t\t *  the Transport timing supports. This should be set once\n\t\t *  on initialization and not set again. Changing this value \n\t\t *  after other objects have been created can cause problems. \n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Number}\n\t\t *  @name PPQ\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {\n\t        get: function () {\n\t            return this._ppq;\n\t        },\n\t        set: function (ppq) {\n\t            var bpm = this.bpm.value;\n\t            this._ppq = ppq;\n\t            this.bpm.value = bpm;\n\t        }\n\t    });\n\t    /**\n\t\t *  The hint to the type of playback. Affects tradeoffs between audio \n\t\t *  output latency and responsiveness. \n\t\t *  \n\t\t *  In addition to setting the value in seconds, the latencyHint also\n\t\t *  accepts the strings \"interactive\" (prioritizes low latency), \n\t\t *  \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t\t *  latency and performance), and \"fastest\" (lowest latency, might glitch more often). \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Seconds|String}\n\t\t *  @name latencyHint\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'latencyHint', {\n\t        get: function () {\n\t            return Tone.Clock.latencyHint;\n\t        },\n\t        set: function (hint) {\n\t            Tone.Clock.latencyHint = hint;\n\t        }\n\t    });\n\t    /**\n\t\t *  Convert from BPM to frequency (factoring in PPQ)\n\t\t *  @param  {BPM}  bpm The BPM value to convert to frequency\n\t\t *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._fromUnits = function (bpm) {\n\t        return 1 / (60 / bpm / this.PPQ);\n\t    };\n\t    /**\n\t\t *  Convert from frequency (with PPQ) into BPM\n\t\t *  @param  {Frequency}  freq The clocks frequency to convert to BPM\n\t\t *  @return  {BPM}  The frequency value as BPM.\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._toUnits = function (freq) {\n\t        return freq / this.PPQ * 60;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSYNCING\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the time aligned to the next subdivision\n\t\t *  of the Transport. If the Transport is not started,\n\t\t *  it will return 0.\n\t\t *  Note: this will not work precisely during tempo ramps.\n\t\t *  @param  {Time}  subdivision  The subdivision to quantize to\n\t\t *  @return  {Number}  The context time of the next subdivision.\n\t\t *  @example\n\t\t * Tone.Transport.start(); //the transport must be started\n\t\t * Tone.Transport.nextSubdivision(\"4n\");\n\t\t */\n\t    Tone.Transport.prototype.nextSubdivision = function (subdivision) {\n\t        subdivision = this.toSeconds(subdivision);\n\t        //if the transport's not started, return 0\n\t        var now;\n\t        if (this.state === Tone.State.Started) {\n\t            now = this._clock._nextTick;\n\t        } else {\n\t            return 0;\n\t        }\n\t        var transportPos = Tone.Time(this.ticks, 'i');\n\t        var remainingTime = subdivision - transportPos % subdivision;\n\t        if (remainingTime === 0) {\n\t            remainingTime = subdivision;\n\t        }\n\t        return now + remainingTime;\n\t    };\n\t    /**\n\t\t *  Attaches the signal to the tempo control signal so that \n\t\t *  any changes in the tempo will change the signal in the same\n\t\t *  ratio. \n\t\t *  \n\t\t *  @param  {Tone.Signal} signal \n\t\t *  @param {number=} ratio Optionally pass in the ratio between\n\t\t *                         the two signals. Otherwise it will be computed\n\t\t *                         based on their current values. \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.syncSignal = function (signal, ratio) {\n\t        if (!ratio) {\n\t            //get the sync ratio\n\t            if (signal._param.value !== 0) {\n\t                ratio = signal._param.value / this.bpm._param.value;\n\t            } else {\n\t                ratio = 0;\n\t            }\n\t        }\n\t        var ratioSignal = new Tone.Gain(ratio);\n\t        this.bpm.chain(ratioSignal, signal._param);\n\t        this._syncedSignals.push({\n\t            'ratio': ratioSignal,\n\t            'signal': signal,\n\t            'initial': signal._param.value\n\t        });\n\t        signal._param.value = 0;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsyncs a previously synced signal from the transport's control. \n\t\t *  See Tone.Transport.syncSignal.\n\t\t *  @param  {Tone.Signal} signal \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.unsyncSignal = function (signal) {\n\t        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t            var syncedSignal = this._syncedSignals[i];\n\t            if (syncedSignal.signal === signal) {\n\t                syncedSignal.ratio.dispose();\n\t                syncedSignal.signal._param.value = syncedSignal.initial;\n\t                this._syncedSignals.splice(i, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this._clock.dispose();\n\t        this._clock = null;\n\t        this._writable('bpm');\n\t        this.bpm = null;\n\t        this._timeline.dispose();\n\t        this._timeline = null;\n\t        this._onceEvents.dispose();\n\t        this._onceEvents = null;\n\t        this._repeatedEvents.dispose();\n\t        this._repeatedEvents = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tINITIALIZATION\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    var TransportConstructor = Tone.Transport;\n\t    Tone.Transport = new TransportConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Transport instanceof TransportConstructor) {\n\t            Tone.Transport = context.Transport;\n\t        } else {\n\t            Tone.Transport = new TransportConstructor();\n\t            //store the Transport on the context so it can be retrieved later\n\t            context.Transport = Tone.Transport;\n\t        }\n\t    });\n\t    return Tone.Transport;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Volume is a simple volume node, useful for creating a volume fader. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Decibels} [volume=0] the initial volume\n\t\t *  @example\n\t\t * var vol = new Tone.Volume(-12);\n\t\t * instrument.chain(vol, Tone.Master);\n\t\t */\n\t    Tone.Volume = function () {\n\t        var options = this.optionsObject(arguments, ['volume'], Tone.Volume.defaults);\n\t        /**\n\t\t\t * the output node\n\t\t\t * @type {GainNode}\n\t\t\t * @private\n\t\t\t */\n\t        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The unmuted volume\n\t\t\t * @type {Decibels}\n\t\t\t * @private\n\t\t\t */\n\t        this._unmutedVolume = options.volume;\n\t        /**\n\t\t\t *  The volume control in decibels. \n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.volume = this.output.gain;\n\t        this._readOnly('volume');\n\t        //set the mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.Volume);\n\t    /**\n\t\t *  Defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Volume.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Volume#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * volume.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Volume.prototype, 'mute', {\n\t        get: function () {\n\t            return this.volume.value === -Infinity;\n\t        },\n\t        set: function (mute) {\n\t            if (!this.mute && mute) {\n\t                this._unmutedVolume = this.volume.value;\n\t                //maybe it should ramp here?\n\t                this.volume.value = -Infinity;\n\t            } else if (this.mute && !mute) {\n\t                this.volume.value = this._unmutedVolume;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Volume} this\n\t\t */\n\t    Tone.Volume.prototype.dispose = function () {\n\t        this.input.dispose();\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('volume');\n\t        this.volume.dispose();\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.Volume;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A single master output which is connected to the\n\t\t *          AudioDestinationNode (aka your speakers). \n\t\t *          It provides useful conveniences such as the ability \n\t\t *          to set the volume and mute the entire application. \n\t\t *          It also gives you the ability to apply master effects to your application. \n\t\t *          <br><br>\n\t\t *          Like Tone.Transport, A single Tone.Master is created\n\t\t *          on initialization and you do not need to explicitly construct one.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @singleton\n\t\t *  @example\n\t\t * //the audio will go from the oscillator to the speakers\n\t\t * oscillator.connect(Tone.Master);\n\t\t * //a convenience for connecting to the master output is also provided:\n\t\t * oscillator.toMaster();\n\t\t * //the above two examples are equivalent.\n\t\t */\n\t    Tone.Master = function () {\n\t        this.createInsOuts(1, 1);\n\t        /**\n\t\t\t *  The private volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume();\n\t        /**\n\t\t\t * The volume of the master output.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        //connections\n\t        this.input.chain(this.output, this.context.destination);\n\t    };\n\t    Tone.extend(Tone.Master);\n\t    /**\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Master.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Master#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * Tone.Master.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Master.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously \n\t\t *  chained in the master effects chain. \n\t\t *  @param {AudioNode|Tone...} args All arguments will be connected in a row\n\t\t *                                  and the Master will be routed through it.\n\t\t *  @return  {Tone.Master}  this\n\t\t *  @example\n\t\t * //some overall compression to keep the levels in check\n\t\t * var masterCompressor = new Tone.Compressor({\n\t\t * \t\"threshold\" : -6,\n\t\t * \t\"ratio\" : 3,\n\t\t * \t\"attack\" : 0.5,\n\t\t * \t\"release\" : 0.1\n\t\t * });\n\t\t * //give a little boost to the lows\n\t\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t\t * //route everything through the filter \n\t\t * //and compressor before going to the speakers\n\t\t * Tone.Master.chain(lowBump, masterCompressor);\n\t\t */\n\t    Tone.Master.prototype.chain = function () {\n\t        this.input.disconnect();\n\t        this.input.chain.apply(this.input, arguments);\n\t        arguments[arguments.length - 1].connect(this.output);\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Master}  this\n\t\t */\n\t    Tone.Master.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUGMENT TONE's PROTOTYPE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)\n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * //connect an oscillator to the master output\n\t\t * var osc = new Tone.Oscillator().toMaster();\n\t\t */\n\t    Tone.prototype.toMaster = function () {\n\t        this.connect(Tone.Master);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Also augment AudioNode's prototype to include toMaster\n\t\t *  as a convenience\n\t\t *  @returns {AudioNode} this\n\t\t */\n\t    AudioNode.prototype.toMaster = function () {\n\t        this.connect(Tone.Master);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  initialize the module and listen for new audio contexts\n\t\t */\n\t    var MasterConstructor = Tone.Master;\n\t    Tone.Master = new MasterConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        // if it already exists, just restore it\n\t        if (context.Master instanceof MasterConstructor) {\n\t            Tone.Master = context.Master;\n\t        } else {\n\t            Tone.Master = new MasterConstructor();\n\t        }\n\t        context.Master = Tone.Master;\n\t    });\n\t    return Tone.Master;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base class for sources. Sources have start/stop methods\n\t\t *          and the ability to be synced to the \n\t\t *          start/stop of Tone.Transport. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * //Multiple state change events can be chained together,\n\t\t * //but must be set in the correct order and with ascending times\n\t\t * \n\t\t * // OK\n\t\t * state.start().stop(\"+0.2\");\n\t\t * // AND\n\t\t * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n\t\t *\n\t\t * // BAD\n\t\t * state.stop(\"+0.2\").start();\n\t\t * // OR\n\t\t * state.start(\"+0.3\").stop(\"+0.2\");\n\t\t * \n\t\t */\n\t    Tone.Source = function (options) {\n\t        // this.createInsOuts(0, 1);\n\t        options = this.defaultArg(options, Tone.Source.defaults);\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        /**\n\t\t\t * \tKeep track of the scheduled state.\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        this._state.memory = 10;\n\t        /**\n\t\t\t *  The synced `start` callback function from the transport\n\t\t\t *  @type {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._synced = false;\n\t        /**\n\t\t\t *  Keep track of all of the scheduled event ids\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scheduled = [];\n\t        //make the output explicitly stereo\n\t        this._volume.output.output.channelCount = 2;\n\t        this._volume.output.output.channelCountMode = 'explicit';\n\t        //mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.Source);\n\t    /**\n\t\t *  The default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Source.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Source#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Source.prototype, 'state', {\n\t        get: function () {\n\t            if (this._synced) {\n\t                if (Tone.Transport.state === Tone.State.Started) {\n\t                    return this._state.getValueAtTime(Tone.Transport.seconds);\n\t                } else {\n\t                    return Tone.State.Stopped;\n\t                }\n\t            } else {\n\t                return this._state.getValueAtTime(this.now());\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Source#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * source.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Source.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    //overwrite these functions\n\t    Tone.Source.prototype._start = Tone.noOp;\n\t    Tone.Source.prototype._stop = Tone.noOp;\n\t    /**\n\t\t *  Start the source at the specified time. If no time is given, \n\t\t *  start the source now.\n\t\t *  @param  {Time} [time=now] When the source should be started.\n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t\t */\n\t    Tone.Source.prototype.start = function (time, offset, duration) {\n\t        if (this.isUndef(time) && this._synced) {\n\t            time = Tone.Transport.seconds;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        //if it's started, stop it and restart it\n\t        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this.stop(time);\n\t        }\n\t        this._state.setStateAtTime(Tone.State.Started, time);\n\t        if (this._synced) {\n\t            // add the offset time to the event\n\t            var event = this._state.get(time);\n\t            event.offset = this.defaultArg(offset, 0);\n\t            event.duration = duration;\n\t            var sched = Tone.Transport.schedule(function (t) {\n\t                this._start(t, offset, duration);\n\t            }.bind(this), time);\n\t            this._scheduled.push(sched);\n\t        } else {\n\t            this._start.apply(this, arguments);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the source at the specified time. If no time is given, \n\t\t *  stop the source now.\n\t\t *  @param  {Time} [time=now] When the source should be stopped. \n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * source.stop(); // stops the source immediately\n\t\t */\n\t    Tone.Source.prototype.stop = function (time) {\n\t        if (this.isUndef(time) && this._synced) {\n\t            time = Tone.Transport.seconds;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._state.cancel(time);\n\t        this._state.setStateAtTime(Tone.State.Stopped, time);\n\t        if (!this._synced) {\n\t            this._stop.apply(this, arguments);\n\t        } else {\n\t            var sched = Tone.Transport.schedule(this._stop.bind(this), time);\n\t            this._scheduled.push(sched);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the source to the Transport so that all subsequent\n\t\t *  calls to `start` and `stop` are synced to the TransportTime\n\t\t *  instead of the AudioContext time. \n\t\t *\n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t\t * source.sync().start(0).stop(0.3);\n\t\t * //start the transport.\n\t\t * Tone.Transport.start();\n\t\t *\n\t\t *  @example\n\t\t * //start the transport with an offset and the sync'ed sources\n\t\t * //will start in the correct position\n\t\t * source.sync().start(0.1);\n\t\t * //the source will be invoked with an offset of 0.4\n\t\t * Tone.Transport.start(\"+0.5\", 0.5);\n\t\t */\n\t    Tone.Source.prototype.sync = function () {\n\t        this._synced = true;\n\t        Tone.Transport.on('start loopStart', function (time, offset) {\n\t            if (offset > 0) {\n\t                // get the playback state at that time\n\t                var stateEvent = this._state.get(offset);\n\t                // listen for start events which may occur in the middle of the sync'ed time\n\t                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {\n\t                    // get the offset\n\t                    var startOffset = offset - this.toSeconds(stateEvent.time);\n\t                    var duration;\n\t                    if (stateEvent.duration) {\n\t                        duration = this.toSeconds(stateEvent.duration) - startOffset;\n\t                    }\n\t                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t                }\n\t            }\n\t        }.bind(this));\n\t        Tone.Transport.on('stop pause loopEnd', function (time) {\n\t            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {\n\t                this._stop(time);\n\t            }\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsync the source to the Transport. See Tone.Source.sync\n\t\t *  @returns {Tone.Source} this\n\t\t */\n\t    Tone.Source.prototype.unsync = function () {\n\t        this._synced = false;\n\t        Tone.Transport.off('start stop pause loopEnd loopStart');\n\t        // clear all of the scheduled ids\n\t        for (var i = 0; i < this._scheduled.length; i++) {\n\t            var id = this._scheduled[i];\n\t            Tone.Transport.clear(id);\n\t        }\n\t        this._scheduled = [];\n\t        this._state.cancel(0);\n\t        return this;\n\t    };\n\t    /**\n\t\t *\tClean up.\n\t\t *  @return {Tone.Source} this\n\t\t */\n\t    Tone.Source.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.unsync();\n\t        this._scheduled = null;\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        this._state.dispose();\n\t        this._state = null;\n\t    };\n\t    return Tone.Source;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  OscillatorNode shim\n\t\t *  @private\n\t\t */\n\t    if (window.OscillatorNode && !OscillatorNode.prototype.start) {\n\t        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;\n\t        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;\n\t        if (!OscillatorNode.prototype.setPeriodicWave) {\n\t            OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;\n\t        }\n\t        if (!AudioContext.prototype.createPeriodicWave) {\n\t            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;\n\t        }\n\t    }\n\t    /**\n\t\t *  @class Tone.Oscillator supports a number of features including\n\t\t *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), \n\t\t *         and Transport syncing (see Tone.Oscillator.syncFrequency).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Source}\n\t\t *  @param {Frequency} [frequency] Starting frequency\n\t\t *  @param {string} [type] The oscillator type. Read more about type below.\n\t\t *  @example\n\t\t * //make and start a 440hz sine tone\n\t\t * var osc = new Tone.Oscillator(440, \"sine\").toMaster().start();\n\t\t */\n\t    Tone.Oscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type'\n\t        ], Tone.Oscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  the main oscillator\n\t\t\t *  @type {OscillatorNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = null;\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  the periodic wave\n\t\t\t *  @type {PeriodicWave}\n\t\t\t *  @private\n\t\t\t */\n\t        this._wave = null;\n\t        /**\n\t\t\t *  The partials of the oscillator\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._partials = this.defaultArg(options.partials, [1]);\n\t        /**\n\t\t\t *  the phase of the oscillator\n\t\t\t *  between 0 - 360\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._phase = options.phase;\n\t        /**\n\t\t\t *  the type of the oscillator\n\t\t\t *  @type {string}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = null;\n\t        //setup\n\t        this.type = options.type;\n\t        this.phase = this._phase;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Oscillator, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Oscillator.defaults = {\n\t        'type': 'sine',\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'partials': []\n\t    };\n\t    /**\n\t\t *  The Oscillator types\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Oscillator.Type = {\n\t        Sine: 'sine',\n\t        Triangle: 'triangle',\n\t        Sawtooth: 'sawtooth',\n\t        Square: 'square',\n\t        Custom: 'custom'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now] \n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._start = function (time) {\n\t        //new oscillator with previous values\n\t        this._oscillator = this.context.createOscillator();\n\t        this._oscillator.setPeriodicWave(this._wave);\n\t        //connect the control signal to the oscillator frequency & detune\n\t        this._oscillator.connect(this.output);\n\t        this.frequency.connect(this._oscillator.frequency);\n\t        this.detune.connect(this._oscillator.detune);\n\t        //start the oscillator\n\t        this._oscillator.start(this.toSeconds(time));\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @private\n\t\t *  @param  {Time} [time=now] (optional) timing parameter\n\t\t *  @returns {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype._stop = function (time) {\n\t        if (this._oscillator) {\n\t            this._oscillator.stop(this.toSeconds(time));\n\t            this._oscillator = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t\t *  will also affect the oscillators frequency. \n\t\t *  @returns {Tone.Oscillator} this\n\t\t *  @example\n\t\t * Tone.Transport.bpm.value = 120;\n\t\t * osc.frequency.value = 440;\n\t\t * //the ration between the bpm and the frequency will be maintained\n\t\t * osc.syncFrequency();\n\t\t * Tone.Transport.bpm.value = 240; \n\t\t * // the frequency of the oscillator is doubled to 880\n\t\t */\n\t    Tone.Oscillator.prototype.syncFrequency = function () {\n\t        Tone.Transport.syncSignal(this.frequency);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsync the oscillator's frequency from the Transport. \n\t\t *  See Tone.Oscillator.syncFrequency\n\t\t *  @returns {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype.unsyncFrequency = function () {\n\t        Tone.Transport.unsyncSignal(this.frequency);\n\t        return this;\n\t    };\n\t    /**\n\t\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t\t * 8 partials of the triangle wave.\n\t\t * <br><br> \n\t\t * Uses PeriodicWave internally even for native types so that it can set the phase. \n\t\t * PeriodicWave equations are from the \n\t\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t\t *  \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t * @example\n\t\t * //set it to a square wave\n\t\t * osc.type = \"square\";\n\t\t * @example\n\t\t * //set the first 6 partials of a sawtooth wave\n\t\t * osc.type = \"sawtooth6\";\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            var coefs = this._getRealImaginary(type, this._phase);\n\t            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);\n\t            this._wave = periodicWave;\n\t            if (this._oscillator !== null) {\n\t                this._oscillator.setPeriodicWave(this._wave);\n\t            }\n\t            this._type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Returns the real and imaginary components based \n\t\t *  on the oscillator type.\n\t\t *  @returns {Array} [real, imaginary]\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {\n\t        var fftSize = 4096;\n\t        var periodicWaveSize = fftSize / 2;\n\t        var real = new Float32Array(periodicWaveSize);\n\t        var imag = new Float32Array(periodicWaveSize);\n\t        var partialCount = 1;\n\t        if (type === Tone.Oscillator.Type.Custom) {\n\t            partialCount = this._partials.length + 1;\n\t            periodicWaveSize = partialCount;\n\t        } else {\n\t            var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t            if (partial) {\n\t                partialCount = parseInt(partial[2]) + 1;\n\t                type = partial[1];\n\t                partialCount = Math.max(partialCount, 2);\n\t                periodicWaveSize = partialCount;\n\t            }\n\t        }\n\t        for (var n = 1; n < periodicWaveSize; ++n) {\n\t            var piFactor = 2 / (n * Math.PI);\n\t            var b;\n\t            switch (type) {\n\t            case Tone.Oscillator.Type.Sine:\n\t                b = n <= partialCount ? 1 : 0;\n\t                break;\n\t            case Tone.Oscillator.Type.Square:\n\t                b = n & 1 ? 2 * piFactor : 0;\n\t                break;\n\t            case Tone.Oscillator.Type.Sawtooth:\n\t                b = piFactor * (n & 1 ? 1 : -1);\n\t                break;\n\t            case Tone.Oscillator.Type.Triangle:\n\t                if (n & 1) {\n\t                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n\t                } else {\n\t                    b = 0;\n\t                }\n\t                break;\n\t            case Tone.Oscillator.Type.Custom:\n\t                b = this._partials[n - 1];\n\t                break;\n\t            default:\n\t                throw new TypeError('Tone.Oscillator: invalid type: ' + type);\n\t            }\n\t            if (b !== 0) {\n\t                real[n] = -b * Math.sin(phase * n);\n\t                imag[n] = b * Math.cos(phase * n);\n\t            } else {\n\t                real[n] = 0;\n\t                imag[n] = 0;\n\t            }\n\t        }\n\t        return [\n\t            real,\n\t            imag\n\t        ];\n\t    };\n\t    /**\n\t\t *  Compute the inverse FFT for a given phase.\t\n\t\t *  @param  {Float32Array}  real\n\t\t *  @param  {Float32Array}  imag \n\t\t *  @param  {NormalRange}  phase \n\t\t *  @return  {AudioRange}\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {\n\t        var sum = 0;\n\t        var len = real.length;\n\t        for (var i = 0; i < len; i++) {\n\t            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t\t *  Returns the initial value of the oscillator.\n\t\t *  @return  {AudioRange}\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._getInitialValue = function () {\n\t        var coefs = this._getRealImaginary(this._type, 0);\n\t        var real = coefs[0];\n\t        var imag = coefs[1];\n\t        var maxValue = 0;\n\t        var twoPi = Math.PI * 2;\n\t        //check for peaks in 8 places\n\t        for (var i = 0; i < 8; i++) {\n\t            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);\n\t        }\n\t        return -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t    };\n\t    /**\n\t\t * The partials of the waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {\n\t        get: function () {\n\t            if (this._type !== Tone.Oscillator.Type.Custom) {\n\t                return [];\n\t            } else {\n\t                return this._partials;\n\t            }\n\t        },\n\t        set: function (partials) {\n\t            this._partials = partials;\n\t            this.type = Tone.Oscillator.Type.Custom;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees. \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t * @example\n\t\t * osc.phase = 180; //flips the phase of the oscillator\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._phase * (180 / Math.PI);\n\t        },\n\t        set: function (phase) {\n\t            this._phase = phase * Math.PI / 180;\n\t            //reset the type\n\t            this.type = this._type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Dispose and disconnect.\n\t\t *  @return {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._oscillator !== null) {\n\t            this._oscillator.disconnect();\n\t            this._oscillator = null;\n\t        }\n\t        this._wave = null;\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this._partials = null;\n\t        return this;\n\t    };\n\t    return Tone.Oscillator;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be\n\t\t *         it's own class is that many browsers optimize out Tone.Signal\n\t\t *         with a value of 0 and will not process nodes further down the graph. \n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Zero = function () {\n\t        /**\n\t\t\t *  The gain node\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gain = this.input = this.output = new Tone.Gain();\n\t        this.context.getConstant(0).connect(this._gain);\n\t    };\n\t    Tone.extend(Tone.Zero);\n\t    /**\n\t\t *  clean up\n\t\t *  @return  {Tone.Zero}  this\n\t\t */\n\t    Tone.Zero.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._gain.dispose();\n\t        this._gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Zero;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal \n\t\t *          which can be attached to an AudioParam or Tone.Signal \n\t\t *          in order to modulate that parameter with an oscillator. The LFO can \n\t\t *          also be synced to the transport to start/stop and change when the tempo changes.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be\n\t\t *                               in the frequency range of 0.1 to 10 hertz. \n\t\t *  @param {number=} min The minimum output value of the LFO. \n\t\t *  @param {number=} max The maximum value of the LFO. \n\t\t *  @example\n\t\t * var lfo = new Tone.LFO(\"4n\", 400, 4000);\n\t\t * lfo.connect(filter.frequency);\n\t\t */\n\t    Tone.LFO = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'min',\n\t            'max'\n\t        ], Tone.LFO.defaults);\n\t        /** \n\t\t\t *  The oscillator. \n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = new Tone.Oscillator({\n\t            'frequency': options.frequency,\n\t            'type': options.type\n\t        });\n\t        /**\n\t\t\t *  the lfo's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._oscillator.frequency;\n\t        /**\n\t\t\t * The amplitude of the LFO, which controls the output range between\n\t\t\t * the min and max output. For example if the min is -10 and the max \n\t\t\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t\t\t * between -5 and 5. \n\t\t\t * @type {Number}\n\t\t\t * @signal\n\t\t\t */\n\t        this.amplitude = this._oscillator.volume;\n\t        this.amplitude.units = Tone.Type.NormalRange;\n\t        this.amplitude.value = options.amplitude;\n\t        /**\n\t\t\t *  The signal which is output when the LFO is stopped\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);\n\t        /**\n\t\t\t *  Just outputs zeros.\n\t\t\t *  @type {Tone.Zero}\n\t\t\t *  @private\n\t\t\t */\n\t        this._zeros = new Tone.Zero();\n\t        /**\n\t\t\t *  The value that the LFO outputs when it's stopped\n\t\t\t *  @type {AudioRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stoppedValue = 0;\n\t        /**\n\t\t\t *  @type {Tone.AudioToGain} \n\t\t\t *  @private\n\t\t\t */\n\t        this._a2g = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  @type {Tone.Scale} \n\t\t\t *  @private\n\t\t\t */\n\t        this._scaler = this.output = new Tone.Scale(options.min, options.max);\n\t        /**\n\t\t\t *  the units of the LFO (used for converting)\n\t\t\t *  @type {Tone.Type} \n\t\t\t *  @private\n\t\t\t */\n\t        this._units = Tone.Type.Default;\n\t        this.units = options.units;\n\t        //connect it up\n\t        this._oscillator.chain(this._a2g, this._scaler);\n\t        this._zeros.connect(this._a2g);\n\t        this._stoppedSignal.connect(this._a2g);\n\t        this._readOnly([\n\t            'amplitude',\n\t            'frequency'\n\t        ]);\n\t        this.phase = options.phase;\n\t    };\n\t    Tone.extend(Tone.LFO, Tone.Oscillator);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.LFO.defaults = {\n\t        'type': 'sine',\n\t        'min': 0,\n\t        'max': 1,\n\t        'phase': 0,\n\t        'frequency': '4n',\n\t        'amplitude': 1,\n\t        'units': Tone.Type.Default\n\t    };\n\t    /**\n\t\t *  Start the LFO. \n\t\t *  @param  {Time} [time=now] the time the LFO will start\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._stoppedSignal.setValueAtTime(0, time);\n\t        this._oscillator.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the LFO. \n\t\t *  @param  {Time} [time=now] the time the LFO will stop\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t        this._oscillator.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the start/stop/pause to the transport \n\t\t *  and the frequency to the bpm of the transport\n\t\t *  @returns {Tone.LFO} this\n\t\t *  @example\n\t\t *  lfo.frequency.value = \"8n\";\n\t\t *  lfo.sync().start(0)\n\t\t *  //the rate of the LFO will always be an eighth note, \n\t\t *  //even as the tempo changes\n\t\t */\n\t    Tone.LFO.prototype.sync = function () {\n\t        this._oscillator.sync();\n\t        this._oscillator.syncFrequency();\n\t        return this;\n\t    };\n\t    /**\n\t\t *  unsync the LFO from transport control\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.unsync = function () {\n\t        this._oscillator.unsync();\n\t        this._oscillator.unsyncFrequency();\n\t        return this;\n\t    };\n\t    /**\n\t\t * The miniumum output of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'min', {\n\t        get: function () {\n\t            return this._toUnits(this._scaler.min);\n\t        },\n\t        set: function (min) {\n\t            min = this._fromUnits(min);\n\t            this._scaler.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'max', {\n\t        get: function () {\n\t            return this._toUnits(this._scaler.max);\n\t        },\n\t        set: function (max) {\n\t            max = this._fromUnits(max);\n\t            this._scaler.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the oscillator: sine, square, sawtooth, triangle. \n\t\t * @memberOf Tone.LFO#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'type', {\n\t        get: function () {\n\t            return this._oscillator.type;\n\t        },\n\t        set: function (type) {\n\t            this._oscillator.type = type;\n\t            this._stoppedValue = this._oscillator._getInitialValue();\n\t            this._stoppedSignal.value = this._stoppedValue;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'phase', {\n\t        get: function () {\n\t            return this._oscillator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._oscillator.phase = phase;\n\t            this._stoppedValue = this._oscillator._getInitialValue();\n\t            this._stoppedSignal.value = this._stoppedValue;\n\t        }\n\t    });\n\t    /**\n\t\t * The output units of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {Tone.Type}\n\t\t * @name units\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'units', {\n\t        get: function () {\n\t            return this._units;\n\t        },\n\t        set: function (val) {\n\t            var currentMin = this.min;\n\t            var currentMax = this.max;\n\t            //convert the min and the max\n\t            this._units = val;\n\t            this.min = currentMin;\n\t            this.max = currentMax;\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.LFO#\n\t\t * @type {Boolean}\n\t\t * @name mute\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'mute', {\n\t        get: function () {\n\t            return this._oscillator.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._oscillator.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.LFO#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'state', {\n\t        get: function () {\n\t            return this._oscillator.state;\n\t        }\n\t    });\n\t    /**\n\t\t *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node. \n\t\t *  Tone.LFO will automatically convert to the destination units of the \n\t\t *  will get the units from the connected node.\n\t\t *  @param  {Tone | AudioParam | AudioNode} node \n\t\t *  @param {number} [outputNum=0] optionally which output to connect from\n\t\t *  @param {number} [inputNum=0] optionally which input to connect to\n\t\t *  @returns {Tone.LFO} this\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype.connect = function (node) {\n\t        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {\n\t            this.convert = node.convert;\n\t            this.units = node.units;\n\t        }\n\t        Tone.Signal.prototype.connect.apply(this, arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  private method borrowed from Param converts \n\t\t *  units from their destination value\n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;\n\t    /**\n\t\t *  private method borrowed from Param converts \n\t\t *  units to their destination value\n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;\n\t    /**\n\t\t *  disconnect and dispose\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'amplitude',\n\t            'frequency'\n\t        ]);\n\t        this._oscillator.dispose();\n\t        this._oscillator = null;\n\t        this._stoppedSignal.dispose();\n\t        this._stoppedSignal = null;\n\t        this._zeros.dispose();\n\t        this._zeros = null;\n\t        this._scaler.dispose();\n\t        this._scaler = null;\n\t        this._a2g.dispose();\n\t        this._a2g = null;\n\t        this.frequency = null;\n\t        this.amplitude = null;\n\t        return this;\n\t    };\n\t    return Tone.LFO;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Limiter will limit the loudness of an incoming signal. \n\t\t *         It is composed of a Tone.Compressor with a fast attack \n\t\t *         and release. Limiters are commonly used to safeguard against \n\t\t *         signal clipping. Unlike a compressor, limiters do not provide \n\t\t *         smooth gain reduction and almost completely prevent \n\t\t *         additional gain above the threshold.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {number} threshold The theshold above which the limiting is applied. \n\t\t *  @example\n\t\t *  var limiter = new Tone.Limiter(-6);\n\t\t */\n\t    Tone.Limiter = function () {\n\t        var options = this.optionsObject(arguments, ['threshold'], Tone.Limiter.defaults);\n\t        /**\n\t\t\t *  the compressor\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this._compressor = this.input = this.output = new Tone.Compressor({\n\t            'attack': 0.001,\n\t            'decay': 0.001,\n\t            'threshold': options.threshold\n\t        });\n\t        /**\n\t\t\t * The threshold of of the limiter\n\t\t\t * @type {Decibel}\n\t\t\t * @signal\n\t\t\t */\n\t        this.threshold = this._compressor.threshold;\n\t        this._readOnly('threshold');\n\t    };\n\t    Tone.extend(Tone.Limiter);\n\t    /**\n\t\t *  The default value\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Limiter.defaults = { 'threshold': -12 };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Limiter} this\n\t\t */\n\t    Tone.Limiter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._compressor.dispose();\n\t        this._compressor = null;\n\t        this._writable('threshold');\n\t        this.threshold = null;\n\t        return this;\n\t    };\n\t    return Tone.Limiter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to \n\t\t *         Tone.FeedbackCombFilter, but includes a lowpass filter.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [delayTime] The delay time of the comb filter\n\t\t *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter\n\t\t *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the\n\t\t *                                signal as it is fedback. \n\t\t */\n\t    Tone.LowpassCombFilter = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'resonance',\n\t            'dampening'\n\t        ], Tone.LowpassCombFilter.defaults);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = this.input = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The delayTime of the comb filter. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delay.delayTime;\n\t        /**\n\t\t\t *  the lowpass filter\n\t\t\t *  @type  {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowpass = this.output = this.context.createBiquadFilter();\n\t        this._lowpass.Q.value = -3.0102999566398125;\n\t        this._lowpass.type = 'lowpass';\n\t        /**\n\t\t\t *  The dampening control of the feedback\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = new Tone.Param({\n\t            'param': this._lowpass.frequency,\n\t            'units': Tone.Type.Frequency,\n\t            'value': options.dampening\n\t        });\n\t        /**\n\t\t\t *  the feedback gain\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of feedback of the delayed signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._feedback.gain;\n\t        //connections\n\t        this._delay.chain(this._lowpass, this._feedback, this._delay);\n\t        this._readOnly([\n\t            'dampening',\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.LowpassCombFilter);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.LowpassCombFilter.defaults = {\n\t        'delayTime': 0.1,\n\t        'resonance': 0.5,\n\t        'dampening': 3000\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.LowpassCombFilter} this\n\t\t */\n\t    Tone.LowpassCombFilter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'dampening',\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t        this.dampening.dispose();\n\t        this.dampening = null;\n\t        this.resonance.dispose();\n\t        this.resonance = null;\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this.delayTime = null;\n\t        this._lowpass.disconnect();\n\t        this._lowpass = null;\n\t        this._feedback.disconnect();\n\t        this._feedback = null;\n\t        return this;\n\t    };\n\t    return Tone.LowpassCombFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Merge brings two signals into the left and right \n\t\t *          channels of a single stereo channel.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var merge = new Tone.Merge().toMaster();\n\t\t * //routing a sine tone in the left channel\n\t\t * //and noise in the right channel\n\t\t * var osc = new Tone.Oscillator().connect(merge.left);\n\t\t * var noise = new Tone.Noise().connect(merge.right);\n\t\t * //starting our oscillators\n\t\t * noise.start();\n\t\t * osc.start();\n\t\t */\n\t    Tone.Merge = function () {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  The left input channel.\n\t\t\t *  Alias for <code>input[0]</code>\n\t\t\t *  @type {GainNode}\n\t\t\t */\n\t        this.left = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  The right input channel.\n\t\t\t *  Alias for <code>input[1]</code>.\n\t\t\t *  @type {GainNode}\n\t\t\t */\n\t        this.right = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t *  the merger node for the two channels\n\t\t\t *  @type {ChannelMergerNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merger = this.output = this.context.createChannelMerger(2);\n\t        //connections\n\t        this.left.connect(this._merger, 0, 0);\n\t        this.right.connect(this._merger, 0, 1);\n\t        this.left.channelCount = 1;\n\t        this.right.channelCount = 1;\n\t        this.left.channelCountMode = 'explicit';\n\t        this.right.channelCountMode = 'explicit';\n\t    };\n\t    Tone.extend(Tone.Merge);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Merge} this\n\t\t */\n\t    Tone.Merge.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.left.dispose();\n\t        this.left = null;\n\t        this.right.dispose();\n\t        this.right = null;\n\t        this._merger.disconnect();\n\t        this._merger = null;\n\t        return this;\n\t    };\n\t    return Tone.Merge;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n\t\t *          of an input signal with some averaging applied. It can also get the raw \n\t\t *          value of the input signal.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {String} type Either \"level\" or \"signal\". \n\t\t *  @param {Number} smoothing The amount of smoothing applied between frames.\n\t\t *  @example\n\t\t * var meter = new Tone.Meter();\n\t\t * var mic = new Tone.UserMedia().start();\n\t\t * //connect mic to the meter\n\t\t * mic.connect(meter);\n\t\t * //the current level of the mic input\n\t\t * var level = meter.value;\n\t\t */\n\t    Tone.Meter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'type',\n\t            'smoothing'\n\t        ], Tone.Meter.defaults);\n\t        /**\n\t\t\t *  The type of the meter, either \"level\" or \"signal\". \n\t\t\t *  A \"level\" meter will return the volume level (rms) of the \n\t\t\t *  input signal and a \"signal\" meter will return\n\t\t\t *  the signal value of the input. \n\t\t\t *  @type  {String}\n\t\t\t */\n\t        this.type = options.type;\n\t        /**\n\t\t\t *  The analyser node which computes the levels.\n\t\t\t *  @private\n\t\t\t *  @type  {Tone.Analyser}\n\t\t\t */\n\t        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 512);\n\t        this._analyser.returnType = 'float';\n\t        /**\n\t\t\t *  The amount of carryover between the current and last frame. \n\t\t\t *  Only applied meter for \"level\" type.\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this.smoothing = options.smoothing;\n\t        /**\n\t\t\t *  The last computed value\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lastValue = 0;\n\t    };\n\t    Tone.extend(Tone.Meter);\n\t    /**\n\t\t *  @private\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Meter.Type = {\n\t        Level: 'level',\n\t        Signal: 'signal'\n\t    };\n\t    /**\n\t\t *  The defaults\n\t\t *  @type {Object}\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Meter.defaults = {\n\t        'smoothing': 0.8,\n\t        'type': Tone.Meter.Type.Level\n\t    };\n\t    /**\n\t\t * The current value of the meter. A value of 1 is\n\t\t * \"unity\".\n\t\t * @memberOf Tone.Meter#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Meter.prototype, 'value', {\n\t        get: function () {\n\t            var signal = this._analyser.analyse();\n\t            if (this.type === Tone.Meter.Type.Level) {\n\t                //rms\n\t                var sum = 0;\n\t                for (var i = 0; i < signal.length; i++) {\n\t                    sum += Math.pow(signal[i], 2);\n\t                }\n\t                var rms = Math.sqrt(sum / signal.length);\n\t                //smooth it\n\t                rms = Math.max(rms, this._lastValue * this.smoothing);\n\t                this._lastValue = rms;\n\t                //scale it\n\t                var unity = 0.35;\n\t                var val = rms / unity;\n\t                //scale the output curve\n\t                return Math.sqrt(val);\n\t            } else {\n\t                return signal[0];\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Meter} this\n\t\t */\n\t    Tone.Meter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._analyser.dispose();\n\t        this._analyser = null;\n\t        return this;\n\t    };\n\t    return Tone.Meter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *\t@class  Tone.Split splits an incoming signal into left and right channels.\n\t\t *\t\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var split = new Tone.Split();\n\t\t * stereoSignal.connect(split);\n\t\t */\n\t    Tone.Split = function () {\n\t        this.createInsOuts(0, 2);\n\t        /** \n\t\t\t *  @type {ChannelSplitterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._splitter = this.input = this.context.createChannelSplitter(2);\n\t        /** \n\t\t\t *  Left channel output. \n\t\t\t *  Alias for <code>output[0]</code>\n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.left = this.output[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  Right channel output.\n\t\t\t *  Alias for <code>output[1]</code>\n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.right = this.output[1] = new Tone.Gain();\n\t        //connections\n\t        this._splitter.connect(this.left, 0, 0);\n\t        this._splitter.connect(this.right, 1, 0);\n\t    };\n\t    Tone.extend(Tone.Split);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Split} this\n\t\t */\n\t    Tone.Split.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._splitter.disconnect();\n\t        this.left.dispose();\n\t        this.left = null;\n\t        this.right.dispose();\n\t        this.right = null;\n\t        this._splitter = null;\n\t        return this;\n\t    };\n\t    return Tone.Split;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels). <br><br>\n\t\t *         <code>\n\t\t *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>\n\t\t *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideSplit = function () {\n\t        this.createInsOuts(0, 2);\n\t        /**\n\t\t\t *  split the incoming signal into left and right channels\n\t\t\t *  @type  {Tone.Split}\n\t\t\t *  @private\n\t\t\t */\n\t        this._split = this.input = new Tone.Split();\n\t        /**\n\t\t\t *  The mid send. Connect to mid processing. Alias for\n\t\t\t *  <code>output[0]</code>\n\t\t\t *  @type {Tone.Expr}\n\t\t\t */\n\t        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');\n\t        /**\n\t\t\t *  The side output. Connect to side processing. Alias for\n\t\t\t *  <code>output[1]</code>\n\t\t\t *  @type {Tone.Expr}\n\t\t\t */\n\t        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');\n\t        this._split.connect(this.mid, 0, 0);\n\t        this._split.connect(this.mid, 1, 1);\n\t        this._split.connect(this.side, 0, 0);\n\t        this._split.connect(this.side, 1, 1);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this.mid, 0, 2);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this.side, 0, 2);\n\t    };\n\t    Tone.extend(Tone.MidSideSplit);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MidSideSplit} this\n\t\t */\n\t    Tone.MidSideSplit.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._split.dispose();\n\t        this._split = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideSplit;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels). \n\t\t *         MidSideMerge merges the mid and side signal after they've been seperated\n\t\t *         by Tone.MidSideSplit.<br><br>\n\t\t *         <code>\n\t\t *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>\n\t\t *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone.StereoEffect}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideMerge = function () {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  The mid signal input. Alias for\n\t\t\t *  <code>input[0]</code>\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t */\n\t        this.mid = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  recombine the mid/side into Left\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._left = new Tone.Expr('($0 + $1) * $2');\n\t        /**\n\t\t\t *  The side signal input. Alias for\n\t\t\t *  <code>input[1]</code>\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t */\n\t        this.side = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t *  recombine the mid/side into Right\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._right = new Tone.Expr('($0 - $1) * $2');\n\t        /**\n\t\t\t *  Merge the left/right signal back into a stereo signal.\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = this.output = new Tone.Merge();\n\t        this.mid.connect(this._left, 0, 0);\n\t        this.side.connect(this._left, 0, 1);\n\t        this.mid.connect(this._right, 0, 0);\n\t        this.side.connect(this._right, 0, 1);\n\t        this._left.connect(this._merge, 0, 0);\n\t        this._right.connect(this._merge, 0, 1);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this._left, 0, 2);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this._right, 0, 2);\n\t    };\n\t    Tone.extend(Tone.MidSideMerge);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MidSideMerge} this\n\t\t */\n\t    Tone.MidSideMerge.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._left.dispose();\n\t        this._left = null;\n\t        this._right.dispose();\n\t        this._right = null;\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideMerge;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.MidSideCompressor applies two different compressors to the mid\n\t\t *         and side signal components. See Tone.MidSideSplit. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @param {Object} options The options that are passed to the mid and side\n\t\t *                          compressors. \n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideCompressor = function (options) {\n\t        options = this.defaultArg(options, Tone.MidSideCompressor.defaults);\n\t        /**\n\t\t\t *  the mid/side split\n\t\t\t *  @type  {Tone.MidSideSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideSplit = this.input = new Tone.MidSideSplit();\n\t        /**\n\t\t\t *  the mid/side recombination\n\t\t\t *  @type  {Tone.MidSideMerge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideMerge = this.output = new Tone.MidSideMerge();\n\t        /**\n\t\t\t *  The compressor applied to the mid signal\n\t\t\t *  @type  {Tone.Compressor}\n\t\t\t */\n\t        this.mid = new Tone.Compressor(options.mid);\n\t        /**\n\t\t\t *  The compressor applied to the side signal\n\t\t\t *  @type  {Tone.Compressor}\n\t\t\t */\n\t        this.side = new Tone.Compressor(options.side);\n\t        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\t        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\t        this._readOnly([\n\t            'mid',\n\t            'side'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MidSideCompressor);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MidSideCompressor.defaults = {\n\t        'mid': {\n\t            'ratio': 3,\n\t            'threshold': -24,\n\t            'release': 0.03,\n\t            'attack': 0.02,\n\t            'knee': 16\n\t        },\n\t        'side': {\n\t            'ratio': 6,\n\t            'threshold': -30,\n\t            'release': 0.25,\n\t            'attack': 0.03,\n\t            'knee': 10\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MidSideCompressor} this\n\t\t */\n\t    Tone.MidSideCompressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'mid',\n\t            'side'\n\t        ]);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._midSideSplit.dispose();\n\t        this._midSideSplit = null;\n\t        this._midSideMerge.dispose();\n\t        this._midSideMerge = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideCompressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal\n\t\t *         where both left and right channels have the same value. This can be useful \n\t\t *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t */\n\t    Tone.Mono = function () {\n\t        this.createInsOuts(1, 0);\n\t        /**\n\t\t\t *  merge the signal\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = this.output = new Tone.Merge();\n\t        this.input.connect(this._merge, 0, 0);\n\t        this.input.connect(this._merge, 0, 1);\n\t        this.input.gain.value = this.dbToGain(-10);\n\t    };\n\t    Tone.extend(Tone.Mono);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Mono} this\n\t\t */\n\t    Tone.Mono.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        return this;\n\t    };\n\t    return Tone.Mono;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A compressor with seperate controls over low/mid/high dynamics\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Object} options The low/mid/high compressor settings.\n\t\t *  @example\n\t\t *  var multiband = new Tone.MultibandCompressor({\n\t\t *  \t\"lowFrequency\" : 200,\n\t\t *  \t\"highFrequency\" : 1300\n\t\t *  \t\"low\" : {\n\t\t *  \t\t\"threshold\" : -12\n\t\t *  \t}\n\t\t *  })\n\t\t */\n\t    Tone.MultibandCompressor = function (options) {\n\t        options = this.defaultArg(arguments, Tone.MultibandCompressor.defaults);\n\t        /**\n\t\t\t *  split the incoming signal into high/mid/low\n\t\t\t *  @type {Tone.MultibandSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._splitter = this.input = new Tone.MultibandSplit({\n\t            'lowFrequency': options.lowFrequency,\n\t            'highFrequency': options.highFrequency\n\t        });\n\t        /**\n\t\t\t *  low/mid crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = this._splitter.lowFrequency;\n\t        /**\n\t\t\t *  mid/high crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = this._splitter.highFrequency;\n\t        /**\n\t\t\t *  the output\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  The compressor applied to the low frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.low = new Tone.Compressor(options.low);\n\t        /**\n\t\t\t *  The compressor applied to the mid frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.mid = new Tone.Compressor(options.mid);\n\t        /**\n\t\t\t *  The compressor applied to the high frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.high = new Tone.Compressor(options.high);\n\t        //connect the compressor\n\t        this._splitter.low.chain(this.low, this.output);\n\t        this._splitter.mid.chain(this.mid, this.output);\n\t        this._splitter.high.chain(this.high, this.output);\n\t        this._readOnly([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MultibandCompressor);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MultibandCompressor.defaults = {\n\t        'low': Tone.Compressor.defaults,\n\t        'mid': Tone.Compressor.defaults,\n\t        'high': Tone.Compressor.defaults,\n\t        'lowFrequency': 250,\n\t        'highFrequency': 2000\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MultibandCompressor} this\n\t\t */\n\t    Tone.MultibandCompressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._splitter.dispose();\n\t        this._writable([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t        this.low.dispose();\n\t        this.mid.dispose();\n\t        this.high.dispose();\n\t        this._splitter = null;\n\t        this.low = null;\n\t        this.mid = null;\n\t        this.high = null;\n\t        this.lowFrequency = null;\n\t        this.highFrequency = null;\n\t        return this;\n\t    };\n\t    return Tone.MultibandCompressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Panner is an equal power Left/Right Panner and does not\n\t\t *          support 3D. Panner uses the StereoPannerNode when available. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {NormalRange} [initialPan=0] The initail panner value (defaults to 0 = center)\n\t\t *  @example\n\t\t *  //pan the input signal hard right. \n\t\t *  var panner = new Tone.Panner(1);\n\t\t */\n\t    Tone.Panner = function (initialPan) {\n\t        if (this._hasStereoPanner) {\n\t            /**\n\t\t\t\t *  the panner node\n\t\t\t\t *  @type {StereoPannerNode}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._panner = this.input = this.output = this.context.createStereoPanner();\n\t            /**\n\t\t\t\t *  The pan control. -1 = hard left, 1 = hard right. \n\t\t\t\t *  @type {NormalRange}\n\t\t\t\t *  @signal\n\t\t\t\t */\n\t            this.pan = this._panner.pan;\n\t        } else {\n\t            /**\n\t\t\t\t *  the dry/wet knob\n\t\t\t\t *  @type {Tone.CrossFade}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._crossFade = new Tone.CrossFade();\n\t            /**\n\t\t\t\t *  @type {Tone.Merge}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._merger = this.output = new Tone.Merge();\n\t            /**\n\t\t\t\t *  @type {Tone.Split}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._splitter = this.input = new Tone.Split();\n\t            /**\n\t\t\t\t *  The pan control. -1 = hard left, 1 = hard right. \n\t\t\t\t *  @type {AudioRange}\n\t\t\t\t *  @signal\n\t\t\t\t */\n\t            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);\n\t            /**\n\t\t\t\t *  always sends 0\n\t\t\t\t *  @type {Tone.Zero}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._zero = new Tone.Zero();\n\t            /**\n\t\t\t\t *  The analog to gain conversion\n\t\t\t\t *  @type  {Tone.AudioToGain}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._a2g = new Tone.AudioToGain();\n\t            //CONNECTIONS:\n\t            this._zero.connect(this._a2g);\n\t            this.pan.chain(this._a2g, this._crossFade.fade);\n\t            //left channel is a, right channel is b\n\t            this._splitter.connect(this._crossFade, 0, 0);\n\t            this._splitter.connect(this._crossFade, 1, 1);\n\t            //merge it back together\n\t            this._crossFade.a.connect(this._merger, 0, 0);\n\t            this._crossFade.b.connect(this._merger, 0, 1);\n\t        }\n\t        //initial value\n\t        this.pan.value = this.defaultArg(initialPan, 0);\n\t        this._readOnly('pan');\n\t    };\n\t    Tone.extend(Tone.Panner);\n\t    /**\n\t\t *  indicates if the panner is using the new StereoPannerNode internally\n\t\t *  @type  {boolean}\n\t\t *  @private\n\t\t */\n\t    Tone.Panner.prototype._hasStereoPanner = Tone.prototype.isFunction(Tone.context.createStereoPanner);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Panner} this\n\t\t */\n\t    Tone.Panner.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('pan');\n\t        if (this._hasStereoPanner) {\n\t            this._panner.disconnect();\n\t            this._panner = null;\n\t            this.pan = null;\n\t        } else {\n\t            this._zero.dispose();\n\t            this._zero = null;\n\t            this._crossFade.dispose();\n\t            this._crossFade = null;\n\t            this._splitter.dispose();\n\t            this._splitter = null;\n\t            this._merger.dispose();\n\t            this._merger = null;\n\t            this.pan.dispose();\n\t            this.pan = null;\n\t            this._a2g.dispose();\n\t            this._a2g = null;\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Panner;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A spatialized panner node which supports equalpower or HRTF panning.\n\t\t *          Tries to normalize the API across various browsers. See Tone.Listener\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Number} positionX The initial x position.\n\t\t *  @param {Number} positionY The initial y position.\n\t\t *  @param {Number} positionZ The initial z position.\n\t\t */\n\t    Tone.Panner3D = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'positionX',\n\t            'positionY',\n\t            'positionZ'\n\t        ], Tone.Panner3D.defaults);\n\t        /**\n\t\t\t *  The panner node\n\t\t\t *  @type {PannerNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = this.input = this.output = this.context.createPanner();\n\t        //set some values\n\t        this._panner.panningModel = options.panningModel;\n\t        this._panner.maxDistance = options.maxDistance;\n\t        this._panner.distanceModel = options.distanceModel;\n\t        this._panner.coneOuterGain = options.coneOuterGain;\n\t        this._panner.coneOuterAngle = options.coneOuterAngle;\n\t        this._panner.coneInnerAngle = options.coneInnerAngle;\n\t        this._panner.refDistance = options.refDistance;\n\t        this._panner.rolloffFactor = options.rolloffFactor;\n\t        /**\n\t\t\t *  Holds the current orientation\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._orientation = [\n\t            options.orientationX,\n\t            options.orientationY,\n\t            options.orientationZ\n\t        ];\n\t        /**\n\t\t\t *  Holds the current position\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._position = [\n\t            options.positionX,\n\t            options.positionY,\n\t            options.positionZ\n\t        ];\n\t        // set the default position/orientation\n\t        this.orientationX = options.orientationX;\n\t        this.orientationY = options.orientationY;\n\t        this.orientationZ = options.orientationZ;\n\t        this.positionX = options.positionX;\n\t        this.positionY = options.positionY;\n\t        this.positionZ = options.positionZ;\n\t    };\n\t    Tone.extend(Tone.Panner3D);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t *  Defaults according to the specification\n\t\t */\n\t    Tone.Panner3D.defaults = {\n\t        'positionX': 0,\n\t        'positionY': 0,\n\t        'positionZ': 0,\n\t        'orientationX': 0,\n\t        'orientationY': 0,\n\t        'orientationZ': 0,\n\t        'panningModel': 'equalpower',\n\t        'maxDistance': 10000,\n\t        'distanceModel': 'inverse',\n\t        'coneOuterGain': 0,\n\t        'coneOuterAngle': 360,\n\t        'coneInnerAngle': 360,\n\t        'refDistance': 1,\n\t        'rolloffFactor': 1\n\t    };\n\t    /**\n\t\t * The ramp time which is applied to the setTargetAtTime\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t    Tone.Panner3D.prototype._rampTimeConstant = 0.01;\n\t    /**\n\t\t *  Sets the position of the source in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.setPosition = function (x, y, z) {\n\t        if (this._panner.positionX) {\n\t            var now = this.now();\n\t            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this._panner.setPosition(x, y, z);\n\t        }\n\t        this._position = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the orientation of the source in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {\n\t        if (this._panner.orientationX) {\n\t            var now = this.now();\n\t            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this._panner.setOrientation(x, y, z);\n\t        }\n\t        this._orientation = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The x position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionX\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {\n\t        set: function (pos) {\n\t            this._position[0] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionY\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {\n\t        set: function (pos) {\n\t            this._position[1] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionZ\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {\n\t        set: function (pos) {\n\t            this._position[2] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationX\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {\n\t        set: function (pos) {\n\t            this._orientation[0] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationY\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {\n\t        set: function (pos) {\n\t            this._orientation[1] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationZ\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {\n\t        set: function (pos) {\n\t            this._orientation[2] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  Proxy a property on the panner to an exposed public propery\n\t\t *  @param  {String}  prop\n\t\t *  @private\n\t\t */\n\t    Tone.Panner3D._aliasProperty = function (prop) {\n\t        Object.defineProperty(Tone.Panner3D.prototype, prop, {\n\t            set: function (val) {\n\t                this._panner[prop] = val;\n\t            },\n\t            get: function () {\n\t                return this._panner[prop];\n\t            }\n\t        });\n\t    };\n\t    /**\n\t\t *  The panning model. Either \"equalpower\" or \"HRTF\".\n\t\t *  @type {String}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name panningModel\n\t\t */\n\t    Tone.Panner3D._aliasProperty('panningModel');\n\t    /**\n\t\t *  A reference distance for reducing volume as source move further from the listener\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name refDistance\n\t\t */\n\t    Tone.Panner3D._aliasProperty('refDistance');\n\t    /**\n\t\t *  Describes how quickly the volume is reduced as source moves away from listener.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name rolloffFactor\n\t\t */\n\t    Tone.Panner3D._aliasProperty('rolloffFactor');\n\t    /**\n\t\t *  The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n\t\t *  @type {String}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name distanceModel\n\t\t */\n\t    Tone.Panner3D._aliasProperty('distanceModel');\n\t    /**\n\t\t *  The angle, in degrees, inside of which there will be no volume reduction\n\t\t *  @type {Degrees}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneInnerAngle\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneInnerAngle');\n\t    /**\n\t\t *  The angle, in degrees, outside of which the volume will be reduced \n\t\t *  to a constant value of coneOuterGain\n\t\t *  @type {Degrees}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneOuterAngle\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneOuterAngle');\n\t    /**\n\t\t *  The gain outside of the coneOuterAngle\n\t\t *  @type {Gain}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneOuterGain\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneOuterGain');\n\t    /**\n\t\t *  The maximum distance between source and listener, \n\t\t *  after which the volume will not be reduced any further.\n\t\t *  @type {Positive}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name maxDistance\n\t\t */\n\t    Tone.Panner3D._aliasProperty('maxDistance');\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.dispose = function () {\n\t        this._panner.disconnect();\n\t        this._panner = null;\n\t        this._orientation = null;\n\t        this._position = null;\n\t        return this;\n\t    };\n\t    return Tone.Panner3D;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {AudioRange} pan the initial pan\n\t\t *  @param {number} volume The output volume. \n\t\t *  @example\n\t\t * //pan the incoming signal left and drop the volume\n\t\t * var panVol = new Tone.PanVol(0.25, -12);\n\t\t */\n\t    Tone.PanVol = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'pan',\n\t            'volume'\n\t        ], Tone.PanVol.defaults);\n\t        /**\n\t\t\t *  The panning node\n\t\t\t *  @type {Tone.Panner}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = this.input = new Tone.Panner(options.pan);\n\t        /**\n\t\t\t *  The L/R panning control.\n\t\t\t *  @type {AudioRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.pan = this._panner.pan;\n\t        /**\n\t\t\t *  The volume node\n\t\t\t *  @type {Tone.Volume}\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t *  The volume control in decibels. \n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        //connections\n\t        this._panner.connect(this._volume);\n\t        this._readOnly([\n\t            'pan',\n\t            'volume'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PanVol);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.PanVol.defaults = {\n\t        'pan': 0.5,\n\t        'volume': 0\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.PanVol} this\n\t\t */\n\t    Tone.PanVol.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'pan',\n\t            'volume'\n\t        ]);\n\t        this._panner.dispose();\n\t        this._panner = null;\n\t        this.pan = null;\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.PanVol;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.CtrlInterpolate will interpolate between given values based\n\t\t *         on the \"index\" property. Passing in an array or object literal\n\t\t *         will interpolate each of the parameters. Note (i.e. \"C3\")\n\t\t *         and Time (i.e. \"4n + 2\") can be interpolated. All other values are\n\t\t *         assumed to be numbers. \n\t\t *  @example\n\t\t * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);\n\t\t * interp.index = 0.75;\n\t\t * interp.value; //returns 1.5\n\t\t *\n\t\t *  @example\n\t\t * var interp = new Tone.CtrlInterpolate([\n\t\t * \t[2, 4, 5],\n\t\t * \t[9, 3, 2],\n\t\t * ]);\n\t\t * @param {Array} values The array of values to interpolate over\n\t\t * @param {Positive} index The initial interpolation index.\n\t\t * @extends {Tone}\n\t\t */\n\t    Tone.CtrlInterpolate = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'values',\n\t            'index'\n\t        ], Tone.CtrlInterpolate.defaults);\n\t        /**\n\t\t\t *  The values to interpolate between\n\t\t\t *  @type  {Array}\n\t\t\t */\n\t        this.values = options.values;\n\t        /**\n\t\t\t *  The interpolated index between values. For example: a value of 1.5\n\t\t\t *  would interpolate equally between the value at index 1\n\t\t\t *  and the value at index 2. \n\t\t\t *  @example\n\t\t\t * interp.index = 0; \n\t\t\t * interp.value; //returns the value at 0\n\t\t\t * interp.index = 0.5;\n\t\t\t * interp.value; //returns the value between indices 0 and 1. \n\t\t\t *  @type  {Positive}\n\t\t\t */\n\t        this.index = options.index;\n\t    };\n\t    Tone.extend(Tone.CtrlInterpolate);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlInterpolate.defaults = {\n\t        'index': 0,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  The current interpolated value based on the index\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlInterpolate#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {\n\t        get: function () {\n\t            var index = this.index;\n\t            index = Math.min(index, this.values.length - 1);\n\t            var lowerPosition = Math.floor(index);\n\t            var lower = this.values[lowerPosition];\n\t            var upper = this.values[Math.ceil(index)];\n\t            return this._interpolate(index - lowerPosition, lower, upper);\n\t        }\n\t    });\n\t    /**\n\t\t *  Internal interpolation routine\n\t\t *  @param  {NormalRange}  index  The index between the lower and upper\n\t\t *  @param  {*}  lower \n\t\t *  @param  {*}  upper \n\t\t *  @return  {*}  The interpolated value\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {\n\t        if (this.isArray(lower)) {\n\t            var retArray = [];\n\t            for (var i = 0; i < lower.length; i++) {\n\t                retArray[i] = this._interpolate(index, lower[i], upper[i]);\n\t            }\n\t            return retArray;\n\t        } else if (this.isObject(lower)) {\n\t            var retObj = {};\n\t            for (var attr in lower) {\n\t                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);\n\t            }\n\t            return retObj;\n\t        } else {\n\t            lower = this._toNumber(lower);\n\t            upper = this._toNumber(upper);\n\t            return (1 - index) * lower + index * upper;\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert from the given type into a number\n\t\t *  @param  {Number|String}  value\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlInterpolate.prototype._toNumber = function (val) {\n\t        if (this.isNumber(val)) {\n\t            return val;\n\t        } else {\n\t            //otherwise assume that it's Time...\n\t            return this.toSeconds(val);\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.CtrlInterpolate}  this\n\t\t */\n\t    Tone.CtrlInterpolate.prototype.dispose = function () {\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlInterpolate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.CtrlMarkov represents a Markov Chain where each call\n\t\t *         to Tone.CtrlMarkov.next will move to the next state. If the next\n\t\t *         state choice is an array, the next state is chosen randomly with\n\t\t *         even probability for all of the choices. For a weighted probability\n\t\t *         of the next choices, pass in an object with \"state\" and \"probability\" attributes. \n\t\t *         The probabilities will be normalized and then chosen. If no next options\n\t\t *         are given for the current state, the state will stay there. \n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var chain = new Tone.CtrlMarkov({\n\t\t * \t\"beginning\" : [\"end\", \"middle\"],\n\t\t * \t\"middle\" : \"end\"\n\t\t * });\n\t\t * chain.value = \"beginning\";\n\t\t * chain.next(); //returns \"end\" or \"middle\" with 50% probability\n\t\t *\n\t\t *  @example\n\t\t * var chain = new Tone.CtrlMarkov({\n\t\t * \t\"beginning\" : [{\"value\" : \"end\", \"probability\" : 0.8}, \n\t\t * \t\t\t\t\t{\"value\" : \"middle\", \"probability\" : 0.2}],\n\t\t * \t\"middle\" : \"end\"\n\t\t * });\n\t\t * chain.value = \"beginning\";\n\t\t * chain.next(); //returns \"end\" with 80% probability or \"middle\" with 20%.\n\t\t *  @param {Object} values An object with the state names as the keys\n\t\t *                         and the next state(s) as the values. \n\t\t */\n\t    Tone.CtrlMarkov = function (values, initial) {\n\t        /**\n\t\t\t *  The Markov values with states as the keys\n\t\t\t *  and next state(s) as the values. \n\t\t\t *  @type {Object}\n\t\t\t */\n\t        this.values = this.defaultArg(values, {});\n\t        /**\n\t\t\t *  The current state of the Markov values. The next\n\t\t\t *  state will be evaluated and returned when Tone.CtrlMarkov.next\n\t\t\t *  is invoked.\n\t\t\t *  @type {String}\n\t\t\t */\n\t        this.value = this.defaultArg(initial, Object.keys(this.values)[0]);\n\t    };\n\t    Tone.extend(Tone.CtrlMarkov);\n\t    /**\n\t\t *  Returns the next state of the Markov values. \n\t\t *  @return  {String}\n\t\t */\n\t    Tone.CtrlMarkov.prototype.next = function () {\n\t        if (this.values.hasOwnProperty(this.value)) {\n\t            var next = this.values[this.value];\n\t            if (this.isArray(next)) {\n\t                var distribution = this._getProbDistribution(next);\n\t                var rand = Math.random();\n\t                var total = 0;\n\t                for (var i = 0; i < distribution.length; i++) {\n\t                    var dist = distribution[i];\n\t                    if (rand > total && rand < total + dist) {\n\t                        var chosen = next[i];\n\t                        if (this.isObject(chosen)) {\n\t                            this.value = chosen.value;\n\t                        } else {\n\t                            this.value = chosen;\n\t                        }\n\t                    }\n\t                    total += dist;\n\t                }\n\t            } else {\n\t                this.value = next;\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    /**\n\t\t *  Choose randomly from an array weighted options in the form \n\t\t *  {\"state\" : string, \"probability\" : number} or an array of values\n\t\t *  @param  {Array}  options \n\t\t *  @return  {Array}  The randomly selected choice\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {\n\t        var distribution = [];\n\t        var total = 0;\n\t        var needsNormalizing = false;\n\t        for (var i = 0; i < options.length; i++) {\n\t            var option = options[i];\n\t            if (this.isObject(option)) {\n\t                needsNormalizing = true;\n\t                distribution[i] = option.probability;\n\t            } else {\n\t                distribution[i] = 1 / options.length;\n\t            }\n\t            total += distribution[i];\n\t        }\n\t        if (needsNormalizing) {\n\t            //normalize the values\n\t            for (var j = 0; j < distribution.length; j++) {\n\t                distribution[j] = distribution[j] / total;\n\t            }\n\t        }\n\t        return distribution;\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.CtrlMarkov}  this\n\t\t */\n\t    Tone.CtrlMarkov.prototype.dispose = function () {\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlMarkov;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Generate patterns from an array of values.\n\t\t *         Has a number of arpeggiation and randomized\n\t\t *         selection patterns. \n\t\t *           <ul>\n\t\t *  \t        <li>\"up\" - cycles upward</li>\n\t\t *  \t\t\t<li>\"down\" - cycles downward</li>\n\t\t *  \t\t\t<li>\"upDown\" - up then and down</li>\n\t\t *  \t\t\t<li>\"downUp\" - cycles down then and up</li>\n\t\t *  \t\t\t<li>\"alternateUp\" - jump up two and down one</li>\n\t\t *  \t\t\t<li>\"alternateDown\" - jump down two and up one</li>\n\t\t *  \t\t\t<li>\"random\" - randomly select an index</li>\n\t\t *  \t\t\t<li>\"randomWalk\" - randomly moves one index away from the current position</li>\n\t\t *  \t\t\t<li>\"randomOnce\" - randomly select an index without repeating until all values have been chosen.</li>\n\t\t *     \t\t</ul>\n\t\t *  @param  {Array}  values   An array of options to choose from.\n\t\t *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.CtrlPattern = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'values',\n\t            'type'\n\t        ], Tone.CtrlPattern.defaults);\n\t        /**\n\t\t\t *  The array of values to arpeggiate over\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.values = options.values;\n\t        /**\n\t\t\t *  The current position in the values array\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this.index = 0;\n\t        /**\n\t\t\t *  The type placeholder\n\t\t\t *  @type {Tone.CtrlPattern.Type}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = null;\n\t        /**\n\t\t\t *  Shuffled values for the RandomOnce type\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shuffled = null;\n\t        /**\n\t\t\t *  The direction of the movement\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._direction = null;\n\t        this.type = options.type;\n\t    };\n\t    Tone.extend(Tone.CtrlPattern);\n\t    /**\n\t\t *  The Control Patterns\n\t\t *  @type  {Object}\n\t\t *  @static\n\t\t */\n\t    Tone.CtrlPattern.Type = {\n\t        Up: 'up',\n\t        Down: 'down',\n\t        UpDown: 'upDown',\n\t        DownUp: 'downUp',\n\t        AlternateUp: 'alternateUp',\n\t        AlternateDown: 'alternateDown',\n\t        Random: 'random',\n\t        RandomWalk: 'randomWalk',\n\t        RandomOnce: 'randomOnce'\n\t    };\n\t    /**\n\t\t *  The default values. \n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlPattern.defaults = {\n\t        'type': Tone.CtrlPattern.Type.Up,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  The value at the current index of the pattern.\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlPattern#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {\n\t        get: function () {\n\t            //some safeguards\n\t            if (this.values.length === 0) {\n\t                return;\n\t            } else if (this.values.length === 1) {\n\t                return this.values[0];\n\t            }\n\t            this.index = Math.min(this.index, this.values.length - 1);\n\t            var val = this.values[this.index];\n\t            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {\n\t                if (this.values.length !== this._shuffled.length) {\n\t                    this._shuffleValues();\n\t                }\n\t                val = this.values[this._shuffled[this.index]];\n\t            }\n\t            return val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The pattern used to select the next\n\t\t *  item from the values array\n\t\t *  @memberOf Tone.CtrlPattern#\n\t\t *  @type {Tone.CtrlPattern.Type}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            this._type = type;\n\t            this._shuffled = null;\n\t            //the first index\n\t            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {\n\t                this.index = 0;\n\t            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {\n\t                this.index = this.values.length - 1;\n\t            }\n\t            //the direction\n\t            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t            //randoms\n\t            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {\n\t                this._shuffleValues();\n\t            } else if (this._type === Tone.CtrlPattern.Random) {\n\t                this.index = Math.floor(Math.random() * this.values.length);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Return the next value given the current position\n\t\t *  and pattern.\n\t\t *  @return {*} The next value\n\t\t */\n\t    Tone.CtrlPattern.prototype.next = function () {\n\t        var type = this.type;\n\t        //choose the next index\n\t        if (type === Tone.CtrlPattern.Type.Up) {\n\t            this.index++;\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.Down) {\n\t            this.index--;\n\t            if (this.index < 0) {\n\t                this.index = this.values.length - 1;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index++;\n\t            } else {\n\t                this.index--;\n\t            }\n\t            if (this.index < 0) {\n\t                this.index = 1;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            } else if (this.index >= this.values.length) {\n\t                this.index = this.values.length - 2;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.Random) {\n\t            this.index = Math.floor(Math.random() * this.values.length);\n\t        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {\n\t            if (Math.random() < 0.5) {\n\t                this.index--;\n\t                this.index = Math.max(this.index, 0);\n\t            } else {\n\t                this.index++;\n\t                this.index = Math.min(this.index, this.values.length - 1);\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {\n\t            this.index++;\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t                //reshuffle the values for next time\n\t                this._shuffleValues();\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index += 2;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            } else {\n\t                this.index -= 1;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index += 1;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            } else {\n\t                this.index -= 2;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t            if (this.index < 0) {\n\t                this.index = this.values.length - 1;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    /**\n\t\t *  Shuffles the values and places the results into the _shuffled\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlPattern.prototype._shuffleValues = function () {\n\t        var copy = [];\n\t        this._shuffled = [];\n\t        for (var i = 0; i < this.values.length; i++) {\n\t            copy[i] = i;\n\t        }\n\t        while (copy.length > 0) {\n\t            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t            this._shuffled.push(randVal[0]);\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.CtrlPattern} this\n\t\t */\n\t    Tone.CtrlPattern.prototype.dispose = function () {\n\t        this._shuffled = null;\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlPattern;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Choose a random value.\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var randomWalk = new Tone.CtrlRandom({\n\t\t * \t\"min\" : 0,\n\t\t * \t\"max\" : 10,\n\t\t * \t\"integer\" : true\n\t\t * });\n\t\t * randomWalk.eval();\n\t\t *\n\t\t *  @param {Number|Time=} min The minimum return value.\n\t\t *  @param {Number|Time=} max The maximum return value.\n\t\t */\n\t    Tone.CtrlRandom = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'min',\n\t            'max'\n\t        ], Tone.CtrlRandom.defaults);\n\t        /**\n\t\t\t *  The minimum return value\n\t\t\t *  @type  {Number|Time}\n\t\t\t */\n\t        this.min = options.min;\n\t        /**\n\t\t\t *  The maximum return value\n\t\t\t *  @type  {Number|Time}\n\t\t\t */\n\t        this.max = options.max;\n\t        /**\n\t\t\t *  If the return value should be an integer\n\t\t\t *  @type  {Boolean}\n\t\t\t */\n\t        this.integer = options.integer;\n\t    };\n\t    Tone.extend(Tone.CtrlRandom);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlRandom.defaults = {\n\t        'min': 0,\n\t        'max': 1,\n\t        'integer': false\n\t    };\n\t    /**\n\t\t *  Return a random value between min and max. \n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlRandom#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {\n\t        get: function () {\n\t            var min = this.toSeconds(this.min);\n\t            var max = this.toSeconds(this.max);\n\t            var rand = Math.random();\n\t            var val = rand * min + (1 - rand) * max;\n\t            if (this.integer) {\n\t                val = Math.floor(val);\n\t            }\n\t            return val;\n\t        }\n\t    });\n\t    return Tone.CtrlRandom;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  AudioBuffer.copyToChannel polyfill\n\t\t *  @private\n\t\t */\n\t    if (window.AudioBuffer && !AudioBuffer.prototype.copyToChannel) {\n\t        AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {\n\t            var channel = this.getChannelData(chanNum);\n\t            start = start || 0;\n\t            for (var i = 0; i < channel.length; i++) {\n\t                channel[i + start] = src[i];\n\t            }\n\t        };\n\t        AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {\n\t            var channel = this.getChannelData(chanNum);\n\t            start = start || 0;\n\t            for (var i = 0; i < channel.length; i++) {\n\t                dest[i] = channel[i + start];\n\t            }\n\t        };\n\t    }\n\t    /**\n\t\t *  @class  Buffer loading and storage. Tone.Buffer is used internally by all \n\t\t *          classes that make requests for audio files such as Tone.Player,\n\t\t *          Tone.Sampler and Tone.Convolver.\n\t\t *          <br><br>\n\t\t *          Aside from load callbacks from individual buffers, Tone.Buffer \n\t\t *  \t\tprovides static methods which keep track of the loading progress \n\t\t *  \t\tof all of the buffers. These methods are Tone.Buffer.on(\"load\" / \"progress\" / \"error\")\n\t\t *\n\t\t *  @constructor \n\t\t *  @extends {Tone}\n\t\t *  @param {AudioBuffer|string} url The url to load, or the audio buffer to set. \n\t\t *  @param {Function=} onload A callback which is invoked after the buffer is loaded. \n\t\t *                            It's recommended to use Tone.Buffer.onload instead \n\t\t *                            since it will give you a callback when ALL buffers are loaded.\n\t\t *  @param {Function=} onerror The callback to invoke if there is an error\n\t\t *  @example\n\t\t * var buffer = new Tone.Buffer(\"path/to/sound.mp3\", function(){\n\t\t * \t//the buffer is now available.\n\t\t * \tvar buff = buffer.get();\n\t\t * });\n\t\t */\n\t    Tone.Buffer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload',\n\t            'onerror'\n\t        ], Tone.Buffer.defaults);\n\t        /**\n\t\t\t *  stores the loaded AudioBuffer\n\t\t\t *  @type {AudioBuffer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = null;\n\t        /**\n\t\t\t *  indicates if the buffer should be reversed or not\n\t\t\t *  @type {Boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this._reversed = options.reverse;\n\t        /**\n\t\t\t *  The XHR\n\t\t\t *  @type  {XMLHttpRequest}\n\t\t\t *  @private\n\t\t\t */\n\t        this._xhr = null;\n\t        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {\n\t            this.set(options.url);\n\t            // invoke the onload callback\n\t            if (options.onload) {\n\t                options.onload(this);\n\t            }\n\t        } else if (this.isString(options.url)) {\n\t            this.load(options.url, options.onload, options.onerror);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Buffer);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Buffer.defaults = {\n\t        'url': undefined,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Pass in an AudioBuffer or Tone.Buffer to set the value\n\t\t *  of this buffer.\n\t\t *  @param {AudioBuffer|Tone.Buffer} buffer the buffer\n\t\t *  @returns {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.set = function (buffer) {\n\t        if (buffer instanceof Tone.Buffer) {\n\t            this._buffer = buffer.get();\n\t        } else {\n\t            this._buffer = buffer;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  @return {AudioBuffer} The audio buffer stored in the object.\n\t\t */\n\t    Tone.Buffer.prototype.get = function () {\n\t        return this._buffer;\n\t    };\n\t    /**\n\t\t *  Makes an xhr reqest for the selected url then decodes\n\t\t *  the file as an audio buffer. Invokes\n\t\t *  the callback once the audio buffer loads.\n\t\t *  @param {String} url The url of the buffer to load.\n\t\t *                      filetype support depends on the\n\t\t *                      browser.\n\t\t *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer\n\t\t */\n\t    Tone.Buffer.prototype.load = function (url, onload, onerror) {\n\t        var promise = new Promise(function (load, error) {\n\t            this._xhr = Tone.Buffer.load(url, //success\n\t            function (buff) {\n\t                this._xhr = null;\n\t                this.set(buff);\n\t                load(this);\n\t                if (onload) {\n\t                    onload(this);\n\t                }\n\t            }.bind(this), //error\n\t            function (err) {\n\t                this._xhr = null;\n\t                error(err);\n\t                if (onerror) {\n\t                    onerror(err);\n\t                }\n\t            }.bind(this));\n\t        }.bind(this));\n\t        return promise;\n\t    };\n\t    /**\n\t\t *  dispose and disconnect\n\t\t *  @returns {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this._buffer = null;\n\t        if (this._xhr) {\n\t            Tone.Buffer._currentDownloads--;\n\t            this._xhr.abort();\n\t            this._xhr = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * If the buffer is loaded or not\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Boolean}\n\t\t * @name loaded\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {\n\t        get: function () {\n\t            return this.length > 0;\n\t        }\n\t    });\n\t    /**\n\t\t * The duration of the buffer. \n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name duration\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'duration', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.duration;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The length of the buffer in samples\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name length\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'length', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.length;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of discrete audio channels. Returns 0 if no buffer\n\t\t * is loaded.\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name numberOfChannels\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.numberOfChannels;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the audio buffer from the array\n\t\t *  @param {Float32Array} array The array to fill the audio buffer\n\t\t *  @param {Number} [channels=1] The number of channels contained in the array. \n\t\t *                               If the channel is more than 1, the input array\n\t\t *                               is expected to be a multidimensional array\n\t\t *                               with dimensions equal to the number of channels.\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.fromArray = function (array) {\n\t        var isMultidimensional = array[0].length > 0;\n\t        var channels = isMultidimensional ? array.length : 1;\n\t        var len = isMultidimensional ? array[0].length : array.length;\n\t        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);\n\t        if (!isMultidimensional && channels === 1) {\n\t            array = [array];\n\t        }\n\t        for (var c = 0; c < channels; c++) {\n\t            buffer.copyToChannel(array[c], c);\n\t        }\n\t        this._buffer = buffer;\n\t        return this;\n\t    };\n\t    /**\n\t\t * \tSums muliple channels into 1 channel\n\t\t *  @param {Number=} channel Optionally only copy a single channel from the array.\n\t\t *  @return {Array}\n\t\t */\n\t    Tone.Buffer.prototype.toMono = function (chanNum) {\n\t        if (this.isNumber(chanNum)) {\n\t            this.fromArray(this.toArray(chanNum));\n\t        } else {\n\t            var outputArray = new Float32Array(this.length);\n\t            var numChannels = this.numberOfChannels;\n\t            for (var channel = 0; channel < numChannels; channel++) {\n\t                var channelArray = this.toArray(channel);\n\t                for (var i = 0; i < channelArray.length; i++) {\n\t                    outputArray[i] += channelArray[i];\n\t                }\n\t            }\n\t            //divide by the number of channels\n\t            outputArray = outputArray.map(function (sample) {\n\t                return sample / numChannels;\n\t            });\n\t            this.fromArray(outputArray);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional \n\t\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t\t *  @param {Number=} channel Optionally only copy a single channel from the array.\n\t\t *  @return {Array}\n\t\t */\n\t    Tone.Buffer.prototype.toArray = function (channel) {\n\t        if (this.isNumber(channel)) {\n\t            return this.getChannelData(channel);\n\t        } else if (this.numberOfChannels === 1) {\n\t            return this.toArray(0);\n\t        } else {\n\t            var ret = [];\n\t            for (var c = 0; c < this.numberOfChannels; c++) {\n\t                ret[c] = this.getChannelData(c);\n\t            }\n\t            return ret;\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t\t *  @param  {Number}  channel  The channel number to return\n\t\t *  @return  {Float32Array}  The audio as a TypedArray\n\t\t */\n\t    Tone.Buffer.prototype.getChannelData = function (channel) {\n\t        return this._buffer.getChannelData(channel);\n\t    };\n\t    /**\n\t\t *  Cut a subsection of the array and return a buffer of the\n\t\t *  subsection. Does not modify the original buffer\n\t\t *  @param {Time} start The time to start the slice\n\t\t *  @param {Time=} end The end time to slice. If none is given\n\t\t *                     will default to the end of the buffer\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.slice = function (start, end) {\n\t        end = this.defaultArg(end, this.duration);\n\t        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));\n\t        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));\n\t        var replacement = [];\n\t        for (var i = 0; i < this.numberOfChannels; i++) {\n\t            replacement[i] = this.toArray(i).slice(startSamples, endSamples);\n\t        }\n\t        var retBuffer = new Tone.Buffer().fromArray(replacement);\n\t        return retBuffer;\n\t    };\n\t    /**\n\t\t *  Reverse the buffer.\n\t\t *  @private\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype._reverse = function () {\n\t        if (this.loaded) {\n\t            for (var i = 0; i < this.numberOfChannels; i++) {\n\t                Array.prototype.reverse.call(this.getChannelData(i));\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * Reverse the buffer.\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {\n\t        get: function () {\n\t            return this._reversed;\n\t        },\n\t        set: function (rev) {\n\t            if (this._reversed !== rev) {\n\t                this._reversed = rev;\n\t                this._reverse();\n\t            }\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // STATIC METHODS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //statically inherits Emitter methods\n\t    Tone.Emitter.mixin(Tone.Buffer);\n\t    /**\n\t\t *  the static queue for all of the xhr requests\n\t\t *  @type {Array}\n\t\t *  @private\n\t\t */\n\t    Tone.Buffer._downloadQueue = [];\n\t    /**\n\t\t *  the total number of downloads\n\t\t *  @type {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Buffer._currentDownloads = 0;\n\t    /**\n\t\t *  A path which is prefixed before every url.\n\t\t *  @type  {String}\n\t\t *  @static\n\t\t */\n\t    Tone.Buffer.baseUrl = '';\n\t    /**\n\t\t *  Loads a url using XMLHttpRequest.\n\t\t *  @param {String} url\n\t\t *  @param {Function} onload\n\t\t *  @param {Function} onerror\n\t\t *  @param {Function} onprogress\n\t\t *  @return {XMLHttpRequest}\n\t\t */\n\t    Tone.Buffer.load = function (url, onload, onerror) {\n\t        //default\n\t        onload = onload || Tone.noOp;\n\t        function onError(e) {\n\t            if (onerror) {\n\t                onerror(e);\n\t                Tone.Buffer.emit('error', e);\n\t            } else {\n\t                throw new Error(e);\n\t            }\n\t        }\n\t        function onProgress() {\n\t            //calculate the progress\n\t            var totalProgress = 0;\n\t            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {\n\t                totalProgress += Tone.Buffer._downloadQueue[i].progress;\n\t            }\n\t            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);\n\t        }\n\t        var request = new XMLHttpRequest();\n\t        request.open('GET', Tone.Buffer.baseUrl + url, true);\n\t        request.responseType = 'arraybuffer';\n\t        //start out as 0\n\t        request.progress = 0;\n\t        Tone.Buffer._currentDownloads++;\n\t        Tone.Buffer._downloadQueue.push(request);\n\t        request.addEventListener('load', function () {\n\t            if (request.status === 200) {\n\t                Tone.context.decodeAudioData(request.response, function (buff) {\n\t                    request.progress = 1;\n\t                    onProgress();\n\t                    onload(buff);\n\t                    Tone.Buffer._currentDownloads--;\n\t                    if (Tone.Buffer._currentDownloads === 0) {\n\t                        // clear the downloads\n\t                        Tone.Buffer._downloadQueue = [];\n\t                        //emit the event at the end\n\t                        Tone.Buffer.emit('load');\n\t                    }\n\t                }, function () {\n\t                    onError('Tone.Buffer: could not decode audio data: ' + url);\n\t                });\n\t            } else {\n\t                onError('Tone.Buffer: could not locate file: ' + url);\n\t            }\n\t        });\n\t        request.addEventListener('error', onError);\n\t        request.addEventListener('progress', function (event) {\n\t            if (event.lengthComputable) {\n\t                //only go to 95%, the last 5% is when the audio is decoded\n\t                request.progress = event.loaded / event.total * 0.95;\n\t                onProgress();\n\t            }\n\t        });\n\t        request.send();\n\t        return request;\n\t    };\n\t    /**\n\t\t *  Stop all of the downloads in progress\n\t\t *  @return {Tone.Buffer}\n\t\t *  @static\n\t\t */\n\t    Tone.Buffer.cancelDownloads = function () {\n\t        Tone.Buffer._downloadQueue.forEach(function (request) {\n\t            request.abort();\n\t        });\n\t        Tone.Buffer._currentDownloads = 0;\n\t        return Tone.Buffer;\n\t    };\n\t    /**\n\t\t *  Checks a url's extension to see if the current browser can play that file type.\n\t\t *  @param {String} url The url/extension to test\n\t\t *  @return {Boolean} If the file extension can be played\n\t\t *  @static\n\t\t *  @example\n\t\t * Tone.Buffer.supportsType(\"wav\"); //returns true\n\t\t * Tone.Buffer.supportsType(\"path/to/file.wav\"); //returns true\n\t\t */\n\t    Tone.Buffer.supportsType = function (url) {\n\t        var extension = url.split('.');\n\t        extension = extension[extension.length - 1];\n\t        var response = document.createElement('audio').canPlayType('audio/' + extension);\n\t        return response !== '';\n\t    };\n\t    /**\n\t\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t\t *  @return {Promise}\n\t\t */\n\t    Tone.loaded = function () {\n\t        var onload, onerror;\n\t        function removeEvents() {\n\t            //remove the events when it's resolved\n\t            Tone.Buffer.off('load', onload);\n\t            Tone.Buffer.off('error', onerror);\n\t        }\n\t        return new Promise(function (success, fail) {\n\t            onload = function () {\n\t                success();\n\t            };\n\t            onerror = function () {\n\t                fail();\n\t            };\n\t            //add the event listeners\n\t            Tone.Buffer.on('load', onload);\n\t            Tone.Buffer.on('error', onerror);\n\t        }).then(removeEvents).catch(function (e) {\n\t            removeEvents();\n\t            throw new Error(e);\n\t        });\n\t    };\n\t    return Tone.Buffer;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class A data structure for holding multiple buffers.\n\t\t *  \n\t\t *  @param  {Object|Array}    urls      An object literal or array\n\t\t *                                      of urls to load.\n\t\t *  @param  {Function=}  callback  The callback to invoke when\n\t\t *                                 the buffers are loaded. \n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * //load a whole bank of piano samples\n\t\t * var pianoSamples = new Tone.Buffers({\n\t\t * \t\"C4\" : \"path/to/C4.mp3\"\n\t\t * \t\"C#4\" : \"path/to/C#4.mp3\"\n\t\t * \t\"D4\" : \"path/to/D4.mp3\"\n\t\t * \t\"D#4\" : \"path/to/D#4.mp3\"\n\t\t * \t...\n\t\t * }, function(){\n\t\t * \t//play one of the samples when they all load\n\t\t * \tplayer.buffer = pianoSamples.get(\"C4\");\n\t\t * \tplayer.start();\n\t\t * });\n\t\t * \n\t\t */\n\t    Tone.Buffers = function (urls, onload, baseUrl) {\n\t        /**\n\t\t\t *  All of the buffers\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffers = {};\n\t        /**\n\t\t\t *  A path which is prefixed before every url.\n\t\t\t *  @type  {String}\n\t\t\t */\n\t        this.baseUrl = this.defaultArg(baseUrl, '');\n\t        urls = this._flattenUrls(urls);\n\t        this._loadingCount = 0;\n\t        //add each one\n\t        for (var key in urls) {\n\t            this._loadingCount++;\n\t            this.add(key, urls[key], this._bufferLoaded.bind(this, onload));\n\t        }\n\t    };\n\t    Tone.extend(Tone.Buffers);\n\t    /**\n\t\t *  True if the buffers object has a buffer by that name.\n\t\t *  @param  {String|Number}  name  The key or index of the \n\t\t *                                 buffer.\n\t\t *  @return  {Boolean}\n\t\t */\n\t    Tone.Buffers.prototype.has = function (name) {\n\t        return this._buffers.hasOwnProperty(name);\n\t    };\n\t    /**\n\t\t *  Get a buffer by name. If an array was loaded, \n\t\t *  then use the array index.\n\t\t *  @param  {String|Number}  name  The key or index of the \n\t\t *                                 buffer.\n\t\t *  @return  {Tone.Buffer}\n\t\t */\n\t    Tone.Buffers.prototype.get = function (name) {\n\t        if (this.has(name)) {\n\t            return this._buffers[name];\n\t        } else {\n\t            throw new Error('Tone.Buffers: no buffer named ' + name);\n\t        }\n\t    };\n\t    /**\n\t\t *  A buffer was loaded. decrement the counter.\n\t\t *  @param  {Function}  callback \n\t\t *  @private\n\t\t */\n\t    Tone.Buffers.prototype._bufferLoaded = function (callback) {\n\t        this._loadingCount--;\n\t        if (this._loadingCount === 0 && callback) {\n\t            callback(this);\n\t        }\n\t    };\n\t    /**\n\t\t * If the buffers are loaded or not\n\t\t * @memberOf Tone.Buffers#\n\t\t * @type {Boolean}\n\t\t * @name loaded\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {\n\t        get: function () {\n\t            var isLoaded = true;\n\t            for (var buffName in this._buffers) {\n\t                var buff = this.get(buffName);\n\t                isLoaded = isLoaded && buff.loaded;\n\t            }\n\t            return isLoaded;\n\t        }\n\t    });\n\t    /**\n\t\t *  Add a buffer by name and url to the Buffers\n\t\t *  @param  {String}    name      A unique name to give\n\t\t *                                the buffer\n\t\t *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, \n\t\t *                                                 or a buffer which will be added\n\t\t *                                                 with the given name.\n\t\t *  @param  {Function=}  callback  The callback to invoke \n\t\t *                                 when the url is loaded.\n\t\t */\n\t    Tone.Buffers.prototype.add = function (name, url, callback) {\n\t        callback = this.defaultArg(callback, Tone.noOp);\n\t        if (url instanceof Tone.Buffer) {\n\t            this._buffers[name] = url;\n\t            callback(this);\n\t        } else if (url instanceof AudioBuffer) {\n\t            this._buffers[name] = new Tone.Buffer(url);\n\t            callback(this);\n\t        } else if (this.isString(url)) {\n\t            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Flatten an object into a single depth object. \n\t\t *  thanks to https://gist.github.com/penguinboy/762197\n\t\t *  @param   {Object} ob \t\n\t\t *  @return  {Object}    \n\t\t *  @private\n\t\t */\n\t    Tone.Buffers.prototype._flattenUrls = function (ob) {\n\t        var toReturn = {};\n\t        for (var i in ob) {\n\t            if (!ob.hasOwnProperty(i))\n\t                continue;\n\t            if (this.isObject(ob[i])) {\n\t                var flatObject = this._flattenUrls(ob[i]);\n\t                for (var x in flatObject) {\n\t                    if (!flatObject.hasOwnProperty(x))\n\t                        continue;\n\t                    toReturn[i + '.' + x] = flatObject[x];\n\t                }\n\t            } else {\n\t                toReturn[i] = ob[i];\n\t            }\n\t        }\n\t        return toReturn;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Buffers} this\n\t\t */\n\t    Tone.Buffers.prototype.dispose = function () {\n\t        for (var name in this._buffers) {\n\t            this._buffers[name].dispose();\n\t        }\n\t        this._buffers = null;\n\t        return this;\n\t    };\n\t    return Tone.Buffers;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  buses are another way of routing audio\n\t\t *\n\t\t *  augments Tone.prototype to include send and recieve\n\t\t */\n\t    /**\n\t\t  *  All of the routes\n\t\t  *  \n\t\t  *  @type {Object}\n\t\t  *  @static\n\t\t  *  @private\n\t\t  */\n\t    var Buses = {};\n\t    /**\n\t\t *  Send this signal to the channel name. \n\t\t *  @param  {string} channelName A named channel to send the signal to.\n\t\t *  @param  {Decibels} amount The amount of the source to send to the bus. \n\t\t *  @return {GainNode} The gain node which connects this node to the desired channel. \n\t\t *                     Can be used to adjust the levels of the send.\n\t\t *  @example\n\t\t * source.send(\"reverb\", -12);\n\t\t */\n\t    Tone.prototype.send = function (channelName, amount) {\n\t        if (!Buses.hasOwnProperty(channelName)) {\n\t            Buses[channelName] = this.context.createGain();\n\t        }\n\t        amount = this.defaultArg(amount, 0);\n\t        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);\n\t        this.output.chain(sendKnob, Buses[channelName]);\n\t        return sendKnob;\n\t    };\n\t    /**\n\t\t *  Recieve the input from the desired channelName to the input\n\t\t *\n\t\t *  @param  {string} channelName A named channel to send the signal to.\n\t\t *  @param {AudioNode} [input] If no input is selected, the\n\t\t *                                         input of the current node is\n\t\t *                                         chosen. \n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * reverbEffect.receive(\"reverb\");\n\t\t */\n\t    Tone.prototype.receive = function (channelName, input) {\n\t        if (!Buses.hasOwnProperty(channelName)) {\n\t            Buses[channelName] = this.context.createGain();\n\t        }\n\t        if (this.isUndef(input)) {\n\t            input = this.input;\n\t        }\n\t        Buses[channelName].connect(input);\n\t        return this;\n\t    };\n\t    //remove all the send/receives when a new audio context is passed in\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Buses) {\n\t            Buses = context.Buses;\n\t        } else {\n\t            Buses = {};\n\t            context.Buses = Buses;\n\t        }\n\t    });\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Draw is useful for synchronizing visuals and audio events.\n\t\t *         Callbacks from Tone.Transport or any of the Tone.Event classes\n\t\t *         always happen _before_ the scheduled time and are not synchronized\n\t\t *         to the animation frame so they are not good for triggering tightly\n\t\t *         synchronized visuals and sound. Tone.Draw makes it easy to schedule\n\t\t *         callbacks using the AudioContext time and uses requestAnimationFrame.\n\t\t *         \n\t\t *  @singleton\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \t//use the time argument to schedule a callback with Tone.Draw\n\t\t * \tTone.Draw.schedule(function(){\n\t\t * \t\t//do drawing or DOM manipulation here\n\t\t * \t}, time)\n\t\t * }, \"+0.5\")\n\t\t */\n\t    Tone.Draw = function () {\n\t        /**\n\t\t\t *  All of the events.\n\t\t\t *  @type  {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = new Tone.Timeline();\n\t        /**\n\t\t\t *  The duration after which events are not invoked.\n\t\t\t *  @type  {Number}\n\t\t\t *  @default 0.25\n\t\t\t */\n\t        this.expiration = 0.25;\n\t        /**\n\t\t\t *  The amount of time before the scheduled time \n\t\t\t *  that the callback can be invoked. Default is\n\t\t\t *  half the time of an animation frame (0.008 seconds).\n\t\t\t *  @type  {Number}\n\t\t\t *  @default 0.008\n\t\t\t */\n\t        this.anticipation = 0.008;\n\t        /**\n\t\t\t *  The draw loop\n\t\t\t *  @type  {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._boundDrawLoop = this._drawLoop.bind(this);\n\t    };\n\t    Tone.extend(Tone.Draw);\n\t    /**\n\t\t *  Schedule a function at the given time to be invoked\n\t\t *  on the nearest animation frame.\n\t\t *  @param  {Function}  callback  Callback is invoked at the given time.\n\t\t *  @param  {Time}    time      The time relative to the AudioContext time\n\t\t *                              to invoke the callback.\n\t\t *  @return  {Tone.Draw}    this\n\t\t */\n\t    Tone.Draw.prototype.schedule = function (callback, time) {\n\t        this._events.add({\n\t            callback: callback,\n\t            time: this.toSeconds(time)\n\t        });\n\t        //start the draw loop on the first event\n\t        if (this._events.length === 1) {\n\t            requestAnimationFrame(this._boundDrawLoop);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel events scheduled after the given time\n\t\t *  @param  {Time=}  after  Time after which scheduled events will \n\t\t *                          be removed from the scheduling timeline.\n\t\t *  @return  {Tone.Draw}  this\n\t\t */\n\t    Tone.Draw.prototype.cancel = function (after) {\n\t        this._events.cancel(this.toSeconds(after));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The draw loop\n\t\t *  @private\n\t\t */\n\t    Tone.Draw.prototype._drawLoop = function () {\n\t        var now = Tone.now();\n\t        while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n\t            var event = this._events.shift();\n\t            if (now - event.time <= this.expiration) {\n\t                event.callback();\n\t            }\n\t        }\n\t        if (this._events.length > 0) {\n\t            requestAnimationFrame(this._boundDrawLoop);\n\t        }\n\t    };\n\t    //make a singleton\n\t    Tone.Draw = new Tone.Draw();\n\t    return Tone.Draw;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space \n\t\t *          using a right-handed cartesian coordinate system. \n\t\t *          The units used in the coordinate system are not defined; \n\t\t *          these coordinates are independent/invariant of any particular \n\t\t *          units such as meters or feet. Tone.Panner3D objects have an forward \n\t\t *          vector representing the direction the sound is projecting. Additionally, \n\t\t *          they have a sound cone representing how directional the sound is. \n\t\t *          For example, the sound could be omnidirectional, in which case it would \n\t\t *          be heard anywhere regardless of its forward, or it can be more directional \n\t\t *          and heard only if it is facing the listener. Tone.Listener objects \n\t\t *          (representing a person's ears) have an forward and up vector \n\t\t *          representing in which direction the person is facing. Because both the \n\t\t *          source stream and the listener can be moving, they both have a velocity \n\t\t *          vector representing both the speed and direction of movement. Taken together, \n\t\t *          these two velocities can be used to generate a doppler shift effect which changes the pitch.\n\t\t *          <br><br>\n\t\t *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @singleton\n\t\t *  @param {Number} positionX The initial x position.\n\t\t *  @param {Number} positionY The initial y position.\n\t\t *  @param {Number} positionZ The initial z position.\n\t\t */\n\t    Tone.Listener = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'positionX',\n\t            'positionY',\n\t            'positionZ'\n\t        ], ListenerConstructor.defaults);\n\t        /**\n\t\t\t *  Holds the current forward orientation\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._orientation = [\n\t            options.forwardX,\n\t            options.forwardY,\n\t            options.forwardZ,\n\t            options.upX,\n\t            options.upY,\n\t            options.upZ\n\t        ];\n\t        /**\n\t\t\t *  Holds the current position\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._position = [\n\t            options.positionX,\n\t            options.positionY,\n\t            options.positionZ\n\t        ];\n\t        // set the default position/forward\n\t        this.forwardX = options.forwardX;\n\t        this.forwardY = options.forwardY;\n\t        this.forwardZ = options.forwardZ;\n\t        this.upX = options.upX;\n\t        this.upY = options.upY;\n\t        this.upZ = options.upZ;\n\t        this.positionX = options.positionX;\n\t        this.positionY = options.positionY;\n\t        this.positionZ = options.positionZ;\n\t    };\n\t    Tone.extend(Tone.Listener);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t *  Defaults according to the specification\n\t\t */\n\t    Tone.Listener.defaults = {\n\t        'positionX': 0,\n\t        'positionY': 0,\n\t        'positionZ': 0,\n\t        'forwardX': 0,\n\t        'forwardY': 0,\n\t        'forwardZ': 1,\n\t        'upX': 0,\n\t        'upY': 1,\n\t        'upZ': 0\n\t    };\n\t    /**\n\t\t * The ramp time which is applied to the setTargetAtTime\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t    Tone.Listener.prototype._rampTimeConstant = 0.01;\n\t    /**\n\t\t *  Sets the position of the listener in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.setPosition = function (x, y, z) {\n\t        if (this.context.listener.positionX) {\n\t            var now = this.now();\n\t            this.context.listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this.context.listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this.context.listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this.context.listener.setPosition(x, y, z);\n\t        }\n\t        this._position = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the orientation of the listener using two vectors, the forward\n\t\t *  vector (which direction the listener is facing) and the up vector \n\t\t *  (which the up direction of the listener). An up vector\n\t\t *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. \n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @param  {Number}  upX\n\t\t *  @param  {Number}  upY\n\t\t *  @param  {Number}  upZ\n\t\t *  @return {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {\n\t        if (this.context.listener.forwardX) {\n\t            var now = this.now();\n\t            this.context.listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this.context.listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this.context.listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t            this.context.listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);\n\t            this.context.listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);\n\t            this.context.listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);\n\t        } else {\n\t            this.context.listener.setOrientation(x, y, z, upX, upY, upZ);\n\t        }\n\t        this._orientation = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The x position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionX', {\n\t        set: function (pos) {\n\t            this._position[0] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionY', {\n\t        set: function (pos) {\n\t            this._position[1] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {\n\t        set: function (pos) {\n\t            this._position[2] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {\n\t        set: function (pos) {\n\t            this._orientation[0] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {\n\t        set: function (pos) {\n\t            this._orientation[1] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {\n\t        set: function (pos) {\n\t            this._orientation[2] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upX', {\n\t        set: function (pos) {\n\t            this._orientation[3] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[3];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upY', {\n\t        set: function (pos) {\n\t            this._orientation[4] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[4];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upZ', {\n\t        set: function (pos) {\n\t            this._orientation[5] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[5];\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.dispose = function () {\n\t        this._orientation = null;\n\t        this._position = null;\n\t        return this;\n\t    };\n\t    //SINGLETON SETUP\n\t    var ListenerConstructor = Tone.Listener;\n\t    Tone.Listener = new ListenerConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Listener instanceof ListenerConstructor) {\n\t            //a single listener object\n\t            Tone.Listener = context.Listener;\n\t        } else {\n\t            //make new Listener insides\n\t            Tone.Listener = new ListenerConstructor();\n\t        }\n\t        context.Listener = Tone.Listener;\n\t    });\n\t    //END SINGLETON SETUP\n\t    return Tone.Listener;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  shim\n\t\t *  @private\n\t\t */\n\t    if (!window.hasOwnProperty('OfflineAudioContext') && window.hasOwnProperty('webkitOfflineAudioContext')) {\n\t        window.OfflineAudioContext = window.webkitOfflineAudioContext;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the OfflineAudioContext\n\t\t *  @extends {Tone.Context\n\t\t *  @param  {Number}  channels  The number of channels to render\n\t\t *  @param  {Number}  duration  The duration to render in samples\n\t\t *  @param {Number} sampleRate the sample rate to render at\n\t\t */\n\t    Tone.OfflineContext = function (channels, duration, sampleRate) {\n\t        /**\n\t\t\t *  The offline context\n\t\t\t *  @private\n\t\t\t *  @type  {OfflineAudioContext}\n\t\t\t */\n\t        var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate);\n\t        //wrap the methods/members\n\t        Tone.Context.call(this, offlineContext);\n\t        /**\n\t\t\t *  A private reference to the duration\n\t\t\t *  @private\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this._duration = duration;\n\t        /**\n\t\t\t *  An artificial clock source\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._currentTime = 0;\n\t        //modify the lookAhead and updateInterval to one block\n\t        this.lookAhead = this.blockTime;\n\t        this.updateInterval = this.blockTime;\n\t    };\n\t    Tone.extend(Tone.OfflineContext, Tone.Context);\n\t    /**\n\t\t *  Override the now method to point to the internal clock time\n\t\t *  @return  {Number}\n\t\t */\n\t    Tone.OfflineContext.prototype.now = function () {\n\t        return this._currentTime;\n\t    };\n\t    /**\n\t\t *  Overwrite this method since the worker is not necessary for the offline context\n\t\t *  @private\n\t\t */\n\t    Tone.OfflineContext.prototype._createWorker = function () {\n\t        //dummy worker that does nothing\n\t        return {\n\t            postMessage: function () {\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  Render the output of the OfflineContext\n\t\t *  @return  {Promise}\n\t\t */\n\t    Tone.OfflineContext.prototype.render = function () {\n\t        while (this._duration - this._currentTime >= 0) {\n\t            //invoke all the callbacks on that time\n\t            this.emit('tick');\n\t            //increment the clock\n\t            this._currentTime += Tone.prototype.blockTime;\n\t        }\n\t        //promise returned is not yet implemented in all browsers\n\t        return new Promise(function (done) {\n\t            this._context.oncomplete = function (e) {\n\t                done(e.renderedBuffer);\n\t            };\n\t            this._context.startRendering();\n\t        }.bind(this));\n\t    };\n\t    return Tone.OfflineContext;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext. \n\t\t *  The OfflineAudioContext is capable of rendering much faster than real time in many cases. \n\t\t *  The callback function also passes in an offline instance of Tone.Transport which can be used\n\t\t *  to schedule events along the Transport. \n\t\t *  @param  {Function}  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n\t\t *  @param  {Time}  duration     the amount of time to record for.\n\t\t *  @return  {Promise}  The promise which is invoked with the Tone.Buffer of the recorded output.\n\t\t *  @example\n\t\t * //render 2 seconds of the oscillator\n\t\t * Tone.Offline(function(){\n\t\t * \t//only nodes created in this callback will be recorded\n\t\t * \tvar oscillator = new Tone.Oscillator().toMaster().start(0)\n\t\t * \t//schedule their events\n\t\t * }, 2).then(function(buffer){\n\t\t * \t//do something with the output buffer\n\t\t * })\n\t\t * @example\n\t\t * //can also schedule events along the Transport\n\t\t * //using the passed in Offline Transport\n\t\t * Tone.Offline(function(Transport){\n\t\t * \tvar osc = new Tone.Oscillator().toMaster()\n\t\t * \tTransport.schedule(function(time){\n\t\t * \t\tosc.start(time).stop(time + 0.1)\n\t\t * \t}, 1)\n\t\t * \tTransport.start(0.2)\n\t\t * }, 4).then(function(buffer){\n\t\t * \t//do something with the output buffer\n\t\t * })\n\t\t */\n\t    Tone.Offline = function (callback, duration) {\n\t        //set the OfflineAudioContext\n\t        var sampleRate = Tone.context.sampleRate;\n\t        var originalContext = Tone.context;\n\t        var context = new Tone.OfflineContext(2, duration, sampleRate);\n\t        Tone.context = context;\n\t        //invoke the callback/scheduling\n\t        callback(Tone.Transport);\n\t        //process the audio\n\t        var rendered = context.render();\n\t        //return the original AudioContext\n\t        Tone.context = originalContext;\n\t        //return the audio\n\t        return rendered.then(function (buffer) {\n\t            //wrap it in a Tone.Buffer\n\t            return new Tone.Buffer(buffer);\n\t        });\n\t    };\n\t    return Tone.Offline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * \t@class  Tone.Effect is the base class for effects. Connect the effect between\n\t\t * \t        the effectSend and effectReturn GainNodes, then control the amount of\n\t\t * \t        effect which goes to the output using the wet control.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {NormalRange|Object} [wet] The starting wet value. \n\t\t */\n\t    Tone.Effect = function () {\n\t        this.createInsOuts(1, 1);\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);\n\t        /**\n\t\t\t *  the drywet knob to control the amount of effect\n\t\t\t *  @type {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._dryWet = new Tone.CrossFade(options.wet);\n\t        /**\n\t\t\t *  The wet control is how much of the effected\n\t\t\t *  will pass through to the output. 1 = 100% effected\n\t\t\t *  signal, 0 = 100% dry signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.wet = this._dryWet.fade;\n\t        /**\n\t\t\t *  connect the effectSend to the input of hte effect\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSend = new Tone.Gain();\n\t        /**\n\t\t\t *  connect the output of the effect to the effectReturn\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturn = new Tone.Gain();\n\t        //connections\n\t        this.input.connect(this._dryWet.a);\n\t        this.input.connect(this.effectSend);\n\t        this.effectReturn.connect(this._dryWet.b);\n\t        this._dryWet.connect(this.output);\n\t        this._readOnly(['wet']);\n\t    };\n\t    Tone.extend(Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Effect.defaults = { 'wet': 1 };\n\t    /**\n\t\t *  chains the effect in between the effectSend and effectReturn\n\t\t *  @param  {Tone} effect\n\t\t *  @private\n\t\t *  @returns {Tone.Effect} this\n\t\t */\n\t    Tone.Effect.prototype.connectEffect = function (effect) {\n\t        this.effectSend.chain(effect, this.effectReturn);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Effect} this\n\t\t */\n\t    Tone.Effect.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._dryWet.dispose();\n\t        this._dryWet = null;\n\t        this.effectSend.dispose();\n\t        this.effectSend = null;\n\t        this.effectReturn.dispose();\n\t        this.effectReturn = null;\n\t        this._writable(['wet']);\n\t        this.wet = null;\n\t        return this;\n\t    };\n\t    return Tone.Effect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n\t\t *         Setting the LFO rate and depth allows for control over the filter modulation rate \n\t\t *         and depth.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Time|Object} [frequency] The rate of the LFO.\n\t\t *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation\n\t \t *  @param {Frequency=} octaves The number of octaves above the baseFrequency\n\t\t *  @example\n\t\t * //create an autofilter and start it's LFO\n\t\t * var autoFilter = new Tone.AutoFilter(\"4n\").toMaster().start();\n\t\t * //route an oscillator through the filter and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(autoFilter).start();\n\t\t */\n\t    Tone.AutoFilter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'baseFrequency',\n\t            'octaves'\n\t        ], Tone.AutoFilter.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which drives the filter cutoff\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'amplitude': options.depth\n\t        });\n\t        /**\n\t\t\t * The range of the filter modulating between the min and max frequency. \n\t\t\t * 0 = no modulation. 1 = full modulation.\n\t\t\t * @type {NormalRange}\n\t\t\t * @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        /**\n\t\t\t * How fast the filter modulates between min and max. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        /**\n\t\t\t *  The filter node\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.filter = new Tone.Filter(options.filter);\n\t        /**\n\t\t\t *  The octaves placeholder\n\t\t\t *  @type {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = 0;\n\t        //connections\n\t        this.connectEffect(this.filter);\n\t        this._lfo.connect(this.filter.frequency);\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.octaves = options.octaves;\n\t        this.baseFrequency = options.baseFrequency;\n\t    };\n\t    //extend Effect\n\t    Tone.extend(Tone.AutoFilter, Tone.Effect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoFilter.defaults = {\n\t        'frequency': 1,\n\t        'type': 'sine',\n\t        'depth': 1,\n\t        'baseFrequency': 200,\n\t        'octaves': 2.6,\n\t        'filter': {\n\t            'type': 'lowpass',\n\t            'rolloff': -12,\n\t            'Q': 1\n\t        }\n\t    };\n\t    /**\n\t\t * Start the effect.\n\t\t * @param {Time} [time=now] When the LFO will start. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.start = function (time) {\n\t        this._lfo.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the effect.\n\t\t * @param {Time} [time=now] When the LFO will stop. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.stop = function (time) {\n\t        this._lfo.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the filter to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                               Transport has started. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.sync = function (delay) {\n\t        this._lfo.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the filter from the transport.\n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.unsync = function () {\n\t        this._lfo.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the AutoFilter. \n\t\t * Possible values: \"sine\", \"square\", \"triangle\", \"sawtooth\".\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The minimum value of the filter's cutoff frequency.\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {Frequency}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._lfo.min;\n\t        },\n\t        set: function (freq) {\n\t            this._lfo.min = this.toFrequency(freq);\n\t            //and set the max\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum value of the filter's cutoff frequency. \n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (oct) {\n\t            this._octaves = oct;\n\t            this._lfo.max = this.baseFrequency * Math.pow(2, oct);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this.filter.dispose();\n\t        this.filter = null;\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. \n\t\t *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. \n\t\t *  @example\n\t\t * //create an autopanner and start it's LFO\n\t\t * var autoPanner = new Tone.AutoPanner(\"4n\").toMaster().start();\n\t\t * //route an oscillator through the panner and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(autoPanner).start();\n\t\t */\n\t    Tone.AutoPanner = function () {\n\t        var options = this.optionsObject(arguments, ['frequency'], Tone.AutoPanner.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which drives the panning\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'amplitude': options.depth,\n\t            'min': -1,\n\t            'max': 1\n\t        });\n\t        /**\n\t\t\t * The amount of panning between left and right. \n\t\t\t * 0 = always center. 1 = full range between left and right. \n\t\t\t * @type {NormalRange}\n\t\t\t * @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        /**\n\t\t\t *  the panner node which does the panning\n\t\t\t *  @type {Tone.Panner}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = new Tone.Panner();\n\t        /**\n\t\t\t * How fast the panner modulates between left and right. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        //connections\n\t        this.connectEffect(this._panner);\n\t        this._lfo.connect(this._panner.pan);\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'depth',\n\t            'frequency'\n\t        ]);\n\t    };\n\t    //extend Effect\n\t    Tone.extend(Tone.AutoPanner, Tone.Effect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoPanner.defaults = {\n\t        'frequency': 1,\n\t        'type': 'sine',\n\t        'depth': 1\n\t    };\n\t    /**\n\t\t * Start the effect.\n\t\t * @param {Time} [time=now] When the LFO will start. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.start = function (time) {\n\t        this._lfo.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the effect.\n\t\t * @param {Time} [time=now] When the LFO will stop. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.stop = function (time) {\n\t        this._lfo.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the panner to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                               Transport has started. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.sync = function (delay) {\n\t        this._lfo.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the panner from the transport\n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.unsync = function () {\n\t        this._lfo.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the AutoFilter. \n\t\t * Possible values: \"sine\", \"square\", \"triangle\", \"sawtooth\".\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this._panner.dispose();\n\t        this._panner = null;\n\t        this._writable([\n\t            'depth',\n\t            'frequency'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoPanner;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).\n\t\t *          The frequency of the filter is adjusted proportionally to the \n\t\t *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set \n\t\t *                                            to at the low point of the wah\n\t\t *  @param {Positive} [octaves] The number of octaves above the baseFrequency\n\t\t *                                the filter will sweep to when fully open\n\t\t *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for \n\t\t *                                   the incoming signal. Normal range of -40 to 0. \n\t\t *  @example\n\t\t * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();\n\t\t * //initialize the synth and connect to autowah\n\t\t * var synth = new Synth.connect(autoWah);\n\t\t * //Q value influences the effect of the wah - default is 2\n\t\t * autoWah.Q.value = 6;\n\t\t * //more audible on higher notes\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\")\n\t\t */\n\t    Tone.AutoWah = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'baseFrequency',\n\t            'octaves',\n\t            'sensitivity'\n\t        ], Tone.AutoWah.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  The envelope follower. Set the attack/release\n\t\t\t *  timing to adjust how the envelope is followed. \n\t\t\t *  @type {Tone.Follower}\n\t\t\t *  @private\n\t\t\t */\n\t        this.follower = new Tone.Follower(options.follower);\n\t        /**\n\t\t\t *  scales the follower value to the frequency domain\n\t\t\t *  @type {Tone}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);\n\t        /**\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._baseFrequency = options.baseFrequency;\n\t        /**\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  the input gain to adjust the sensitivity\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputBoost = new Tone.Gain();\n\t        /**\n\t\t\t *  @type {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._bandpass = new Tone.Filter({\n\t            'rolloff': -48,\n\t            'frequency': 0,\n\t            'Q': options.Q\n\t        });\n\t        /**\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._peaking = new Tone.Filter(0, 'peaking');\n\t        this._peaking.gain.value = options.gain;\n\t        /**\n\t\t\t * The gain of the filter.\n\t\t\t * @type {Number}\n\t\t\t * @signal\n\t\t\t */\n\t        this.gain = this._peaking.gain;\n\t        /**\n\t\t\t * The quality of the filter.\n\t\t\t * @type {Positive}\n\t\t\t * @signal\n\t\t\t */\n\t        this.Q = this._bandpass.Q;\n\t        //the control signal path\n\t        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);\n\t        this._sweepRange.connect(this._bandpass.frequency);\n\t        this._sweepRange.connect(this._peaking.frequency);\n\t        //the filtered path\n\t        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t        //set the initial value\n\t        this._setSweepRange();\n\t        this.sensitivity = options.sensitivity;\n\t        this._readOnly([\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AutoWah, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoWah.defaults = {\n\t        'baseFrequency': 100,\n\t        'octaves': 6,\n\t        'sensitivity': 0,\n\t        'Q': 2,\n\t        'gain': 2,\n\t        'follower': {\n\t            'attack': 0.3,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t * The number of octaves that the filter will sweep above the \n\t\t * baseFrequency. \n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Number}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            this._setSweepRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The base frequency from which the sweep will start from.\n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Frequency}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._baseFrequency;\n\t        },\n\t        set: function (baseFreq) {\n\t            this._baseFrequency = baseFreq;\n\t            this._setSweepRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The sensitivity to control how responsive to the input signal the filter is. \n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Decibels}\n\t\t * @name sensitivity\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {\n\t        get: function () {\n\t            return this.gainToDb(1 / this._inputBoost.gain.value);\n\t        },\n\t        set: function (sensitivy) {\n\t            this._inputBoost.gain.value = 1 / this.dbToGain(sensitivy);\n\t        }\n\t    });\n\t    /**\n\t\t *  sets the sweep range of the scaler\n\t\t *  @private\n\t\t */\n\t    Tone.AutoWah.prototype._setSweepRange = function () {\n\t        this._sweepRange.min = this._baseFrequency;\n\t        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.AutoWah} this\n\t\t */\n\t    Tone.AutoWah.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this.follower.dispose();\n\t        this.follower = null;\n\t        this._sweepRange.dispose();\n\t        this._sweepRange = null;\n\t        this._bandpass.dispose();\n\t        this._bandpass = null;\n\t        this._peaking.dispose();\n\t        this._peaking = null;\n\t        this._inputBoost.dispose();\n\t        this._inputBoost = null;\n\t        this._writable([\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t        this.gain = null;\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoWah;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. \n\t\t *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing\n\t\t *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Number} bits The number of bits to downsample the signal. Nominal range\n\t\t *                       of 1 to 8. \n\t\t *  @example\n\t\t * //initialize crusher and route a synth through it\n\t\t * var crusher = new Tone.BitCrusher(4).toMaster();\n\t\t * var synth = new Tone.MonoSynth().connect(crusher);\n\t\t */\n\t    Tone.BitCrusher = function () {\n\t        var options = this.optionsObject(arguments, ['bits'], Tone.BitCrusher.defaults);\n\t        Tone.Effect.call(this, options);\n\t        var invStepSize = 1 / Math.pow(2, options.bits - 1);\n\t        /**\n\t\t\t *  Subtract the input signal and the modulus of the input signal\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subtract = new Tone.Subtract();\n\t        /**\n\t\t\t *  The mod function\n\t\t\t *  @type  {Tone.Modulo}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulo = new Tone.Modulo(invStepSize);\n\t        /**\n\t\t\t *  keeps track of the bits\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._bits = options.bits;\n\t        //connect it up\n\t        this.effectSend.fan(this._subtract, this._modulo);\n\t        this._modulo.connect(this._subtract, 0, 1);\n\t        this._subtract.connect(this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.BitCrusher, Tone.Effect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.BitCrusher.defaults = { 'bits': 4 };\n\t    /**\n\t\t * The bit depth of the effect. Nominal range of 1-8. \n\t\t * @memberOf Tone.BitCrusher#\n\t\t * @type {number}\n\t\t * @name bits\n\t\t */\n\t    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {\n\t        get: function () {\n\t            return this._bits;\n\t        },\n\t        set: function (bits) {\n\t            this._bits = bits;\n\t            var invStepSize = 1 / Math.pow(2, bits - 1);\n\t            this._modulo.value = invStepSize;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.BitCrusher} this\n\t\t */\n\t    Tone.BitCrusher.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._subtract.dispose();\n\t        this._subtract = null;\n\t        this._modulo.dispose();\n\t        this._modulo = null;\n\t        return this;\n\t    };\n\t    return Tone.BitCrusher;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good \n\t\t *         for making different types of distortion sounds.\n\t\t *         Note that odd orders sound very different from even ones, \n\t\t *         and order = 1 is no change. \n\t\t *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. \n\t\t *  @example\n\t\t * //create a new cheby\n\t\t * var cheby = new Tone.Chebyshev(50);\n\t\t * //create a monosynth connected to our cheby\n\t\t * synth = new Tone.MonoSynth().connect(cheby);\n\t\t */\n\t    Tone.Chebyshev = function () {\n\t        var options = this.optionsObject(arguments, ['order'], Tone.Chebyshev.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(4096);\n\t        /**\n\t\t\t * holds onto the order of the filter\n\t\t\t * @type {number}\n\t\t\t * @private\n\t\t\t */\n\t        this._order = options.order;\n\t        this.connectEffect(this._shaper);\n\t        this.order = options.order;\n\t        this.oversample = options.oversample;\n\t    };\n\t    Tone.extend(Tone.Chebyshev, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Chebyshev.defaults = {\n\t        'order': 1,\n\t        'oversample': 'none'\n\t    };\n\t    /**\n\t\t *  get the coefficient for that degree\n\t\t *  @param {number} x the x value\n\t\t *  @param   {number} degree \n\t\t *  @param {Object} memo memoize the computed value. \n\t\t *                       this speeds up computation greatly. \n\t\t *  @return  {number}       the coefficient \n\t\t *  @private\n\t\t */\n\t    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {\n\t        if (memo.hasOwnProperty(degree)) {\n\t            return memo[degree];\n\t        } else if (degree === 0) {\n\t            memo[degree] = 0;\n\t        } else if (degree === 1) {\n\t            memo[degree] = x;\n\t        } else {\n\t            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);\n\t        }\n\t        return memo[degree];\n\t    };\n\t    /**\n\t\t * The order of the Chebyshev polynomial which creates\n\t\t * the equation which is applied to the incoming \n\t\t * signal through a Tone.WaveShaper. The equations\n\t\t * are in the form:<br>\n\t\t * order 2: 2x^2 + 1<br>\n\t\t * order 3: 4x^3 + 3x <br>\n\t\t * @memberOf Tone.Chebyshev#\n\t\t * @type {Positive}\n\t\t * @name order\n\t\t */\n\t    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {\n\t        get: function () {\n\t            return this._order;\n\t        },\n\t        set: function (order) {\n\t            this._order = order;\n\t            var curve = new Array(4096);\n\t            var len = curve.length;\n\t            for (var i = 0; i < len; ++i) {\n\t                var x = i * 2 / len - 1;\n\t                if (x === 0) {\n\t                    //should output 0 when input is 0\n\t                    curve[i] = 0;\n\t                } else {\n\t                    curve[i] = this._getCoefficient(x, order, {});\n\t                }\n\t            }\n\t            this._shaper.curve = curve;\n\t        }\n\t    });\n\t    /**\n\t\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t\t * @memberOf Tone.Chebyshev#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            this._shaper.oversample = oversampling;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Chebyshev} this\n\t\t */\n\t    Tone.Chebyshev.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        return this;\n\t    };\n\t    return Tone.Chebyshev;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R. \n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.Effect}\n\t\t */\n\t    Tone.StereoEffect = function () {\n\t        this.createInsOuts(1, 1);\n\t        //get the defaults\n\t        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);\n\t        /**\n\t\t\t *  the drywet knob to control the amount of effect\n\t\t\t *  @type {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._dryWet = new Tone.CrossFade(options.wet);\n\t        /**\n\t\t\t *  The wet control, i.e. how much of the effected\n\t\t\t *  will pass through to the output. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.wet = this._dryWet.fade;\n\t        /**\n\t\t\t *  then split it\n\t\t\t *  @type {Tone.Split}\n\t\t\t *  @private\n\t\t\t */\n\t        this._split = new Tone.Split();\n\t        /**\n\t\t\t *  the effects send LEFT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSendL = this._split.left;\n\t        /**\n\t\t\t *  the effects send RIGHT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSendR = this._split.right;\n\t        /**\n\t\t\t *  the stereo effect merger\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = new Tone.Merge();\n\t        /**\n\t\t\t *  the effect return LEFT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturnL = this._merge.left;\n\t        /**\n\t\t\t *  the effect return RIGHT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturnR = this._merge.right;\n\t        //connections\n\t        this.input.connect(this._split);\n\t        //dry wet connections\n\t        this.input.connect(this._dryWet, 0, 0);\n\t        this._merge.connect(this._dryWet, 0, 1);\n\t        this._dryWet.connect(this.output);\n\t        this._readOnly(['wet']);\n\t    };\n\t    Tone.extend(Tone.StereoEffect, Tone.Effect);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.StereoEffect} this\n\t\t */\n\t    Tone.StereoEffect.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._dryWet.dispose();\n\t        this._dryWet = null;\n\t        this._split.dispose();\n\t        this._split = null;\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        this.effectSendL = null;\n\t        this.effectSendR = null;\n\t        this.effectReturnL = null;\n\t        this.effectReturnR = null;\n\t        this._writable(['wet']);\n\t        this.wet = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * \t@class  Tone.FeedbackEffect provides a loop between an \n\t\t * \t        audio source and its own output. This is a base-class\n\t\t * \t        for feedback effects. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {NormalRange|Object} [feedback] The initial feedback value.\n\t\t */\n\t    Tone.FeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback']);\n\t        options = this.defaultArg(options, Tone.FeedbackEffect.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the gain which controls the feedback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of signal which is fed back into the effect input. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = this._feedbackGain.gain;\n\t        //the feedback loop\n\t        this.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.FeedbackEffect, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.FeedbackEffect} this\n\t\t */\n\t    Tone.FeedbackEffect.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this._feedbackGain.dispose();\n\t        this._feedbackGain = null;\n\t        this.feedback = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Just like a stereo feedback effect, but the feedback is routed from left to right\n\t\t *         and right to left instead of on the same channel.\n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.FeedbackEffect}\n\t\t */\n\t    Tone.StereoXFeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The amount of feedback from the output\n\t\t\t *  back into the input of the effect (routed\n\t\t\t *  across left and right channels).\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  the left side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackLR = new Tone.Gain();\n\t        /**\n\t\t\t *  the right side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackRL = new Tone.Gain();\n\t        //connect it up\n\t        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);\n\t        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);\n\t        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.StereoXFeedbackEffect, Tone.FeedbackEffect);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.StereoXFeedbackEffect} this\n\t\t */\n\t    Tone.StereoXFeedbackEffect.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this.feedback.dispose();\n\t        this.feedback = null;\n\t        this._feedbackLR.dispose();\n\t        this._feedbackLR = null;\n\t        this._feedbackRL.dispose();\n\t        this._feedbackRL = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoXFeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Chorus is a stereo chorus effect with feedback composed of \n\t\t *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. \n\t\t *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n\t\t *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.StereoXFeedbackEffect}\n\t\t *\t@param {Frequency|Object} [frequency] The frequency of the LFO.\n\t\t *\t@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. \n\t\t *\t@param {NormalRange} [depth] The depth of the chorus.\n\t\t *\t@example\n\t\t * var chorus = new Tone.Chorus(4, 2.5, 0.5);\n\t\t * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);\n\t\t * synth.triggerAttackRelease([\"C3\",\"E3\",\"G3\"], \"8n\");\n\t\t */\n\t    Tone.Chorus = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'delayTime',\n\t            'depth'\n\t        ], Tone.Chorus.defaults);\n\t        Tone.StereoXFeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the depth of the chorus\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._depth = options.depth;\n\t        /**\n\t\t\t *  the delayTime\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayTime = options.delayTime / 1000;\n\t        /**\n\t\t\t *  the lfo which controls the delayTime\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'min': 0,\n\t            'max': 1\n\t        });\n\t        /**\n\t\t\t *  another LFO for the right side with a 180 degree phase diff\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'min': 0,\n\t            'max': 1,\n\t            'phase': 180\n\t        });\n\t        /**\n\t\t\t *  delay for left\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNodeL = new Tone.Delay();\n\t        /**\n\t\t\t *  delay for right\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNodeR = new Tone.Delay();\n\t        /**\n\t\t\t * The frequency of the LFO which modulates the delayTime. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfoL.frequency;\n\t        //connections\n\t        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);\n\t        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);\n\t        //and pass through to make the detune apparent\n\t        this.effectSendL.connect(this.effectReturnL);\n\t        this.effectSendR.connect(this.effectReturnR);\n\t        //lfo setup\n\t        this._lfoL.connect(this._delayNodeL.delayTime);\n\t        this._lfoR.connect(this._delayNodeR.delayTime);\n\t        //start the lfo\n\t        this._lfoL.start();\n\t        this._lfoR.start();\n\t        //have one LFO frequency control the other\n\t        this._lfoL.frequency.connect(this._lfoR.frequency);\n\t        //set the initial values\n\t        this.depth = this._depth;\n\t        this.frequency.value = options.frequency;\n\t        this.type = options.type;\n\t        this._readOnly(['frequency']);\n\t        this.spread = options.spread;\n\t    };\n\t    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Chorus.defaults = {\n\t        'frequency': 1.5,\n\t        'delayTime': 3.5,\n\t        'depth': 0.7,\n\t        'feedback': 0.1,\n\t        'type': 'sine',\n\t        'spread': 180\n\t    };\n\t    /**\n\t\t * The depth of the effect. A depth of 1 makes the delayTime\n\t\t * modulate between 0 and 2*delayTime (centered around the delayTime). \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {NormalRange}\n\t\t * @name depth\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'depth', {\n\t        get: function () {\n\t            return this._depth;\n\t        },\n\t        set: function (depth) {\n\t            this._depth = depth;\n\t            var deviation = this._delayTime * depth;\n\t            this._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t            this._lfoL.max = this._delayTime + deviation;\n\t            this._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t            this._lfoR.max = this._delayTime + deviation;\n\t        }\n\t    });\n\t    /**\n\t\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t\t * will give a more pronounced effect. Nominal range a delayTime\n\t\t * is between 2 and 20ms. \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {Milliseconds}\n\t\t * @name delayTime\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {\n\t        get: function () {\n\t            return this._delayTime * 1000;\n\t        },\n\t        set: function (delayTime) {\n\t            this._delayTime = delayTime / 1000;\n\t            this.depth = this._depth;\n\t        }\n\t    });\n\t    /**\n\t\t * The oscillator type of the LFO. \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfoL.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfoL.type = type;\n\t            this._lfoR.type = type;\n\t        }\n\t    });\n\t    /** \n\t\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {Degrees}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'spread', {\n\t        get: function () {\n\t            return this._lfoR.phase - this._lfoL.phase;    //180\n\t        },\n\t        set: function (spread) {\n\t            this._lfoL.phase = 90 - spread / 2;\n\t            this._lfoR.phase = spread / 2 + 90;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Chorus} this\n\t\t */\n\t    Tone.Chorus.prototype.dispose = function () {\n\t        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        this._delayNodeL.dispose();\n\t        this._delayNodeL = null;\n\t        this._delayNodeR.dispose();\n\t        this._delayNodeR = null;\n\t        this._writable('frequency');\n\t        this.frequency = null;\n\t        return this;\n\t    };\n\t    return Tone.Chorus;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Convolver is a wrapper around the Native Web Audio \n\t\t *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n\t\t *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n\t\t *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer\n\t\t *                                           contianing the impulse response. \n\t\t *  @param {Function} onload The callback to invoke when the url is loaded.\n\t\t *  @example\n\t\t * //initializing the convolver with an impulse response\n\t\t * var convolver = new Tone.Convolver(\"./path/to/ir.wav\").toMaster();\n\t\t */\n\t    Tone.Convolver = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.Convolver.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  convolver node\n\t\t\t *  @type {ConvolverNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._convolver = this.context.createConvolver();\n\t        /**\n\t\t\t *  the convolution buffer\n\t\t\t *  @type {Tone.Buffer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = new Tone.Buffer();\n\t        if (this.isString(options.url)) {\n\t            this._buffer.load(options.url, function (buffer) {\n\t                this.buffer = buffer;\n\t                options.onload();\n\t            }.bind(this));\n\t        } else if (options.url) {\n\t            this.buffer = options.url;\n\t            options.onload();\n\t        }\n\t        this.connectEffect(this._convolver);\n\t    };\n\t    Tone.extend(Tone.Convolver, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Convolver.defaults = { 'onload': Tone.noOp };\n\t    /**\n\t\t *  The convolver's buffer\n\t\t *  @memberOf Tone.Convolver#\n\t\t *  @type {AudioBuffer}\n\t\t *  @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {\n\t        get: function () {\n\t            return this._buffer.get();\n\t        },\n\t        set: function (buffer) {\n\t            this._buffer.set(buffer);\n\t            this._convolver.buffer = this._buffer.get();\n\t        }\n\t    });\n\t    /**\n\t\t *  Load an impulse response url as an audio buffer.\n\t\t *  Decodes the audio asynchronously and invokes\n\t\t *  the callback once the audio buffer loads.\n\t\t *  @param {string} url The url of the buffer to load.\n\t\t *                      filetype support depends on the\n\t\t *                      browser.\n\t\t *  @param  {function=} callback\n\t\t *  @returns {Promise}\n\t\t */\n\t    Tone.Convolver.prototype.load = function (url, callback) {\n\t        return this._buffer.load(url, function (buff) {\n\t            this.buffer = buff;\n\t            if (callback) {\n\t                callback();\n\t            }\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Convolver} this\n\t\t */\n\t    Tone.Convolver.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._convolver.disconnect();\n\t        this._convolver = null;\n\t        this._buffer.dispose();\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    return Tone.Convolver;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.\n\t\t *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)\n\t\t *  @example\n\t\t * var dist = new Tone.Distortion(0.8).toMaster();\n\t\t * var fm = new Tone.SimpleFM().connect(dist);\n\t\t * //this sounds good on bass notes\n\t\t * fm.triggerAttackRelease(\"A1\", \"8n\");\n\t\t */\n\t    Tone.Distortion = function () {\n\t        var options = this.optionsObject(arguments, ['distortion'], Tone.Distortion.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(4096);\n\t        /**\n\t\t\t * holds the distortion amount\n\t\t\t * @type {number}\n\t\t\t * @private\n\t\t\t */\n\t        this._distortion = options.distortion;\n\t        this.connectEffect(this._shaper);\n\t        this.distortion = options.distortion;\n\t        this.oversample = options.oversample;\n\t    };\n\t    Tone.extend(Tone.Distortion, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Distortion.defaults = {\n\t        'distortion': 0.4,\n\t        'oversample': 'none'\n\t    };\n\t    /**\n\t\t * The amount of distortion.\n\t\t * @memberOf Tone.Distortion#\n\t\t * @type {NormalRange}\n\t\t * @name distortion\n\t\t */\n\t    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {\n\t        get: function () {\n\t            return this._distortion;\n\t        },\n\t        set: function (amount) {\n\t            this._distortion = amount;\n\t            var k = amount * 100;\n\t            var deg = Math.PI / 180;\n\t            this._shaper.setMap(function (x) {\n\t                if (Math.abs(x) < 0.001) {\n\t                    //should output 0 when input is 0\n\t                    return 0;\n\t                } else {\n\t                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t                }\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t\t * @memberOf Tone.Distortion#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            this._shaper.oversample = oversampling;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Distortion} this\n\t\t */\n\t    Tone.Distortion.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        return this;\n\t    };\n\t    return Tone.Distortion;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.FeedbackDelay is a DelayNode in which part of output\n\t\t *          signal is fed back into the delay. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.FeedbackEffect}\n\t\t *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. \n\t\t *  @param {NormalRange=} feedback The amount of the effected signal which \n\t\t *                            is fed back through the delay.\n\t\t *  @example\n\t\t * var feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toMaster();\n\t\t * var tom = new Tone.DrumSynth({\n\t\t * \t\"octaves\" : 4,\n\t\t * \t\"pitchDecay\" : 0.1\n\t\t * }).connect(feedbackDelay);\n\t\t * tom.triggerAttackRelease(\"A2\",\"32n\");\n\t\t */\n\t    Tone.FeedbackDelay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'feedback'\n\t        ], Tone.FeedbackDelay.defaults);\n\t        Tone.FeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The delayTime of the DelayNode. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delayNode.delayTime;\n\t        // connect it up\n\t        this.connectEffect(this._delayNode);\n\t        this._readOnly(['delayTime']);\n\t    };\n\t    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);\n\t    /**\n\t\t *  The default values. \n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FeedbackDelay} this\n\t\t */\n\t    Tone.FeedbackDelay.prototype.dispose = function () {\n\t        Tone.FeedbackEffect.prototype.dispose.call(this);\n\t        this._delayNode.dispose();\n\t        this._delayNode = null;\n\t        this._writable(['delayTime']);\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackDelay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  an array of comb filter delay values from Freeverb implementation\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterTunings = [\n\t        1557 / 44100,\n\t        1617 / 44100,\n\t        1491 / 44100,\n\t        1422 / 44100,\n\t        1277 / 44100,\n\t        1356 / 44100,\n\t        1188 / 44100,\n\t        1116 / 44100\n\t    ];\n\t    /**\n\t\t *  an array of allpass filter frequency values from Freeverb implementation\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var allpassFilterFrequencies = [\n\t        225,\n\t        556,\n\t        441,\n\t        341\n\t    ];\n\t    /**\n\t\t *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n\t\t *         Read more on reverb on [SoundOnSound](http://www.soundonsound.com/sos/may00/articles/reverb.htm).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [roomSize] Correlated to the decay time. \n\t\t *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part \n\t\t *                                 of the reverb. \n\t\t *  @example\n\t\t * var freeverb = new Tone.Freeverb().toMaster();\n\t\t * freeverb.dampening.value = 1000;\n\t\t * //routing synth through the reverb\n\t\t * var synth = new Tone.AMSynth().connect(freeverb);\n\t\t */\n\t    Tone.Freeverb = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'roomSize',\n\t            'dampening'\n\t        ], Tone.Freeverb.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The roomSize value between. A larger roomSize\n\t\t\t *  will result in a longer decay. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of dampening of the reverberant signal. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  the comb filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._combFilters = [];\n\t        /**\n\t\t\t *  the allpass filters on the left\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFiltersL = [];\n\t        /**\n\t\t\t *  the allpass filters on the right\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFiltersR = [];\n\t        //make the allpass filters on the right\n\t        for (var l = 0; l < allpassFilterFrequencies.length; l++) {\n\t            var allpassL = this.context.createBiquadFilter();\n\t            allpassL.type = 'allpass';\n\t            allpassL.frequency.value = allpassFilterFrequencies[l];\n\t            this._allpassFiltersL.push(allpassL);\n\t        }\n\t        //make the allpass filters on the left\n\t        for (var r = 0; r < allpassFilterFrequencies.length; r++) {\n\t            var allpassR = this.context.createBiquadFilter();\n\t            allpassR.type = 'allpass';\n\t            allpassR.frequency.value = allpassFilterFrequencies[r];\n\t            this._allpassFiltersR.push(allpassR);\n\t        }\n\t        //make the comb filters\n\t        for (var c = 0; c < combFilterTunings.length; c++) {\n\t            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);\n\t            if (c < combFilterTunings.length / 2) {\n\t                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);\n\t            } else {\n\t                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);\n\t            }\n\t            this.roomSize.connect(lfpf.resonance);\n\t            this.dampening.connect(lfpf.dampening);\n\t            this._combFilters.push(lfpf);\n\t        }\n\t        //chain the allpass filters togetehr\n\t        this.connectSeries.apply(this, this._allpassFiltersL);\n\t        this.connectSeries.apply(this, this._allpassFiltersR);\n\t        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);\n\t        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);\n\t        this._readOnly([\n\t            'roomSize',\n\t            'dampening'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Freeverb, Tone.StereoEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Freeverb.defaults = {\n\t        'roomSize': 0.7,\n\t        'dampening': 3000\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Freeverb} this\n\t\t */\n\t    Tone.Freeverb.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        for (var al = 0; al < this._allpassFiltersL.length; al++) {\n\t            this._allpassFiltersL[al].disconnect();\n\t            this._allpassFiltersL[al] = null;\n\t        }\n\t        this._allpassFiltersL = null;\n\t        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {\n\t            this._allpassFiltersR[ar].disconnect();\n\t            this._allpassFiltersR[ar] = null;\n\t        }\n\t        this._allpassFiltersR = null;\n\t        for (var cf = 0; cf < this._combFilters.length; cf++) {\n\t            this._combFilters[cf].dispose();\n\t            this._combFilters[cf] = null;\n\t        }\n\t        this._combFilters = null;\n\t        this._writable([\n\t            'roomSize',\n\t            'dampening'\n\t        ]);\n\t        this.roomSize.dispose();\n\t        this.roomSize = null;\n\t        this.dampening.dispose();\n\t        this.dampening = null;\n\t        return this;\n\t    };\n\t    return Tone.Freeverb;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  an array of the comb filter delay time values\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterDelayTimes = [\n\t        1687 / 25000,\n\t        1601 / 25000,\n\t        2053 / 25000,\n\t        2251 / 25000\n\t    ];\n\t    /**\n\t\t *  the resonances of each of the comb filters\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterResonances = [\n\t        0.773,\n\t        0.802,\n\t        0.753,\n\t        0.733\n\t    ];\n\t    /**\n\t\t *  the allpass filter frequencies\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var allpassFilterFreqs = [\n\t        347,\n\t        113,\n\t        37\n\t    ];\n\t    /**\n\t\t *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n\t\t *         tuned by John Chowning in 1970.\n\t\t *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. \n\t\t *         \n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.\n\t\t *  @example\n\t\t * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);\n\t\t * var delay = new Tone.FeedbackDelay(0.5); \n\t\t * //connecting the synth to reverb through delay\n\t\t * var synth = new Tone.DuoSynth().chain(delay, reverb);\n\t\t * synth.triggerAttackRelease(\"A4\",\"8n\");\n\t\t */\n\t    Tone.JCReverb = function () {\n\t        var options = this.optionsObject(arguments, ['roomSize'], Tone.JCReverb.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  room size control values between [0,1]\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  scale the room size\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);\n\t        /**\n\t\t\t *  a series of allpass filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFilters = [];\n\t        /**\n\t\t\t *  parallel feedback comb filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackCombFilters = [];\n\t        //make the allpass filters\n\t        for (var af = 0; af < allpassFilterFreqs.length; af++) {\n\t            var allpass = this.context.createBiquadFilter();\n\t            allpass.type = 'allpass';\n\t            allpass.frequency.value = allpassFilterFreqs[af];\n\t            this._allpassFilters.push(allpass);\n\t        }\n\t        //and the comb filters\n\t        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {\n\t            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);\n\t            this._scaleRoomSize.connect(fbcf.resonance);\n\t            fbcf.resonance.value = combFilterResonances[cf];\n\t            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);\n\t            if (cf < combFilterDelayTimes.length / 2) {\n\t                fbcf.connect(this.effectReturnL);\n\t            } else {\n\t                fbcf.connect(this.effectReturnR);\n\t            }\n\t            this._feedbackCombFilters.push(fbcf);\n\t        }\n\t        //chain the allpass filters together\n\t        this.roomSize.connect(this._scaleRoomSize);\n\t        this.connectSeries.apply(this, this._allpassFilters);\n\t        this.effectSendL.connect(this._allpassFilters[0]);\n\t        this.effectSendR.connect(this._allpassFilters[0]);\n\t        this._readOnly(['roomSize']);\n\t    };\n\t    Tone.extend(Tone.JCReverb, Tone.StereoEffect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.JCReverb.defaults = { 'roomSize': 0.5 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.JCReverb} this\n\t\t */\n\t    Tone.JCReverb.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        for (var apf = 0; apf < this._allpassFilters.length; apf++) {\n\t            this._allpassFilters[apf].disconnect();\n\t            this._allpassFilters[apf] = null;\n\t        }\n\t        this._allpassFilters = null;\n\t        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {\n\t            this._feedbackCombFilters[fbcf].dispose();\n\t            this._feedbackCombFilters[fbcf] = null;\n\t        }\n\t        this._feedbackCombFilters = null;\n\t        this._writable(['roomSize']);\n\t        this.roomSize.dispose();\n\t        this.roomSize = null;\n\t        this._scaleRoomSize.dispose();\n\t        this._scaleRoomSize = null;\n\t        return this;\n\t    };\n\t    return Tone.JCReverb;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels) \n\t\t *         and effects them separately before being recombined.\n\t\t *         Applies a Mid/Side seperation and recombination.\n\t\t *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n\t\t *         <br><br>\n\t\t *         This is a base-class for Mid/Side Effects. \n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideEffect = function () {\n\t        Tone.Effect.apply(this, arguments);\n\t        /**\n\t\t\t *  The mid/side split\n\t\t\t *  @type  {Tone.MidSideSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideSplit = new Tone.MidSideSplit();\n\t        /**\n\t\t\t *  The mid/side merge\n\t\t\t *  @type  {Tone.MidSideMerge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideMerge = new Tone.MidSideMerge();\n\t        /**\n\t\t\t *  The mid send. Connect to mid processing\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this.midSend = this._midSideSplit.mid;\n\t        /**\n\t\t\t *  The side send. Connect to side processing\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this.sideSend = this._midSideSplit.side;\n\t        /**\n\t\t\t *  The mid return connection\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.midReturn = this._midSideMerge.mid;\n\t        /**\n\t\t\t *  The side return connection\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.sideReturn = this._midSideMerge.side;\n\t        //the connections\n\t        this.effectSend.connect(this._midSideSplit);\n\t        this._midSideMerge.connect(this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.MidSideEffect, Tone.Effect);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.MidSideEffect} this\n\t\t */\n\t    Tone.MidSideEffect.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._midSideSplit.dispose();\n\t        this._midSideSplit = null;\n\t        this._midSideMerge.dispose();\n\t        this._midSideMerge = null;\n\t        this.midSend = null;\n\t        this.sideSend = null;\n\t        this.midReturn = null;\n\t        this.sideReturn = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase\n\t\t *         of different frequency components of an incoming signal. Read more on \n\t\t *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). \n\t\t *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n\t\t *\n\t\t *\t@extends {Tone.StereoEffect}\n\t\t *\t@constructor\n\t\t *\t@param {Frequency|Object} [frequency] The speed of the phasing. \n\t\t *\t@param {number} [octaves] The octaves of the effect. \n\t\t *\t@param {Frequency} [baseFrequency] The base frequency of the filters. \n\t\t *\t@example\n\t\t * var phaser = new Tone.Phaser({\n\t\t * \t\"frequency\" : 15, \n\t\t * \t\"octaves\" : 5, \n\t\t * \t\"baseFrequency\" : 1000\n\t\t * }).toMaster();\n\t\t * var synth = new Tone.FMSynth().connect(phaser);\n\t\t * synth.triggerAttackRelease(\"E3\", \"2n\");\n\t\t */\n\t    Tone.Phaser = function () {\n\t        //set the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'octaves',\n\t            'baseFrequency'\n\t        ], Tone.Phaser.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which controls the frequency on the left side\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO(options.frequency, 0, 1);\n\t        /**\n\t\t\t *  the lfo which controls the frequency on the right side\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO(options.frequency, 0, 1);\n\t        this._lfoR.phase = 180;\n\t        /**\n\t\t\t *  the base modulation frequency\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._baseFrequency = options.baseFrequency;\n\t        /**\n\t\t\t *  the octaves of the phasing\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  The quality factor of the filters\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);\n\t        /**\n\t\t\t *  the array of filters for the left side\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);\n\t        /**\n\t\t\t *  the array of filters for the left side\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);\n\t        /**\n\t\t\t * the frequency of the effect\n\t\t\t * @type {Tone.Signal}\n\t\t\t */\n\t        this.frequency = this._lfoL.frequency;\n\t        this.frequency.value = options.frequency;\n\t        //connect them up\n\t        this.effectSendL.connect(this._filtersL[0]);\n\t        this.effectSendR.connect(this._filtersR[0]);\n\t        this._filtersL[options.stages - 1].connect(this.effectReturnL);\n\t        this._filtersR[options.stages - 1].connect(this.effectReturnR);\n\t        //control the frequency with one LFO\n\t        this._lfoL.frequency.connect(this._lfoR.frequency);\n\t        //set the options\n\t        this.baseFrequency = options.baseFrequency;\n\t        this.octaves = options.octaves;\n\t        //start the lfo\n\t        this._lfoL.start();\n\t        this._lfoR.start();\n\t        this._readOnly([\n\t            'frequency',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Phaser, Tone.StereoEffect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {object}\n\t\t */\n\t    Tone.Phaser.defaults = {\n\t        'frequency': 0.5,\n\t        'octaves': 3,\n\t        'stages': 10,\n\t        'Q': 10,\n\t        'baseFrequency': 350\n\t    };\n\t    /**\n\t\t *  @param {number} stages\n\t\t *  @returns {Array} the number of filters all connected together\n\t\t *  @private\n\t\t */\n\t    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {\n\t        var filters = new Array(stages);\n\t        //make all the filters\n\t        for (var i = 0; i < stages; i++) {\n\t            var filter = this.context.createBiquadFilter();\n\t            filter.type = 'allpass';\n\t            Q.connect(filter.Q);\n\t            connectToFreq.connect(filter.frequency);\n\t            filters[i] = filter;\n\t        }\n\t        this.connectSeries.apply(this, filters);\n\t        return filters;\n\t    };\n\t    /**\n\t\t * The number of octaves the phase goes above\n\t\t * the baseFrequency\n\t\t * @memberOf Tone.Phaser#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            var max = this._baseFrequency * Math.pow(2, octaves);\n\t            this._lfoL.max = max;\n\t            this._lfoR.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The the base frequency of the filters. \n\t\t * @memberOf Tone.Phaser#\n\t\t * @type {number}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._baseFrequency;\n\t        },\n\t        set: function (freq) {\n\t            this._baseFrequency = freq;\n\t            this._lfoL.min = freq;\n\t            this._lfoR.min = freq;\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Phaser} this\n\t\t */\n\t    Tone.Phaser.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'Q'\n\t        ]);\n\t        this.Q.dispose();\n\t        this.Q = null;\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        for (var i = 0; i < this._filtersL.length; i++) {\n\t            this._filtersL[i].disconnect();\n\t            this._filtersL[i] = null;\n\t        }\n\t        this._filtersL = null;\n\t        for (var j = 0; j < this._filtersR.length; j++) {\n\t            this._filtersR[j].disconnect();\n\t            this._filtersR[j] = null;\n\t        }\n\t        this._filtersR = null;\n\t        this.frequency = null;\n\t        return this;\n\t    };\n\t    return Tone.Phaser;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard\n\t\t *          first in one channel and next in the opposite channel. In a stereo\n\t\t *          system these are the right and left channels.\n\t\t *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays \n\t\t *          with independent delay values. Each delay is routed to one channel\n\t\t *          (left or right), and the channel triggered second will always \n\t\t *          trigger at the same interval after the first.\n\t\t *\n\t\t * \t@constructor\n\t\t * \t@extends {Tone.StereoXFeedbackEffect}\n\t\t *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.\n\t\t *  @param {NormalRange=} feedback The amount of the effected signal which \n\t\t *                                 is fed back through the delay.\n\t\t *  @example\n\t\t * var pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toMaster();\n\t\t * var drum = new Tone.DrumSynth().connect(pingPong);\n\t\t * drum.triggerAttackRelease(\"C4\", \"32n\");\n\t\t */\n\t    Tone.PingPongDelay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'feedback'\n\t        ], Tone.PingPongDelay.defaults);\n\t        Tone.StereoXFeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the delay node on the left side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the delay node on the right side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the predelay on the right side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the delay time signal\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);\n\t        //connect it up\n\t        this.effectSendL.chain(this._leftDelay, this.effectReturnL);\n\t        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);\n\t        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n\t        //rearranged the feedback to be after the rightPreDelay\n\t        this._feedbackLR.disconnect();\n\t        this._feedbackLR.connect(this._rightDelay);\n\t        this._readOnly(['delayTime']);\n\t    };\n\t    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PingPongDelay.defaults = {\n\t        'delayTime': 0.25,\n\t        'maxDelayTime': 1\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.PingPongDelay} this\n\t\t */\n\t    Tone.PingPongDelay.prototype.dispose = function () {\n\t        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);\n\t        this._leftDelay.dispose();\n\t        this._leftDelay = null;\n\t        this._rightDelay.dispose();\n\t        this._rightDelay = null;\n\t        this._rightPreDelay.dispose();\n\t        this._rightPreDelay = null;\n\t        this._writable(['delayTime']);\n\t        this.delayTime.dispose();\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.PingPongDelay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. \n\t\t *         The effect is achieved by speeding up or slowing down the delayTime\n\t\t *         of a DelayNode using a sawtooth wave. \n\t\t *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n\t\t *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n\t\t *         \n\t\t *  @extends {Tone.FeedbackEffect}\n\t\t *  @param {Interval=} pitch The interval to transpose the incoming signal by. \n\t\t */\n\t    Tone.PitchShift = function () {\n\t        var options = this.optionsObject(arguments, ['pitch'], Tone.PitchShift.defaults);\n\t        Tone.FeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  The pitch signal\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._frequency = new Tone.Signal(0);\n\t        /**\n\t\t\t *  Uses two DelayNodes to cover up the jump in\n\t\t\t *  the sawtooth wave. \n\t\t\t *  @type  {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayA = new Tone.Delay(0, 1);\n\t        /**\n\t\t\t *  The first LFO.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoA = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 0.1,\n\t            'type': 'sawtooth'\n\t        }).connect(this._delayA.delayTime);\n\t        /**\n\t\t\t *  The second DelayNode\n\t\t\t *  @type  {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayB = new Tone.Delay(0, 1);\n\t        /**\n\t\t\t *  The first LFO.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoB = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 0.1,\n\t            'type': 'sawtooth',\n\t            'phase': 180\n\t        }).connect(this._delayB.delayTime);\n\t        /**\n\t\t\t *  Crossfade quickly between the two delay lines\n\t\t\t *  to cover up the jump in the sawtooth wave\n\t\t\t *  @type  {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._crossFade = new Tone.CrossFade();\n\t        /**\n\t\t\t *  LFO which alternates between the two\n\t\t\t *  delay lines to cover up the disparity in the\n\t\t\t *  sawtooth wave. \n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._crossFadeLFO = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 1,\n\t            'type': 'triangle',\n\t            'phase': 90\n\t        }).connect(this._crossFade.fade);\n\t        /**\n\t\t\t *  The delay node\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackDelay = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The amount of delay on the input signal\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._feedbackDelay.delayTime;\n\t        this._readOnly('delayTime');\n\t        /**\n\t\t\t *  Hold the current pitch\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pitch = options.pitch;\n\t        /**\n\t\t\t *  Hold the current windowSize\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._windowSize = options.windowSize;\n\t        //connect the two delay lines up\n\t        this._delayA.connect(this._crossFade.a);\n\t        this._delayB.connect(this._crossFade.b);\n\t        //connect the frequency\n\t        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);\n\t        //route the input\n\t        this.effectSend.fan(this._delayA, this._delayB);\n\t        this._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t        //start the LFOs at the same time\n\t        var now = this.now();\n\t        this._lfoA.start(now);\n\t        this._lfoB.start(now);\n\t        this._crossFadeLFO.start(now);\n\t        //set the initial value\n\t        this.windowSize = this._windowSize;\n\t    };\n\t    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.PitchShift.defaults = {\n\t        'pitch': 0,\n\t        'windowSize': 0.1,\n\t        'delayTime': 0,\n\t        'feedback': 0\n\t    };\n\t    /**\n\t\t * Repitch the incoming signal by some interval (measured\n\t\t * in semi-tones). \n\t\t * @memberOf Tone.PitchShift#\n\t\t * @type {Interval}\n\t\t * @name pitch\n\t\t * @example\n\t\t * pitchShift.pitch = -12; //down one octave\n\t\t * pitchShift.pitch = 7; //up a fifth\n\t\t */\n\t    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {\n\t        get: function () {\n\t            return this._pitch;\n\t        },\n\t        set: function (interval) {\n\t            this._pitch = interval;\n\t            var factor = 0;\n\t            if (interval < 0) {\n\t                this._lfoA.min = 0;\n\t                this._lfoA.max = this._windowSize;\n\t                this._lfoB.min = 0;\n\t                this._lfoB.max = this._windowSize;\n\t                factor = this.intervalToFrequencyRatio(interval - 1) + 1;\n\t            } else {\n\t                this._lfoA.min = this._windowSize;\n\t                this._lfoA.max = 0;\n\t                this._lfoB.min = this._windowSize;\n\t                this._lfoB.max = 0;\n\t                factor = this.intervalToFrequencyRatio(interval) - 1;\n\t            }\n\t            this._frequency.value = factor * (1.2 / this._windowSize);\n\t        }\n\t    });\n\t    /**\n\t\t * The window size corresponds roughly to the sample length in a looping sampler. \n\t\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t\t * signal, but larger values will result in smoother pitch shifting for larger intervals. \n\t\t * A nominal range of 0.03 to 0.1 is recommended. \n\t\t * @memberOf Tone.PitchShift#\n\t\t * @type {Time}\n\t\t * @name windowSize\n\t\t * @example\n\t\t * pitchShift.windowSize = 0.1;\n\t\t */\n\t    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {\n\t        get: function () {\n\t            return this._windowSize;\n\t        },\n\t        set: function (size) {\n\t            this._windowSize = this.toSeconds(size);\n\t            this.pitch = this._pitch;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.PitchShift}  this\n\t\t */\n\t    Tone.PitchShift.prototype.dispose = function () {\n\t        Tone.FeedbackEffect.prototype.dispose.call(this);\n\t        this._frequency.dispose();\n\t        this._frequency = null;\n\t        this._delayA.disconnect();\n\t        this._delayA = null;\n\t        this._delayB.disconnect();\n\t        this._delayB = null;\n\t        this._lfoA.dispose();\n\t        this._lfoA = null;\n\t        this._lfoB.dispose();\n\t        this._lfoB = null;\n\t        this._crossFade.dispose();\n\t        this._crossFade = null;\n\t        this._crossFadeLFO.dispose();\n\t        this._crossFadeLFO = null;\n\t        this._writable('delayTime');\n\t        this._feedbackDelay.dispose();\n\t        this._feedbackDelay = null;\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.PitchShift;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Base class for stereo feedback effects where the effectReturn\n\t\t *         is fed back into the same channel. \n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.FeedbackEffect}\n\t\t */\n\t    Tone.StereoFeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  controls the amount of feedback\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  the left side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackL = new Tone.Gain();\n\t        /**\n\t\t\t *  the right side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackR = new Tone.Gain();\n\t        //connect it up\n\t        this.effectReturnL.chain(this._feedbackL, this.effectSendL);\n\t        this.effectReturnR.chain(this._feedbackR, this.effectSendR);\n\t        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.StereoFeedbackEffect, Tone.FeedbackEffect);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.StereoFeedbackEffect} this\n\t\t */\n\t    Tone.StereoFeedbackEffect.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this.feedback.dispose();\n\t        this.feedback = null;\n\t        this._feedbackL.dispose();\n\t        this._feedbackL = null;\n\t        this._feedbackR.dispose();\n\t        this._feedbackR = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoFeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Applies a width factor to the mid/side seperation. \n\t\t *         0 is all mid and 1 is all side.\n\t\t *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n\t\t *         <br><br>\n\t\t *         <code>\n\t\t *         Mid *= 2*(1-width)<br>\n\t\t *         Side *= 2*width\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone.MidSideEffect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t\t */\n\t    Tone.StereoWidener = function () {\n\t        var options = this.optionsObject(arguments, ['width'], Tone.StereoWidener.defaults);\n\t        Tone.MidSideEffect.call(this, options);\n\t        /**\n\t\t\t *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  Mid multiplier\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');\n\t        /**\n\t\t\t *  Side multiplier\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');\n\t        /**\n\t\t\t *  constant output of 2\n\t\t\t *  @type {Tone}\n\t\t\t *  @private\n\t\t\t */\n\t        this._two = new Tone.Signal(2);\n\t        //the mid chain\n\t        this._two.connect(this._midMult, 0, 1);\n\t        this.width.connect(this._midMult, 0, 2);\n\t        //the side chain\n\t        this._two.connect(this._sideMult, 0, 1);\n\t        this.width.connect(this._sideMult, 0, 2);\n\t        //connect it to the effect send/return\n\t        this.midSend.chain(this._midMult, this.midReturn);\n\t        this.sideSend.chain(this._sideMult, this.sideReturn);\n\t        this._readOnly(['width']);\n\t    };\n\t    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.StereoWidener.defaults = { 'width': 0.5 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.StereoWidener} this\n\t\t */\n\t    Tone.StereoWidener.prototype.dispose = function () {\n\t        Tone.MidSideEffect.prototype.dispose.call(this);\n\t        this._writable(['width']);\n\t        this.width.dispose();\n\t        this.width = null;\n\t        this._midMult.dispose();\n\t        this._midMult = null;\n\t        this._sideMult.dispose();\n\t        this._sideMult = null;\n\t        this._two.dispose();\n\t        this._two = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoWidener;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.\n\t\t *         The type, frequency, and depth of the LFO is controllable.\n\t\t *\n\t\t *  @extends {Tone.StereoEffect}\n\t\t *  @constructor\n\t\t *  @param {Frequency} [frequency] The rate of the effect.\n\t\t *  @param {NormalRange} [depth] The depth of the effect.\n\t\t *  @example\n\t\t * //create a tremolo and start it's LFO\n\t\t * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();\n\t\t * //route an oscillator through the tremolo and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(tremolo).start();\n\t\t */\n\t    Tone.Tremolo = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'depth'\n\t        ], Tone.Tremolo.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The tremelo LFO in the left channel\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO({\n\t            'phase': options.spread,\n\t            'min': 1,\n\t            'max': 0\n\t        });\n\t        /**\n\t\t\t *  The tremelo LFO in the left channel\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO({\n\t            'phase': options.spread,\n\t            'min': 1,\n\t            'max': 0\n\t        });\n\t        /**\n\t\t\t *  Where the gain is multiplied\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitudeL = new Tone.Gain();\n\t        /**\n\t\t\t *  Where the gain is multiplied\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitudeR = new Tone.Gain();\n\t        /**\n\t\t\t *  The frequency of the tremolo.\n\t\t\t *  @type  {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The depth of the effect. A depth of 0, has no effect\n\t\t\t *  on the amplitude, and a depth of 1 makes the amplitude\n\t\t\t *  modulate fully between 0 and 1.\n\t\t\t *  @type  {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);\n\t        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);\n\t        this._lfoL.connect(this._amplitudeL.gain);\n\t        this._lfoR.connect(this._amplitudeR.gain);\n\t        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t        this.type = options.type;\n\t        this.spread = options.spread;\n\t    };\n\t    Tone.extend(Tone.Tremolo, Tone.StereoEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Tremolo.defaults = {\n\t        'frequency': 10,\n\t        'type': 'sine',\n\t        'depth': 0.5,\n\t        'spread': 180\n\t    };\n\t    /**\n\t\t * Start the tremolo.\n\t\t * @param {Time} [time=now] When the tremolo begins.\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.start = function (time) {\n\t        this._lfoL.start(time);\n\t        this._lfoR.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the tremolo.\n\t\t * @param {Time} [time=now] When the tremolo stops.\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.stop = function (time) {\n\t        this._lfoL.stop(time);\n\t        this._lfoR.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the effect to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                              Transport has started.\n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.Tremolo.prototype.sync = function (delay) {\n\t        this._lfoL.sync(delay);\n\t        this._lfoR.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the filter from the transport\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.unsync = function () {\n\t        this._lfoL.unsync();\n\t        this._lfoR.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * The Tremolo's oscillator type.\n\t\t * @memberOf Tone.Tremolo#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Tremolo.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfoL.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfoL.type = type;\n\t            this._lfoR.type = type;\n\t        }\n\t    });\n\t    /** \n\t\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t\t * @memberOf Tone.Tremolo#\n\t\t * @type {Degrees}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {\n\t        get: function () {\n\t            return this._lfoR.phase - this._lfoL.phase;    //180\n\t        },\n\t        set: function (spread) {\n\t            this._lfoL.phase = 90 - spread / 2;\n\t            this._lfoR.phase = spread / 2 + 90;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        this._amplitudeL.dispose();\n\t        this._amplitudeL = null;\n\t        this._amplitudeR.dispose();\n\t        this._amplitudeR = null;\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.Tremolo;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n\t\t *         modulates the delayTime of the delay, causing the pitch to rise\n\t\t *         and fall. \n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency} frequency The frequency of the vibrato.\n\t\t *  @param {NormalRange} depth The amount the pitch is modulated.\n\t\t */\n\t    Tone.Vibrato = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'depth'\n\t        ], Tone.Vibrato.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  The delay node used for the vibrato effect\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = new Tone.Delay(0, options.maxDelay);\n\t        /**\n\t\t\t *  The LFO used to control the vibrato\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'type': options.type,\n\t            'min': 0,\n\t            'max': options.maxDelay,\n\t            'frequency': options.frequency,\n\t            'phase': -90    //offse the phase so the resting position is in the center\n\t        }).start().connect(this._delayNode.delayTime);\n\t        /**\n\t\t\t *  The frequency of the vibrato\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        /**\n\t\t\t *  The depth of the vibrato. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        this.depth.value = options.depth;\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.effectSend.chain(this._delayNode, this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.Vibrato, Tone.Effect);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Vibrato.defaults = {\n\t        'maxDelay': 0.005,\n\t        'frequency': 5,\n\t        'depth': 0.1,\n\t        'type': 'sine'\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the Vibrato.\n\t\t * @memberOf Tone.Vibrato#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Vibrato.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Vibrato} this\n\t\t */\n\t    Tone.Vibrato.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._delayNode.dispose();\n\t        this._delayNode = null;\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t    };\n\t    return Tone.Vibrato;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable\n\t\t *          callback for a single or repeatable events along the timeline. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @param {function} callback The callback to invoke at the time. \n\t\t *  @param {*} value The value or values which should be passed to\n\t\t *                      the callback function on invocation.  \n\t\t *  @example\n\t\t * var chord = new Tone.Event(function(time, chord){\n\t\t * \t//the chord as well as the exact time of the event\n\t\t * \t//are passed in as arguments to the callback function\n\t\t * }, [\"D4\", \"E4\", \"F4\"]);\n\t\t * //start the chord at the beginning of the transport timeline\n\t\t * chord.start();\n\t\t * //loop it every measure for 8 measures\n\t\t * chord.loop = 8;\n\t\t * chord.loopEnd = \"1m\";\n\t\t */\n\t    Tone.Event = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'value'\n\t        ], Tone.Event.defaults);\n\t        /**\n\t\t\t *  Loop value\n\t\t\t *  @type  {Boolean|Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  The callback to invoke. \n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  The value which is passed to the\n\t\t\t *  callback function.\n\t\t\t *  @type  {*}\n\t\t\t *  @private\n\t\t\t */\n\t        this.value = options.value;\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = this.toTicks(options.loopStart);\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = this.toTicks(options.loopEnd);\n\t        /**\n\t\t\t *  Tracks the scheduled events\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  The playback speed of the note. A speed of 1\n\t\t\t *  is no change. \n\t\t\t *  @private\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this._playbackRate = 1;\n\t        /**\n\t\t\t *  A delay time from when the event is scheduled to start\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startOffset = 0;\n\t        /**\n\t\t\t *  The probability that the callback will be invoked\n\t\t\t *  at the scheduled time. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @example\n\t\t\t * //the callback will be invoked 50% of the time\n\t\t\t * event.probability = 0.5;\n\t\t\t */\n\t        this.probability = options.probability;\n\t        /**\n\t\t\t *  If set to true, will apply small (+/-0.02 seconds) random variation\n\t\t\t *  to the callback time. If the value is given as a time, it will randomize\n\t\t\t *  by that amount.\n\t\t\t *  @example\n\t\t\t * event.humanize = true;\n\t\t\t *  @type {Boolean|Time}\n\t\t\t */\n\t        this.humanize = options.humanize;\n\t        /**\n\t\t\t *  If mute is true, the callback won't be\n\t\t\t *  invoked.\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.mute = options.mute;\n\t        //set the initial values\n\t        this.playbackRate = options.playbackRate;\n\t    };\n\t    Tone.extend(Tone.Event);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Event.defaults = {\n\t        'callback': Tone.noOp,\n\t        'loop': false,\n\t        'loopEnd': '1m',\n\t        'loopStart': 0,\n\t        'playbackRate': 1,\n\t        'value': null,\n\t        'probability': 1,\n\t        'mute': false,\n\t        'humanize': false\n\t    };\n\t    /**\n\t\t *  Reschedule all of the events along the timeline\n\t\t *  with the updated values.\n\t\t *  @param {Time} after Only reschedules events after the given time.\n\t\t *  @return  {Tone.Event}  this\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._rescheduleEvents = function (after) {\n\t        //if no argument is given, schedules all of the events\n\t        after = this.defaultArg(after, -1);\n\t        this._state.forEachFrom(after, function (event) {\n\t            var duration;\n\t            if (event.state === Tone.State.Started) {\n\t                if (!this.isUndef(event.id)) {\n\t                    Tone.Transport.clear(event.id);\n\t                }\n\t                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t                if (this._loop) {\n\t                    duration = Infinity;\n\t                    if (this.isNumber(this._loop)) {\n\t                        duration = this._loop * this._getLoopDuration();\n\t                    }\n\t                    var nextEvent = this._state.getAfter(startTick);\n\t                    if (nextEvent !== null) {\n\t                        duration = Math.min(duration, nextEvent.time - startTick);\n\t                    }\n\t                    if (duration !== Infinity) {\n\t                        //schedule a stop since it's finite duration\n\t                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);\n\t                        duration = Tone.Time(duration, 'i');\n\t                    }\n\t                    var interval = Tone.Time(this._getLoopDuration(), 'i');\n\t                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);\n\t                } else {\n\t                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');\n\t                }\n\t            }\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the note, either \"started\" or \"stopped\".\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Event#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'state', {\n\t        get: function () {\n\t            return this._state.getValueAtTime(Tone.Transport.ticks);\n\t        }\n\t    });\n\t    /**\n\t\t *  The start from the scheduled start time\n\t\t *  @type {Ticks}\n\t\t *  @memberOf Tone.Event#\n\t\t *  @name startOffset\n\t\t *  @private\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'startOffset', {\n\t        get: function () {\n\t            return this._startOffset;\n\t        },\n\t        set: function (offset) {\n\t            this._startOffset = offset;\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the note at the given time. \n\t\t *  @param  {TimelinePosition}  time  When the note should start.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.start = function (time) {\n\t        time = this.toTicks(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': time,\n\t                'id': undefined\n\t            });\n\t            this._rescheduleEvents(time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the Event at the given time.\n\t\t *  @param  {TimelinePosition}  time  When the note should stop.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.stop = function (time) {\n\t        this.cancel(time);\n\t        time = this.toTicks(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this._state.setStateAtTime(Tone.State.Stopped, time);\n\t            var previousEvent = this._state.getBefore(time);\n\t            var reschedulTime = time;\n\t            if (previousEvent !== null) {\n\t                reschedulTime = previousEvent.time;\n\t            }\n\t            this._rescheduleEvents(reschedulTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel all scheduled events greater than or equal to the given time\n\t\t *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.cancel = function (time) {\n\t        time = this.defaultArg(time, -Infinity);\n\t        time = this.toTicks(time);\n\t        this._state.forEachFrom(time, function (event) {\n\t            Tone.Transport.clear(event.id);\n\t        });\n\t        this._state.cancel(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The callback function invoker. Also \n\t\t *  checks if the Event is done playing\n\t\t *  @param  {Number}  time  The time of the event in seconds\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._tick = function (time) {\n\t        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {\n\t            if (this.probability < 1 && Math.random() > this.probability) {\n\t                return;\n\t            }\n\t            if (this.humanize) {\n\t                var variation = 0.02;\n\t                if (!this.isBoolean(this.humanize)) {\n\t                    variation = this.toSeconds(this.humanize);\n\t                }\n\t                time += (Math.random() * 2 - 1) * variation;\n\t            }\n\t            this.callback(time, this.value);\n\t        }\n\t    };\n\t    /**\n\t\t *  Get the duration of the loop.\n\t\t *  @return  {Ticks}\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._getLoopDuration = function () {\n\t        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t    };\n\t    /**\n\t\t *  If the note should loop or not\n\t\t *  between Tone.Event.loopStart and \n\t\t *  Tone.Event.loopEnd. An integer\n\t\t *  value corresponds to the number of\n\t\t *  loops the Event does after it starts.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {Boolean|Positive}\n\t\t *  @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            this._rescheduleEvents();\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe playback rate of the note. Defaults to 1.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {Positive}\n\t\t *  @name playbackRate\n\t\t *  @example\n\t\t * note.loop = true;\n\t\t * //repeat the note twice as fast\n\t\t * note.playbackRate = 2;\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this._rescheduleEvents();\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopEnd point is the time the event will loop\n\t\t *  if Tone.Event.loop is true.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toNotation();\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = this.toTicks(loopEnd);\n\t            if (this._loop) {\n\t                this._rescheduleEvents();\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The time when the loop should start. \n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toNotation();\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = this.toTicks(loopStart);\n\t            if (this._loop) {\n\t                this._rescheduleEvents();\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The current progress of the loop interval.\n\t\t *  Returns 0 if the event is not started yet or\n\t\t *  it is not set to loop.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {NormalRange}\n\t\t *  @name progress\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'progress', {\n\t        get: function () {\n\t            if (this._loop) {\n\t                var ticks = Tone.Transport.ticks;\n\t                var lastEvent = this._state.get(ticks);\n\t                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {\n\t                    var loopDuration = this._getLoopDuration();\n\t                    var progress = (ticks - lastEvent.time) % loopDuration;\n\t                    return progress / loopDuration;\n\t                } else {\n\t                    return 0;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.dispose = function () {\n\t        this.cancel();\n\t        this._state.dispose();\n\t        this._state = null;\n\t        this.callback = null;\n\t        this.value = null;\n\t    };\n\t    return Tone.Event;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Loop creates a looped callback at the \n\t\t *         specified interval. The callback can be \n\t\t *         started, stopped and scheduled along\n\t\t *         the Transport's timeline. \n\t\t *  @example\n\t\t * var loop = new Tone.Loop(function(time){\n\t\t * \t//triggered every eighth note. \n\t\t * \tconsole.log(time);\n\t\t * }, \"8n\").start(0);\n\t\t * Tone.Transport.start();\n\t\t *  @extends {Tone}\n\t\t *  @param {Function} callback The callback to invoke with the event.\n\t\t *  @param {Time} interval The time between successive callback calls. \n\t\t */\n\t    Tone.Loop = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'interval'\n\t        ], Tone.Loop.defaults);\n\t        /**\n\t\t\t *  The event which produces the callbacks\n\t\t\t */\n\t        this._event = new Tone.Event({\n\t            'callback': this._tick.bind(this),\n\t            'loop': true,\n\t            'loopEnd': options.interval,\n\t            'playbackRate': options.playbackRate,\n\t            'probability': options.probability\n\t        });\n\t        /**\n\t\t\t *  The callback to invoke with the next event in the pattern\n\t\t\t *  @type {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        //set the iterations\n\t        this.iterations = options.iterations;\n\t    };\n\t    Tone.extend(Tone.Loop);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Loop.defaults = {\n\t        'interval': '4n',\n\t        'callback': Tone.noOp,\n\t        'playbackRate': 1,\n\t        'iterations': Infinity,\n\t        'probability': true,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Start the loop at the specified time along the Transport's\n\t\t *  timeline.\n\t\t *  @param  {TimelinePosition=}  time  When to start the Loop.\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.start = function (time) {\n\t        this._event.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the loop at the given time.\n\t\t *  @param  {TimelinePosition=}  time  When to stop the Arpeggio\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.stop = function (time) {\n\t        this._event.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel all scheduled events greater than or equal to the given time\n\t\t *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.cancel = function (time) {\n\t        this._event.cancel(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Internal function called when the notes should be called\n\t\t *  @param  {Number}  time  The time the event occurs\n\t\t *  @private\n\t\t */\n\t    Tone.Loop.prototype._tick = function (time) {\n\t        this.callback(time);\n\t    };\n\t    /**\n\t\t *  The state of the Loop, either started or stopped.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {String}\n\t\t *  @name state\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'state', {\n\t        get: function () {\n\t            return this._event.state;\n\t        }\n\t    });\n\t    /**\n\t\t *  The progress of the loop as a value between 0-1. 0, when\n\t\t *  the loop is stopped or done iterating. \n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {NormalRange}\n\t\t *  @name progress\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'progress', {\n\t        get: function () {\n\t            return this._event.progress;\n\t        }\n\t    });\n\t    /**\n\t\t *  The time between successive callbacks. \n\t\t *  @example\n\t\t * loop.interval = \"8n\"; //loop every 8n\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Time}\n\t\t *  @name interval\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'interval', {\n\t        get: function () {\n\t            return this._event.loopEnd;\n\t        },\n\t        set: function (interval) {\n\t            this._event.loopEnd = interval;\n\t        }\n\t    });\n\t    /**\n\t\t *  The playback rate of the loop. The normal playback rate is 1 (no change). \n\t\t *  A `playbackRate` of 2 would be twice as fast. \n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Time}\n\t\t *  @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._event.playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._event.playbackRate = rate;\n\t        }\n\t    });\n\t    /**\n\t\t *  Random variation +/-0.01s to the scheduled time. \n\t\t *  Or give it a time value which it will randomize by.\n\t\t *  @type {Boolean|Time}\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @name humanize\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'humanize', {\n\t        get: function () {\n\t            return this._event.humanize;\n\t        },\n\t        set: function (variation) {\n\t            this._event.humanize = variation;\n\t        }\n\t    });\n\t    /**\n\t\t *  The probably of the callback being invoked.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {NormalRange}\n\t\t *  @name probability\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'probability', {\n\t        get: function () {\n\t            return this._event.probability;\n\t        },\n\t        set: function (prob) {\n\t            this._event.probability = prob;\n\t        }\n\t    });\n\t    /**\n\t\t *  Muting the Loop means that no callbacks are invoked.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Boolean}\n\t\t *  @name mute\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'mute', {\n\t        get: function () {\n\t            return this._event.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._event.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of iterations of the loop. The default\n\t\t *  value is Infinity (loop forever).\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Positive}\n\t\t *  @name iterations\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'iterations', {\n\t        get: function () {\n\t            if (this._event.loop === true) {\n\t                return Infinity;\n\t            } else {\n\t                return this._event.loop;\n\t            }\n\t            return this._pattern.index;\n\t        },\n\t        set: function (iters) {\n\t            if (iters === Infinity) {\n\t                this._event.loop = true;\n\t            } else {\n\t                this._event.loop = iters;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.dispose = function () {\n\t        this._event.dispose();\n\t        this._event = null;\n\t        this.callback = null;\n\t    };\n\t    return Tone.Loop;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Part is a collection Tone.Events which can be\n\t\t *         started/stoped and looped as a single unit.\n\t\t *\n\t\t *  @extends {Tone.Event}\n\t\t *  @param {Function} callback The callback to invoke on each event\n\t\t *  @param {Array} events the array of events\n\t\t *  @example\n\t\t * var part = new Tone.Part(function(time, note){\n\t\t * \t//the notes given as the second element in the array\n\t\t * \t//will be passed in as the second argument\n\t\t * \tsynth.triggerAttackRelease(note, \"8n\", time);\n\t\t * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n\t\t *  @example\n\t\t * //use an array of objects as long as the object has a \"time\" attribute\n\t\t * var part = new Tone.Part(function(time, value){\n\t\t * \t//the value is an object which contains both the note and the velocity\n\t\t * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n\t\t * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9}, \n\t\t * \t   {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n\t\t * ]).start(0);\n\t\t */\n\t    Tone.Part = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'events'\n\t        ], Tone.Part.defaults);\n\t        /**\n\t\t\t *  If the part is looping or not\n\t\t\t *  @type  {Boolean|Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = this.toTicks(options.loopStart);\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = this.toTicks(options.loopEnd);\n\t        /**\n\t\t\t *  The playback rate of the part\n\t\t\t *  @type  {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  private holder of probability value\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._probability = options.probability;\n\t        /**\n\t\t\t *  the amount of variation from the\n\t\t\t *  given time. \n\t\t\t *  @type {Boolean|Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._humanize = options.humanize;\n\t        /**\n\t\t\t *  The start offset\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startOffset = 0;\n\t        /**\n\t\t\t *  Keeps track of the current state\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  An array of Objects. \n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = [];\n\t        /**\n\t\t\t *  The callback to invoke at all the scheduled events.\n\t\t\t *  @type {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  If mute is true, the callback won't be\n\t\t\t *  invoked.\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.mute = options.mute;\n\t        //add the events\n\t        var events = this.defaultArg(options.events, []);\n\t        if (!this.isUndef(options.events)) {\n\t            for (var i = 0; i < events.length; i++) {\n\t                if (Array.isArray(events[i])) {\n\t                    this.add(events[i][0], events[i][1]);\n\t                } else {\n\t                    this.add(events[i]);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    Tone.extend(Tone.Part, Tone.Event);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Part.defaults = {\n\t        'callback': Tone.noOp,\n\t        'loop': false,\n\t        'loopEnd': '1m',\n\t        'loopStart': 0,\n\t        'playbackRate': 1,\n\t        'probability': 1,\n\t        'humanize': false,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Start the part at the given time. \n\t\t *  @param  {TransportTime}  time    When to start the part.\n\t\t *  @param  {Time=}  offset  The offset from the start of the part\n\t\t *                           to begin playing at.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.start = function (time, offset) {\n\t        var ticks = this.toTicks(time);\n\t        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {\n\t            if (this._loop) {\n\t                offset = this.defaultArg(offset, this._loopStart);\n\t            } else {\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toTicks(offset);\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': ticks,\n\t                'offset': offset\n\t            });\n\t            this._forEach(function (event) {\n\t                this._startNote(event, ticks, offset);\n\t            });\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the event in the given event at the correct time given\n\t\t *  the ticks and offset and looping.\n\t\t *  @param  {Tone.Event}  event \n\t\t *  @param  {Ticks}  ticks\n\t\t *  @param  {Ticks}  offset\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._startNote = function (event, ticks, offset) {\n\t        ticks -= offset;\n\t        if (this._loop) {\n\t            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t                if (event.startOffset < offset) {\n\t                    //start it on the next loop\n\t                    ticks += this._getLoopDuration();\n\t                }\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t                event.loop = false;\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            }\n\t        } else {\n\t            if (event.startOffset >= offset) {\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  The start from the scheduled start time\n\t\t *  @type {Ticks}\n\t\t *  @memberOf Tone.Part#\n\t\t *  @name startOffset\n\t\t *  @private\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'startOffset', {\n\t        get: function () {\n\t            return this._startOffset;\n\t        },\n\t        set: function (offset) {\n\t            this._startOffset = offset;\n\t            this._forEach(function (event) {\n\t                event.startOffset += this._startOffset;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  Stop the part at the given time.\n\t\t *  @param  {TimelinePosition}  time  When to stop the part.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.stop = function (time) {\n\t        var ticks = this.toTicks(time);\n\t        this._state.cancel(ticks);\n\t        this._state.setStateAtTime(Tone.State.Stopped, ticks);\n\t        this._forEach(function (event) {\n\t            event.stop(time);\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get/Set an Event's value at the given time. \n\t\t *  If a value is passed in and no event exists at\n\t\t *  the given time, one will be created with that value. \n\t\t *  If two events are at the same time, the first one will\n\t\t *  be returned.\n\t\t *  @example\n\t\t * part.at(\"1m\"); //returns the part at the first measure\n\t\t *\n\t\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2. \n\t\t * //if an event didn't exist at that time, it will be created.\n\t\t *  @param {TransportTime} time The time of the event to get or set.\n\t\t *  @param {*=} value If a value is passed in, the value of the\n\t\t *                    event at the given time will be set to it.\n\t\t *  @return {Tone.Event} the event at the time\n\t\t */\n\t    Tone.Part.prototype.at = function (time, value) {\n\t        time = Tone.TransportTime(time);\n\t        var tickTime = Tone.Time(1, 'i').toSeconds();\n\t        for (var i = 0; i < this._events.length; i++) {\n\t            var event = this._events[i];\n\t            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {\n\t                if (!this.isUndef(value)) {\n\t                    event.value = value;\n\t                }\n\t                return event;\n\t            }\n\t        }\n\t        //if there was no event at that time, create one\n\t        if (!this.isUndef(value)) {\n\t            this.add(time, value);\n\t            //return the new event\n\t            return this._events[this._events.length - 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Add a an event to the part. \n\t\t *  @param {Time} time The time the note should start.\n\t\t *                            If an object is passed in, it should\n\t\t *                            have a 'time' attribute and the rest\n\t\t *                            of the object will be used as the 'value'.\n\t\t *  @param  {Tone.Event|*}  value \n\t\t *  @returns {Tone.Part} this\n\t\t *  @example\n\t\t * part.add(\"1m\", \"C#+11\");\n\t\t */\n\t    Tone.Part.prototype.add = function (time, value) {\n\t        //extract the parameters\n\t        if (time.hasOwnProperty('time')) {\n\t            value = time;\n\t            time = value.time;\n\t        }\n\t        time = this.toTicks(time);\n\t        var event;\n\t        if (value instanceof Tone.Event) {\n\t            event = value;\n\t            event.callback = this._tick.bind(this);\n\t        } else {\n\t            event = new Tone.Event({\n\t                'callback': this._tick.bind(this),\n\t                'value': value\n\t            });\n\t        }\n\t        //the start offset\n\t        event.startOffset = time;\n\t        //initialize the values\n\t        event.set({\n\t            'loopEnd': this.loopEnd,\n\t            'loopStart': this.loopStart,\n\t            'loop': this.loop,\n\t            'humanize': this.humanize,\n\t            'playbackRate': this.playbackRate,\n\t            'probability': this.probability\n\t        });\n\t        this._events.push(event);\n\t        //start the note if it should be played right now\n\t        this._restartEvent(event);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Restart the given event\n\t\t *  @param  {Tone.Event}  event \n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._restartEvent = function (event) {\n\t        this._state.forEach(function (stateEvent) {\n\t            if (stateEvent.state === Tone.State.Started) {\n\t                this._startNote(event, stateEvent.time, stateEvent.offset);\n\t            } else {\n\t                //stop the note\n\t                event.stop(Tone.TransportTime(stateEvent.time, 'i'));\n\t            }\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Remove an event from the part. Will recursively iterate\n\t\t *  into nested parts to find the event.\n\t\t *  @param {Time} time The time of the event\n\t\t *  @param {*} value Optionally select only a specific event value\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.remove = function (time, value) {\n\t        //extract the parameters\n\t        if (time.hasOwnProperty('time')) {\n\t            value = time;\n\t            time = value.time;\n\t        }\n\t        time = this.toTicks(time);\n\t        for (var i = this._events.length - 1; i >= 0; i--) {\n\t            var event = this._events[i];\n\t            if (event instanceof Tone.Part) {\n\t                event.remove(time, value);\n\t            } else {\n\t                if (event.startOffset === time) {\n\t                    if (this.isUndef(value) || !this.isUndef(value) && event.value === value) {\n\t                        this._events.splice(i, 1);\n\t                        event.dispose();\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove all of the notes from the group. \n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.removeAll = function () {\n\t        this._forEach(function (event) {\n\t            event.dispose();\n\t        });\n\t        this._events = [];\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t\t *  @param {TimelinePosition} after The time after which to cancel the scheduled events.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.cancel = function (after) {\n\t        after = this.toTicks(after);\n\t        this._forEach(function (event) {\n\t            event.cancel(after);\n\t        });\n\t        this._state.cancel(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over all of the events\n\t\t *  @param {Function} callback\n\t\t *  @param {Object} ctx The context\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._forEach = function (callback, ctx) {\n\t        ctx = this.defaultArg(ctx, this);\n\t        for (var i = this._events.length - 1; i >= 0; i--) {\n\t            var e = this._events[i];\n\t            if (e instanceof Tone.Part) {\n\t                e._forEach(callback, ctx);\n\t            } else {\n\t                callback.call(ctx, e);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the attribute of all of the events\n\t\t *  @param  {String}  attr  the attribute to set\n\t\t *  @param  {*}  value      The value to set it to\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._setAll = function (attr, value) {\n\t        this._forEach(function (event) {\n\t            event[attr] = value;\n\t        });\n\t    };\n\t    /**\n\t\t *  Internal tick method\n\t\t *  @param  {Number}  time  The time of the event in seconds\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._tick = function (time, value) {\n\t        if (!this.mute) {\n\t            this.callback(time, value);\n\t        }\n\t    };\n\t    /**\n\t\t *  Determine if the event should be currently looping\n\t\t *  given the loop boundries of this Part.\n\t\t *  @param  {Tone.Event}  event  The event to test\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._testLoopBoundries = function (event) {\n\t        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {\n\t            event.cancel(0);\n\t        } else {\n\t            //reschedule it if it's stopped\n\t            if (event.state === Tone.State.Stopped) {\n\t                this._restartEvent(event);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  The probability of the notes being triggered.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {NormalRange}\n\t\t *  @name probability\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'probability', {\n\t        get: function () {\n\t            return this._probability;\n\t        },\n\t        set: function (prob) {\n\t            this._probability = prob;\n\t            this._setAll('probability', prob);\n\t        }\n\t    });\n\t    /**\n\t\t *  If set to true, will apply small random variation\n\t\t *  to the callback time. If the value is given as a time, it will randomize\n\t\t *  by that amount.\n\t\t *  @example\n\t\t * event.humanize = true;\n\t\t *  @type {Boolean|Time}\n\t\t *  @name humanize\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'humanize', {\n\t        get: function () {\n\t            return this._humanize;\n\t        },\n\t        set: function (variation) {\n\t            this._humanize = variation;\n\t            this._setAll('humanize', variation);\n\t        }\n\t    });\n\t    /**\n\t\t *  If the part should loop or not\n\t\t *  between Tone.Part.loopStart and \n\t\t *  Tone.Part.loopEnd. An integer\n\t\t *  value corresponds to the number of\n\t\t *  loops the Part does after it starts.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Boolean|Positive}\n\t\t *  @name loop\n\t\t *  @example\n\t\t * //loop the part 8 times\n\t\t * part.loop = 8;\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            this._forEach(function (event) {\n\t                event._loopStart = this._loopStart;\n\t                event._loopEnd = this._loopEnd;\n\t                event.loop = loop;\n\t                this._testLoopBoundries(event);\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopEnd point determines when it will \n\t\t *  loop if Tone.Part.loop is true.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toNotation();\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = this.toTicks(loopEnd);\n\t            if (this._loop) {\n\t                this._forEach(function (event) {\n\t                    event.loopEnd = loopEnd;\n\t                    this._testLoopBoundries(event);\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopStart point determines when it will \n\t\t *  loop if Tone.Part.loop is true.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toNotation();\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = this.toTicks(loopStart);\n\t            if (this._loop) {\n\t                this._forEach(function (event) {\n\t                    event.loopStart = this.loopStart;\n\t                    this._testLoopBoundries(event);\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe playback rate of the part\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Positive}\n\t\t *  @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this._setAll('playbackRate', rate);\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe number of scheduled notes in the part. \n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Positive}\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'length', {\n\t        get: function () {\n\t            return this._events.length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.dispose = function () {\n\t        this.removeAll();\n\t        this._state.dispose();\n\t        this._state = null;\n\t        this.callback = null;\n\t        this._events = null;\n\t        return this;\n\t    };\n\t    return Tone.Part;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Pattern arpeggiates between the given notes\n\t\t *         in a number of patterns. See Tone.CtrlPattern for\n\t\t *         a full list of patterns.\n\t\t *  @example\n\t\t * var pattern = new Tone.Pattern(function(time, note){\n\t\t *   //the order of the notes passed in depends on the pattern\n\t\t * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n\t\t *  @extends {Tone.Loop}\n\t\t *  @param {Function} callback The callback to invoke with the\n\t\t *                             event.\n\t\t *  @param {Array} values The values to arpeggiate over.\n\t\t */\n\t    Tone.Pattern = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'values',\n\t            'pattern'\n\t        ], Tone.Pattern.defaults);\n\t        Tone.Loop.call(this, options);\n\t        /**\n\t\t\t *  The pattern manager\n\t\t\t *  @type {Tone.CtrlPattern}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pattern = new Tone.CtrlPattern({\n\t            'values': options.values,\n\t            'type': options.pattern,\n\t            'index': options.index\n\t        });\n\t    };\n\t    Tone.extend(Tone.Pattern, Tone.Loop);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Pattern.defaults = {\n\t        'pattern': Tone.CtrlPattern.Type.Up,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  Internal function called when the notes should be called\n\t\t *  @param  {Number}  time  The time the event occurs\n\t\t *  @private\n\t\t */\n\t    Tone.Pattern.prototype._tick = function (time) {\n\t        this.callback(time, this._pattern.value);\n\t        this._pattern.next();\n\t    };\n\t    /**\n\t\t *  The current index in the values array.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {Positive}\n\t\t *  @name index\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'index', {\n\t        get: function () {\n\t            return this._pattern.index;\n\t        },\n\t        set: function (i) {\n\t            this._pattern.index = i;\n\t        }\n\t    });\n\t    /**\n\t\t *  The array of events.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {Array}\n\t\t *  @name values\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'values', {\n\t        get: function () {\n\t            return this._pattern.values;\n\t        },\n\t        set: function (vals) {\n\t            this._pattern.values = vals;\n\t        }\n\t    });\n\t    /**\n\t\t *  The current value of the pattern.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'value', {\n\t        get: function () {\n\t            return this._pattern.value;\n\t        }\n\t    });\n\t    /**\n\t\t *  The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {String}\n\t\t *  @name pattern\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {\n\t        get: function () {\n\t            return this._pattern.type;\n\t        },\n\t        set: function (pattern) {\n\t            this._pattern.type = pattern;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Pattern}  this\n\t\t */\n\t    Tone.Pattern.prototype.dispose = function () {\n\t        Tone.Loop.prototype.dispose.call(this);\n\t        this._pattern.dispose();\n\t        this._pattern = null;\n\t    };\n\t    return Tone.Pattern;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A sequence is an alternate notation of a part. Instead\n\t\t *         of passing in an array of [time, event] pairs, pass\n\t\t *         in an array of events which will be spaced at the\n\t\t *         given subdivision. Sub-arrays will subdivide that beat\n\t\t *         by the number of items are in the array. \n\t\t *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n\t\t *  @param  {Function}  callback  The callback to invoke with every note\n\t\t *  @param  {Array}    events  The sequence\n\t\t *  @param  {Time} subdivision  The subdivision between which events are placed. \n\t\t *  @extends {Tone.Part}\n\t\t *  @example\n\t\t * var seq = new Tone.Sequence(function(time, note){\n\t\t * \tconsole.log(note);\n\t\t * //straight quater notes\n\t\t * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n\t\t *  @example\n\t\t * var seq = new Tone.Sequence(function(time, note){\n\t\t * \tconsole.log(note);\n\t\t * //subdivisions are given as subarrays\n\t\t * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n\t\t */\n\t    Tone.Sequence = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'events',\n\t            'subdivision'\n\t        ], Tone.Sequence.defaults);\n\t        //remove the events\n\t        var events = options.events;\n\t        delete options.events;\n\t        Tone.Part.call(this, options);\n\t        /**\n\t\t\t *  The subdivison of each note\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subdivision = this.toTicks(options.subdivision);\n\t        //if no time was passed in, the loop end is the end of the cycle\n\t        if (this.isUndef(options.loopEnd) && !this.isUndef(events)) {\n\t            this._loopEnd = events.length * this._subdivision;\n\t        }\n\t        //defaults to looping\n\t        this._loop = true;\n\t        //add all of the events\n\t        if (!this.isUndef(events)) {\n\t            for (var i = 0; i < events.length; i++) {\n\t                this.add(i, events[i]);\n\t            }\n\t        }\n\t    };\n\t    Tone.extend(Tone.Sequence, Tone.Part);\n\t    /**\n\t\t *  The default values.\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Sequence.defaults = { 'subdivision': '4n' };\n\t    /**\n\t\t *  The subdivision of the sequence. This can only be \n\t\t *  set in the constructor. The subdivision is the \n\t\t *  interval between successive steps. \n\t\t *  @type {Time}\n\t\t *  @memberOf Tone.Sequence#\n\t\t *  @name subdivision\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {\n\t        get: function () {\n\t            return Tone.Time(this._subdivision, 'i').toNotation();\n\t        }\n\t    });\n\t    /**\n\t\t *  Get/Set an index of the sequence. If the index contains a subarray, \n\t\t *  a Tone.Sequence representing that sub-array will be returned. \n\t\t *  @example\n\t\t * var sequence = new Tone.Sequence(playNote, [\"E4\", \"C4\", \"F#4\", [\"A4\", \"Bb3\"]])\n\t\t * sequence.at(0)// => returns \"E4\"\n\t\t * //set a value\n\t\t * sequence.at(0, \"G3\");\n\t\t * //get a nested sequence\n\t\t * sequence.at(3).at(1)// => returns \"Bb3\"\n\t\t * @param {Positive} index The index to get or set\n\t\t * @param {*} value Optionally pass in the value to set at the given index.\n\t\t */\n\t    Tone.Sequence.prototype.at = function (index, value) {\n\t        //if the value is an array, \n\t        if (this.isArray(value)) {\n\t            //remove the current event at that index\n\t            this.remove(index);\n\t        }\n\t        //call the parent's method\n\t        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);\n\t    };\n\t    /**\n\t\t *  Add an event at an index, if there's already something\n\t\t *  at that index, overwrite it. If `value` is an array, \n\t\t *  it will be parsed as a subsequence.\n\t\t *  @param {Number} index The index to add the event to\n\t\t *  @param {*} value The value to add at that index\n\t\t *  @returns {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.add = function (index, value) {\n\t        if (value === null) {\n\t            return this;\n\t        }\n\t        if (this.isArray(value)) {\n\t            //make a subsequence and add that to the sequence\n\t            var subSubdivision = Math.round(this._subdivision / value.length);\n\t            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));\n\t        }\n\t        Tone.Part.prototype.add.call(this, this._indexTime(index), value);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove a value from the sequence by index\n\t\t *  @param {Number} index The index of the event to remove\n\t\t *  @returns {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.remove = function (index, value) {\n\t        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the time of the index given the Sequence's subdivision\n\t\t *  @param  {Number}  index \n\t\t *  @return  {Time}  The time of that index\n\t\t *  @private\n\t\t */\n\t    Tone.Sequence.prototype._indexTime = function (index) {\n\t        if (index instanceof Tone.TransportTime) {\n\t            return index;\n\t        } else {\n\t            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.dispose = function () {\n\t        Tone.Part.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.Sequence;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,\n\t\t *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is \n\t\t *         a square and only odd-numbered harmonics are present. At all other widths \n\t\t *         even-numbered harmonics are present. Read more \n\t\t *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @param {Frequency} [frequency] The frequency of the oscillator\n\t\t *  @param {NormalRange} [width] The width of the pulse\n\t\t *  @example\n\t\t * var pulse = new Tone.PulseOscillator(\"E5\", 0.4).toMaster().start();\n\t\t */\n\t    Tone.PulseOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'width'\n\t        ], Tone.Oscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The width of the pulse. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  gate the width amount\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._widthGate = new Tone.Gain();\n\t        /**\n\t\t\t *  the sawtooth oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sawtooth = new Tone.Oscillator({\n\t            frequency: options.frequency,\n\t            detune: options.detune,\n\t            type: 'sawtooth',\n\t            phase: options.phase\n\t        });\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._sawtooth.frequency;\n\t        /**\n\t\t\t *  The detune in cents. \n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._sawtooth.detune;\n\t        /**\n\t\t\t *  Threshold the signal to turn it into a square\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._thresh = new Tone.WaveShaper(function (val) {\n\t            if (val < 0) {\n\t                return -1;\n\t            } else {\n\t                return 1;\n\t            }\n\t        });\n\t        //connections\n\t        this._sawtooth.chain(this._thresh, this.output);\n\t        this.width.chain(this._widthGate, this._thresh);\n\t        this._readOnly([\n\t            'width',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PulseOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  The default parameters.\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PulseOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'width': 0.2\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} time \n\t\t *  @private\n\t\t */\n\t    Tone.PulseOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._sawtooth.start(time);\n\t        this._widthGate.gain.setValueAtTime(1, time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time \n\t\t *  @private\n\t\t */\n\t    Tone.PulseOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._sawtooth.stop(time);\n\t        //the width is still connected to the output. \n\t        //that needs to be stopped also\n\t        this._widthGate.gain.setValueAtTime(0, time);\n\t    };\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._sawtooth.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._sawtooth.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the oscillator. Always returns \"pulse\".\n\t\t * @readOnly\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return 'pulse';\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. Cannot set partials for this waveform type\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @private\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return [];\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up method.\n\t\t *  @return {Tone.PulseOscillator} this\n\t\t */\n\t    Tone.PulseOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._sawtooth.dispose();\n\t        this._sawtooth = null;\n\t        this._writable([\n\t            'width',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.width.dispose();\n\t        this.width = null;\n\t        this._widthGate.dispose();\n\t        this._widthGate = null;\n\t        this._thresh.dispose();\n\t        this._thresh = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.PulseOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator \n\t\t *         at the modulationFrequency. This has the effect of continuously\n\t\t *         changing the timbre of the oscillator by altering the harmonics \n\t\t *         generated.\n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. \n\t\t *  @example\n\t\t *  var pwm = new Tone.PWMOscillator(\"Ab3\", 0.3).toMaster().start();\n\t\t */\n\t    Tone.PWMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'modulationFrequency'\n\t        ], Tone.PWMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  the pulse oscillator\n\t\t\t *  @type {Tone.PulseOscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);\n\t        //change the pulse oscillator type\n\t        this._pulse._sawtooth.type = 'sine';\n\t        /**\n\t\t\t *  the modulator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator({\n\t            'frequency': options.frequency,\n\t            'detune': options.detune,\n\t            'phase': options.phase\n\t        });\n\t        /**\n\t\t\t *  Scale the oscillator so it doesn't go silent \n\t\t\t *  at the extreme values.\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = new Tone.Multiply(2);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._modulator.frequency;\n\t        /**\n\t\t\t *  The detune of the oscillator.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._modulator.detune;\n\t        /**\n\t\t\t *  The modulation rate of the oscillator. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.modulationFrequency = this._pulse.frequency;\n\t        //connections\n\t        this._modulator.chain(this._scale, this._pulse.width);\n\t        this._pulse.connect(this.output);\n\t        this._readOnly([\n\t            'modulationFrequency',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PWMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.PWMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationFrequency': 0.4\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.PWMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._pulse.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.PWMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._pulse.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the oscillator. Always returns \"pwm\".\n\t\t * @readOnly\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return 'pwm';\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. Cannot set partials for this waveform type\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @private\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return [];\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._modulator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.PWMOscillator} this\n\t\t */\n\t    Tone.PWMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._pulse.dispose();\n\t        this._pulse = null;\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._writable([\n\t            'modulationFrequency',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.modulationFrequency = null;\n\t        return this;\n\t    };\n\t    return Tone.PWMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FMOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.FMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.FMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'modulationType'\n\t        ], Tone.FMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The carrier oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Oscillator(options.frequency, options.type);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._carrier.detune;\n\t        this.detune.value = options.detune;\n\t        /**\n\t\t\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the \n\t\t\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t\t *  modulating signal (ma) -- as in ma/mf. \n\t\t\t *\t@type {Positive}\n\t\t\t *\t@signal\n\t\t\t */\n\t        this.modulationIndex = new Tone.Multiply(options.modulationIndex);\n\t        this.modulationIndex.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  The modulating oscillator\n\t\t\t *  @type  {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);\n\t        /**\n\t\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t\t *  Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch the modulator an octave below carrier\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //connections\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.frequency.chain(this.modulationIndex, this._modulationNode);\n\t        this._modulator.connect(this._modulationNode.gain);\n\t        this._modulationNode.connect(this._carrier.frequency);\n\t        this._carrier.connect(this.output);\n\t        this.detune.connect(this._modulator.detune);\n\t        this.phase = options.phase;\n\t        this._readOnly([\n\t            'modulationIndex',\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.FMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationIndex': 2,\n\t        'modulationType': 'square',\n\t        'harmonicity': 1\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.FMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._carrier.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.FMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._carrier.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._carrier.type;\n\t        },\n\t        set: function (type) {\n\t            this._carrier.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {String}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            return this._modulator.type;\n\t        },\n\t        set: function (type) {\n\t            this._modulator.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._carrier.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._carrier.phase = phase;\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._carrier.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._carrier.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.FMOscillator} this\n\t\t */\n\t    Tone.FMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'modulationIndex',\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.modulationIndex.dispose();\n\t        this.modulationIndex = null;\n\t        return this;\n\t    };\n\t    return Tone.FMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AMOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.AMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.AMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'modulationType'\n\t        ], Tone.AMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The carrier oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Oscillator(options.frequency, options.type);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._carrier.frequency;\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._carrier.detune;\n\t        this.detune.value = options.detune;\n\t        /**\n\t\t\t *  The modulating oscillator\n\t\t\t *  @type  {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);\n\t        /**\n\t\t\t *  convert the -1,1 output to 0,1\n\t\t\t *  @type {Tone.AudioToGain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationScale = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t\t *  Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch the modulator an octave below carrier\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //connections\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.detune.connect(this._modulator.detune);\n\t        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t        this._carrier.chain(this._modulationNode, this.output);\n\t        this.phase = options.phase;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.AMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationType': 'square',\n\t        'harmonicity': 1\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.AMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._carrier.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.AMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._carrier.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._carrier.type;\n\t        },\n\t        set: function (type) {\n\t            this._carrier.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {string}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            return this._modulator.type;\n\t        },\n\t        set: function (type) {\n\t            this._modulator.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._carrier.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._carrier.phase = phase;\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._carrier.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._carrier.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.AMOscillator} this\n\t\t */\n\t    Tone.AMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this._modulationScale.dispose();\n\t        this._modulationScale = null;\n\t        return this;\n\t    };\n\t    return Tone.AMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FatOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.FatOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.FatOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'spread'\n\t        ], Tone.FatOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  The array of oscillators\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillators = [];\n\t        /**\n\t\t\t *  The total spread of the oscillators\n\t\t\t *  @type  {Cents}\n\t\t\t *  @private\n\t\t\t */\n\t        this._spread = options.spread;\n\t        /**\n\t\t\t *  The type of the oscillator\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The phase of the oscillators\n\t\t\t *  @type {Degrees}\n\t\t\t *  @private\n\t\t\t */\n\t        this._phase = options.phase;\n\t        /**\n\t\t\t *  The partials array\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._partials = this.defaultArg(options.partials, []);\n\t        //set the count initially\n\t        this.count = options.count;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FatOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.FatOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'spread': 20,\n\t        'count': 3,\n\t        'type': 'sawtooth'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._forEach(function (osc) {\n\t            osc.start(time);\n\t        });\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._forEach(function (osc) {\n\t            osc.stop(time);\n\t        });\n\t    };\n\t    /**\n\t\t *  Iterate over all of the oscillators\n\t\t *  @param  {Function}  iterator  The iterator function\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._forEach = function (iterator) {\n\t        for (var i = 0; i < this._oscillators.length; i++) {\n\t            iterator.call(this, this._oscillators[i], i);\n\t        }\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            this._type = type;\n\t            this._forEach(function (osc) {\n\t                osc.type = type;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The detune spread between the oscillators. If \"count\" is\n\t\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t\t * for a total detune spread of 40 cents.\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Cents}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {\n\t        get: function () {\n\t            return this._spread;\n\t        },\n\t        set: function (spread) {\n\t            this._spread = spread;\n\t            if (this._oscillators.length > 1) {\n\t                var start = -spread / 2;\n\t                var step = spread / (this._oscillators.length - 1);\n\t                this._forEach(function (osc, i) {\n\t                    osc.detune.value = start + step * i;\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of detuned oscillators\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Number}\n\t\t * @name count\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {\n\t        get: function () {\n\t            return this._oscillators.length;\n\t        },\n\t        set: function (count) {\n\t            count = Math.max(count, 1);\n\t            if (this._oscillators.length !== count) {\n\t                // var partials = this.partials;\n\t                // var type = this.type;\n\t                //dispose the previous oscillators\n\t                this._forEach(function (osc) {\n\t                    osc.dispose();\n\t                });\n\t                this._oscillators = [];\n\t                for (var i = 0; i < count; i++) {\n\t                    var osc = new Tone.Oscillator();\n\t                    if (this.type === Tone.Oscillator.Type.Custom) {\n\t                        osc.partials = this._partials;\n\t                    } else {\n\t                        osc.type = this._type;\n\t                    }\n\t                    osc.phase = this._phase;\n\t                    osc.volume.value = -6 - count;\n\t                    this.frequency.connect(osc.frequency);\n\t                    this.detune.connect(osc.detune);\n\t                    osc.connect(this.output);\n\t                    this._oscillators[i] = osc;\n\t                }\n\t                //set the spread\n\t                this.spread = this._spread;\n\t                if (this.state === Tone.State.Started) {\n\t                    this._forEach(function (osc) {\n\t                        osc.start();\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._phase;\n\t        },\n\t        set: function (phase) {\n\t            this._phase = phase;\n\t            this._forEach(function (osc) {\n\t                osc.phase = phase;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._partials;\n\t        },\n\t        set: function (partials) {\n\t            this._partials = partials;\n\t            this._type = Tone.Oscillator.Type.Custom;\n\t            this._forEach(function (osc) {\n\t                osc.partials = partials;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.FatOscillator} this\n\t\t */\n\t    Tone.FatOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this._forEach(function (osc) {\n\t            osc.dispose();\n\t        });\n\t        this._oscillators = null;\n\t        this._partials = null;\n\t        return this;\n\t    };\n\t    return Tone.FatOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n\t\t *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n\t\t *         into one class. The oscillator class can be changed by setting the `type`. \n\t\t *         `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n\t\t *         any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n\t\t *         will use the FMOscillator, AMOscillator or FatOscillator respectively. \n\t\t *         For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n\t\t *         to a FatOscillator of type \"sawtooth\". \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The initial frequency of the oscillator.\n\t\t *  @param {String} type The type of the oscillator.\n\t\t *  @example\n\t\t *  var omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\");\n\t\t */\n\t    Tone.OmniOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type'\n\t        ], Tone.OmniOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  the type of the oscillator source\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sourceType = undefined;\n\t        /**\n\t\t\t *  the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = null;\n\t        //set the oscillator\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        //set the options\n\t        this.set(options);\n\t    };\n\t    Tone.extend(Tone.OmniOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.OmniOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'type': 'sine',\n\t        'phase': 0\n\t    };\n\t    /**\n\t\t *  @enum {String}\n\t\t *  @private\n\t\t */\n\t    var OmniOscType = {\n\t        Pulse: 'PulseOscillator',\n\t        PWM: 'PWMOscillator',\n\t        Osc: 'Oscillator',\n\t        FM: 'FMOscillator',\n\t        AM: 'AMOscillator',\n\t        Fat: 'FatOscillator'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param {Time} [time=now] the time to start the oscillator\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._start = function (time) {\n\t        this._oscillator.start(time);\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param {Time} [time=now] the time to start the oscillator\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._stop = function (time) {\n\t        this._oscillator.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error \n\t\t * when it's not.\n\t\t * \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {String}\n\t\t * @name type\n\t\t * @example\n\t\t * omniOsc.type = \"pwm\";\n\t\t * //modulationFrequency is parameter which is available\n\t\t * //only when the type is \"pwm\". \n\t\t * omniOsc.modulationFrequency.value = 0.5;\n\t\t * @example\n\t\t * //an square wave frequency modulated by a sawtooth\n\t\t * omniOsc.type = \"fmsquare\";\n\t\t * omniOsc.modulationType = \"sawtooth\";\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {\n\t        get: function () {\n\t            var prefix = '';\n\t            if (this._sourceType === OmniOscType.FM) {\n\t                prefix = 'fm';\n\t            } else if (this._sourceType === OmniOscType.AM) {\n\t                prefix = 'am';\n\t            } else if (this._sourceType === OmniOscType.Fat) {\n\t                prefix = 'fat';\n\t            }\n\t            return prefix + this._oscillator.type;\n\t        },\n\t        set: function (type) {\n\t            if (type.substr(0, 2) === 'fm') {\n\t                this._createNewOscillator(OmniOscType.FM);\n\t                this._oscillator.type = type.substr(2);\n\t            } else if (type.substr(0, 2) === 'am') {\n\t                this._createNewOscillator(OmniOscType.AM);\n\t                this._oscillator.type = type.substr(2);\n\t            } else if (type.substr(0, 3) === 'fat') {\n\t                this._createNewOscillator(OmniOscType.Fat);\n\t                this._oscillator.type = type.substr(3);\n\t            } else if (type === 'pwm') {\n\t                this._createNewOscillator(OmniOscType.PWM);\n\t            } else if (type === 'pulse') {\n\t                this._createNewOscillator(OmniOscType.Pulse);\n\t            } else {\n\t                this._createNewOscillator(OmniOscType.Osc);\n\t                this._oscillator.type = type;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._oscillator.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._oscillator.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Set a member/attribute of the oscillator. \n\t\t *  @param {Object|String} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone.OmniOscillator} this\n\t\t */\n\t    Tone.OmniOscillator.prototype.set = function (params, value) {\n\t        //make sure the type is set first\n\t        if (params === 'type') {\n\t            this.type = value;\n\t        } else if (this.isObject(params) && params.hasOwnProperty('type')) {\n\t            this.type = params.type;\n\t        }\n\t        //then set the rest\n\t        Tone.prototype.set.apply(this, arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the oscillator to the frequency and detune signals\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {\n\t        if (oscType !== this._sourceType) {\n\t            this._sourceType = oscType;\n\t            var OscillatorConstructor = Tone[oscType];\n\t            //short delay to avoid clicks on the change\n\t            var now = this.now() + this.blockTime;\n\t            if (this._oscillator !== null) {\n\t                var oldOsc = this._oscillator;\n\t                oldOsc.stop(now);\n\t                //dispose the old one\n\t                setTimeout(function () {\n\t                    oldOsc.dispose();\n\t                    oldOsc = null;\n\t                }, this.blockTime * 1000);\n\t            }\n\t            this._oscillator = new OscillatorConstructor();\n\t            this.frequency.connect(this._oscillator.frequency);\n\t            this.detune.connect(this._oscillator.detune);\n\t            this._oscillator.connect(this.output);\n\t            if (this.state === Tone.State.Started) {\n\t                this._oscillator.start(now);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t * The phase of the oscillator in degrees. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._oscillator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._oscillator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The width of the oscillator (only if the oscillator is set to \"pulse\")\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {NormalRange}\n\t\t * @signal\n\t\t * @name width\n\t\t * @example\n\t\t * var omniOsc = new Tone.OmniOscillator(440, \"pulse\");\n\t\t * //can access the width attribute only if type === \"pulse\"\n\t\t * omniOsc.width.value = 0.2; \n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Pulse) {\n\t                return this._oscillator.width;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of detuned oscillators\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Number}\n\t\t * @name count\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                return this._oscillator.count;\n\t            }\n\t        },\n\t        set: function (count) {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                this._oscillator.count = count;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The detune spread between the oscillators. If \"count\" is\n\t\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t\t * for more info.\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Cents}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                return this._oscillator.spread;\n\t            }\n\t        },\n\t        set: function (spread) {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                this._oscillator.spread = spread;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator. Only if the oscillator\n\t\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t\t * for more info. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {String}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                return this._oscillator.modulationType;\n\t            }\n\t        },\n\t        set: function (mType) {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                this._oscillator.modulationType = mType;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the \n\t\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t * modulating signal (ma) -- as in ma/mf. \n\t\t * See Tone.FMOscillator for more info. \n\t\t * @type {Positive}\n\t\t * @signal\n\t\t * @name modulationIndex\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM) {\n\t                return this._oscillator.modulationIndex;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t\t *  for more info. \n\t\t *  @memberOf Tone.OmniOscillator#\n\t\t *  @signal\n\t\t *  @type {Positive}\n\t\t *  @name harmonicity\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                return this._oscillator.harmonicity;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The modulationFrequency Signal of the oscillator \n\t\t * (only if the oscillator type is set to pwm). See \n\t\t * Tone.PWMOscillator for more info. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Frequency}\n\t\t * @signal\n\t\t * @name modulationFrequency\n\t\t * @example\n\t\t * var omniOsc = new Tone.OmniOscillator(440, \"pwm\");\n\t\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t\t * omniOsc.modulationFrequency.value = 0.2; \n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.PWM) {\n\t                return this._oscillator.modulationFrequency;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.OmniOscillator} this\n\t\t */\n\t    Tone.OmniOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._oscillator.dispose();\n\t        this._oscillator = null;\n\t        this._sourceType = null;\n\t        return this;\n\t    };\n\t    return Tone.OmniOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base-class for all instruments\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Instrument = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Instrument.defaults);\n\t        /**\n\t\t\t *  The output and volume triming node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t    };\n\t    Tone.extend(Tone.Instrument);\n\t    /**\n\t\t *  the default attributes\n\t\t *  @type {object}\n\t\t */\n\t    Tone.Instrument.defaults = {\n\t        /** the volume of the output in decibels */\n\t        'volume': 0\n\t    };\n\t    /**\n\t\t *  @abstract\n\t\t *  @param {string|number} note the note to trigger\n\t\t *  @param {Time} [time=now] the time to trigger the ntoe\n\t\t *  @param {number} [velocity=1] the velocity to trigger the note\n\t\t */\n\t    Tone.Instrument.prototype.triggerAttack = Tone.noOp;\n\t    /**\n\t\t *  @abstract\n\t\t *  @param {Time} [time=now] when to trigger the release\n\t\t */\n\t    Tone.Instrument.prototype.triggerRelease = Tone.noOp;\n\t    /**\n\t\t *  Trigger the attack and then the release after the duration. \n\t\t *  @param  {Frequency} note     The note to trigger.\n\t\t *  @param  {Time} duration How long the note should be held for before\n\t\t *                          triggering the release. This value must be greater than 0. \n\t\t *  @param {Time} [time=now]  When the note should be triggered.\n\t\t *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.\n\t\t *  @returns {Tone.Instrument} this\n\t\t *  @example\n\t\t * //trigger \"C4\" for the duration of an 8th note\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(note, time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Instrument} this\n\t\t */\n\t    Tone.Instrument.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this._writable(['volume']);\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.Instrument;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  This is an abstract base class for other monophonic instruments to \n\t\t *          extend. IMPORTANT: It does not make any sound on its own and\n\t\t *          shouldn't be directly instantiated.\n\t\t *\n\t\t *  @constructor\n\t\t *  @abstract\n\t\t *  @extends {Tone.Instrument}\n\t\t */\n\t    Tone.Monophonic = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Monophonic.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The glide time between notes. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.portamento = options.portamento;\n\t    };\n\t    Tone.extend(Tone.Monophonic, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Monophonic.defaults = { 'portamento': 0 };\n\t    /**\n\t\t *  Trigger the attack of the note optionally with a given velocity. \n\t\t *  \n\t\t *  \n\t\t *  @param  {Frequency} note     The note to trigger.\n\t\t *  @param  {Time} [time=now]     When the note should start.\n\t\t *  @param  {number} [velocity=1] velocity The velocity scaler \n\t\t *                                determines how \"loud\" the note \n\t\t *                                will be triggered.\n\t\t *  @returns {Tone.Monophonic} this\n\t\t *  @example\n\t\t * synth.triggerAttack(\"C4\");\n\t\t *  @example\n\t\t * //trigger the note a half second from now at half velocity\n\t\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t\t */\n\t    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._triggerEnvelopeAttack(time, velocity);\n\t        this.setNote(note, time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of the envelope\n\t\t *  @param  {Time} [time=now] If no time is given, the release happens immediatly\n\t\t *  @returns {Tone.Monophonic} this\n\t\t *  @example\n\t\t * synth.triggerRelease();\n\t\t */\n\t    Tone.Monophonic.prototype.triggerRelease = function (time) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._triggerEnvelopeRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  override this method with the actual method\n\t\t *  @abstract\n\t\t *  @private\n\t\t */\n\t    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {\n\t    };\n\t    /**\n\t\t *  override this method with the actual method\n\t\t *  @abstract\n\t\t *  @private\n\t\t */\n\t    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {\n\t    };\n\t    /**\n\t\t *  Set the note at the given time. If no time is given, the note\n\t\t *  will set immediately. \n\t\t *  @param {Frequency} note The note to change to.\n\t\t *  @param  {Time} [time=now] The time when the note should be set. \n\t\t *  @returns {Tone.Monophonic} this\n\t\t * @example\n\t\t * //change to F#6 in one quarter note from now.\n\t\t * synth.setNote(\"F#6\", \"+4n\");\n\t\t * @example\n\t\t * //change to Bb4 right now\n\t\t * synth.setNote(\"Bb4\");\n\t\t */\n\t    Tone.Monophonic.prototype.setNote = function (note, time) {\n\t        time = this.toSeconds(time);\n\t        if (this.portamento > 0) {\n\t            var currentNote = this.frequency.value;\n\t            this.frequency.setValueAtTime(currentNote, time);\n\t            var portTime = this.toSeconds(this.portamento);\n\t            this.frequency.exponentialRampToValueAtTime(note, time + portTime);\n\t        } else {\n\t            this.frequency.setValueAtTime(note, time);\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Monophonic;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator\n\t\t *          routed through a Tone.AmplitudeEnvelope. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.Synth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.Synth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Synth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this.oscillator.frequency;\n\t        /**\n\t\t\t *  The detune control.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this.oscillator.detune;\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the oscillators to the output\n\t        this.oscillator.chain(this.envelope, this.output);\n\t        //start the oscillators\n\t        this.oscillator.start();\n\t        this._readOnly([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Synth, Tone.Monophonic);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Synth.defaults = {\n\t        'oscillator': { 'type': 'triangle' },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0.3,\n\t            'release': 1\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelope\n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {number} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.Synth} this\n\t\t *  @private\n\t\t */\n\t    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelope\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.Synth} this\n\t\t *  @private\n\t\t */\n\t    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Synth} this\n\t\t */\n\t    Tone.Synth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.Synth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  AMSynth uses the output of one Tone.Synth to modulate the\n\t\t *          amplitude of another Tone.Synth. The harmonicity (the ratio between\n\t\t *          the two signals) affects the timbre of the output signal greatly.\n\t\t *          Read more about Amplitude Modulation Synthesis on \n\t\t *          [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                            see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.AMSynth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"4n\");\n\t\t */\n\t    Tone.AMSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.AMSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The carrier voice. \n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Synth();\n\t        this._carrier.volume.value = -10;\n\t        /**\n\t\t\t *  The carrier's oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.oscillator = this._carrier.oscillator;\n\t        /**\n\t\t\t *  The carrier's envelope\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = this._carrier.envelope.set(options.envelope);\n\t        /**\n\t\t\t *  The modulator voice. \n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Synth();\n\t        this._modulator.volume.value = -10;\n\t        /**\n\t\t\t *  The modulator's oscillator which is applied\n\t\t\t *  to the amplitude of the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulation = this._modulator.oscillator.set(options.modulation);\n\t        /**\n\t\t\t *  The modulator's envelope\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);\n\t        /**\n\t\t\t *  The frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  convert the -1,1 output to 0,1\n\t\t\t *  @type {Tone.AudioToGain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationScale = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain();\n\t        //control the two voices frequency\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.detune.fan(this._carrier.detune, this._modulator.detune);\n\t        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t        this._carrier.chain(this._modulationNode, this.output);\n\t        this._readOnly([\n\t            'frequency',\n\t            'harmonicity',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AMSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AMSynth.defaults = {\n\t        'harmonicity': 3,\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.01,\n\t            'decay': 0.01,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        },\n\t        'modulation': { 'type': 'square' },\n\t        'modulationEnvelope': {\n\t            'attack': 0.5,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t *  trigger the attack portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will occur\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note\n\t\t *  @private\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the port glide\n\t        time = this.toSeconds(time);\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.modulationEnvelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  trigger the release portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @private\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        this.modulationEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'harmonicity',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._modulationScale.dispose();\n\t        this._modulationScale = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.oscillator = null;\n\t        this.envelope = null;\n\t        this.modulationEnvelope = null;\n\t        this.modulation = null;\n\t        return this;\n\t    };\n\t    return Tone.AMSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.\n\t\t *          The amplitude of the Tone.Oscillator and the cutoff frequency of the \n\t\t *          Tone.Filter are controlled by Tone.Envelopes. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n\t\t *          \n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.MonoSynth({\n\t\t * \t\"oscillator\" : {\n\t\t * \t\t\"type\" : \"square\"\n\t\t *  },\n\t\t *  \"envelope\" : {\n\t\t *  \t\"attack\" : 0.1\n\t\t *  }\n\t\t * }).toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.MonoSynth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.MonoSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this.oscillator.frequency;\n\t        /**\n\t\t\t *  The detune control.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this.oscillator.detune;\n\t        /**\n\t\t\t *  The filter.\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.filter = new Tone.Filter(options.filter);\n\t        /**\n\t\t\t *  The filter envelope.\n\t\t\t *  @type {Tone.FrequencyEnvelope}\n\t\t\t */\n\t        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the oscillators to the output\n\t        this.oscillator.chain(this.filter, this.envelope, this.output);\n\t        //start the oscillators\n\t        this.oscillator.start();\n\t        //connect the filter envelope\n\t        this.filterEnvelope.connect(this.filter.frequency);\n\t        this._readOnly([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'filter',\n\t            'filterEnvelope',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MonoSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MonoSynth.defaults = {\n\t        'frequency': 'C4',\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'square' },\n\t        'filter': {\n\t            'Q': 6,\n\t            'type': 'lowpass',\n\t            'rolloff': -24\n\t        },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0.9,\n\t            'release': 1\n\t        },\n\t        'filterEnvelope': {\n\t            'attack': 0.06,\n\t            'decay': 0.2,\n\t            'sustain': 0.5,\n\t            'release': 2,\n\t            'baseFrequency': 200,\n\t            'octaves': 7,\n\t            'exponent': 2\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelope\n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.filterEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelope\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        this.filterEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t */\n\t    Tone.MonoSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'filter',\n\t            'filterEnvelope',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this.filterEnvelope.dispose();\n\t        this.filterEnvelope = null;\n\t        this.filter.dispose();\n\t        this.filter = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.MonoSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.DuoSynth is a monophonic synth composed of two \n\t\t *          MonoSynths run in parallel with control over the \n\t\t *          frequency ratio between the two voices and vibrato effect.\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var duoSynth = new Tone.DuoSynth().toMaster();\n\t\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t\t */\n\t    Tone.DuoSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.DuoSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  the first voice\n\t\t\t *  @type {Tone.MonoSynth}\n\t\t\t */\n\t        this.voice0 = new Tone.MonoSynth(options.voice0);\n\t        this.voice0.volume.value = -10;\n\t        /**\n\t\t\t *  the second voice\n\t\t\t *  @type {Tone.MonoSynth}\n\t\t\t */\n\t        this.voice1 = new Tone.MonoSynth(options.voice1);\n\t        this.voice1.volume.value = -10;\n\t        /**\n\t\t\t *  The vibrato LFO. \n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);\n\t        this._vibrato.start();\n\t        /**\n\t\t\t * the vibrato frequency\n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.vibratoRate = this._vibrato.frequency;\n\t        /**\n\t\t\t *  the vibrato gain\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);\n\t        /**\n\t\t\t * The amount of vibrato\n\t\t\t * @type {Positive}\n\t\t\t * @signal\n\t\t\t */\n\t        this.vibratoAmount = this._vibratoGain.gain;\n\t        /**\n\t\t\t *  the frequency control\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * duoSynth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        //control the two voices frequency\n\t        this.frequency.connect(this.voice0.frequency);\n\t        this.frequency.chain(this.harmonicity, this.voice1.frequency);\n\t        this._vibrato.connect(this._vibratoGain);\n\t        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\t        this.voice0.connect(this.output);\n\t        this.voice1.connect(this.output);\n\t        this._readOnly([\n\t            'voice0',\n\t            'voice1',\n\t            'frequency',\n\t            'vibratoAmount',\n\t            'vibratoRate'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.DuoSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.DuoSynth.defaults = {\n\t        'vibratoAmount': 0.5,\n\t        'vibratoRate': 5,\n\t        'harmonicity': 1.5,\n\t        'voice0': {\n\t            'volume': -10,\n\t            'portamento': 0,\n\t            'oscillator': { 'type': 'sine' },\n\t            'filterEnvelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            },\n\t            'envelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            }\n\t        },\n\t        'voice1': {\n\t            'volume': -10,\n\t            'portamento': 0,\n\t            'oscillator': { 'type': 'sine' },\n\t            'filterEnvelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            },\n\t            'envelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelopes\n\t\t *  \n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.voice0.envelope.triggerAttack(time, velocity);\n\t        this.voice1.envelope.triggerAttack(time, velocity);\n\t        this.voice0.filterEnvelope.triggerAttack(time);\n\t        this.voice1.filterEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelopes\n\t\t *  \n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.voice0.triggerRelease(time);\n\t        this.voice1.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t */\n\t    Tone.DuoSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'voice0',\n\t            'voice1',\n\t            'frequency',\n\t            'vibratoAmount',\n\t            'vibratoRate'\n\t        ]);\n\t        this.voice0.dispose();\n\t        this.voice0 = null;\n\t        this.voice1.dispose();\n\t        this.voice1 = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._vibratoGain.dispose();\n\t        this._vibratoGain = null;\n\t        this._vibrato = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this.vibratoAmount.dispose();\n\t        this.vibratoAmount = null;\n\t        this.vibratoRate = null;\n\t        return this;\n\t    };\n\t    return Tone.DuoSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n\t\t *          the frequency of a second Tone.Synth. A lot of spectral content \n\t\t *          can be explored using the modulationIndex parameter. Read more about\n\t\t *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var fmSynth = new Tone.FMSynth().toMaster();\n\t\t * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t\t */\n\t    Tone.FMSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.FMSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The carrier voice.\n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Synth(options.carrier);\n\t        this._carrier.volume.value = -10;\n\t        /**\n\t\t\t *  The carrier's oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.oscillator = this._carrier.oscillator;\n\t        /**\n\t\t\t *  The carrier's envelope\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.envelope = this._carrier.envelope.set(options.envelope);\n\t        /**\n\t\t\t *  The modulator voice.\n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Synth(options.modulator);\n\t        this._modulator.volume.value = -10;\n\t        /**\n\t\t\t *  The modulator's oscillator which is applied\n\t\t\t *  to the amplitude of the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulation = this._modulator.oscillator.set(options.modulation);\n\t        /**\n\t\t\t *  The modulator's envelope\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  The modulation index which essentially the depth or amount of the modulation. It is the \n\t\t\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t\t *  modulating signal (ma) -- as in ma/mf. \n\t\t\t *\t@type {Positive}\n\t\t\t *\t@signal\n\t\t\t */\n\t        this.modulationIndex = new Tone.Multiply(options.modulationIndex);\n\t        this.modulationIndex.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //control the two voices frequency\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.frequency.chain(this.modulationIndex, this._modulationNode);\n\t        this.detune.fan(this._carrier.detune, this._modulator.detune);\n\t        this._modulator.connect(this._modulationNode.gain);\n\t        this._modulationNode.connect(this._carrier.frequency);\n\t        this._carrier.connect(this.output);\n\t        this._readOnly([\n\t            'frequency',\n\t            'harmonicity',\n\t            'modulationIndex',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FMSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FMSynth.defaults = {\n\t        'harmonicity': 3,\n\t        'modulationIndex': 10,\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.01,\n\t            'decay': 0.01,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        },\n\t        'modulation': { 'type': 'square' },\n\t        'modulationEnvelope': {\n\t            'attack': 0.5,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t * \ttrigger the attack portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will occur\n\t\t *  @param {number} [velocity=1] the velocity of the note\n\t\t *  @returns {Tone.FMSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.modulationEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  trigger the release portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @returns {Tone.FMSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        this.modulationEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FMSynth} this\n\t\t */\n\t    Tone.FMSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'harmonicity',\n\t            'modulationIndex',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.modulationIndex.dispose();\n\t        this.modulationIndex = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.oscillator = null;\n\t        this.envelope = null;\n\t        this.modulationEnvelope = null;\n\t        this.modulation = null;\n\t        return this;\n\t    };\n\t    return Tone.FMSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator\n\t\t *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n\t\t *          is routed through a Tone.AmplitudeEnvelope to the output. The drum\n\t\t *          quality of the sound comes from the frequency envelope applied\n\t\t *          during during Tone.MembraneSynth.triggerAttack(note). The frequency\n\t\t *          envelope starts at <code>note * .octaves</code> and ramps to \n\t\t *          <code>note</code> over the duration of <code>.pitchDecay</code>. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.MembraneSynth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C2\", \"8n\");\n\t\t */\n\t    Tone.MembraneSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.MembraneSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        /**\n\t\t\t *  The number of octaves the pitch envelope ramps.\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this.octaves = options.octaves;\n\t        /**\n\t\t\t *  The amount of time the frequency envelope takes. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.pitchDecay = options.pitchDecay;\n\t        this.oscillator.chain(this.envelope, this.output);\n\t        this._readOnly([\n\t            'oscillator',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MembraneSynth, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MembraneSynth.defaults = {\n\t        'pitchDecay': 0.05,\n\t        'octaves': 10,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 0.4,\n\t            'sustain': 0.01,\n\t            'release': 1.4,\n\t            'attackCurve': 'exponential'\n\t        }\n\t    };\n\t    /**\n\t\t *  Trigger the note at the given time with the given velocity. \n\t\t *  \n\t\t *  @param  {Frequency} note     the note\n\t\t *  @param  {Time} [time=now]     the time, if not given is now\n\t\t *  @param  {number} [velocity=1] velocity defaults to 1\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t *  @example\n\t\t *  kick.triggerAttack(60);\n\t\t */\n\t    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        note = this.toFrequency(note);\n\t        var maxNote = note * this.octaves;\n\t        this.oscillator.frequency.setValueAtTime(maxNote, time);\n\t        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of the note.\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t */\n\t    Tone.MembraneSynth.prototype.triggerRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t */\n\t    Tone.MembraneSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.MembraneSynth;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  Inharmonic ratio of frequencies based on the Roland TR-808\n\t\t *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var inharmRatios = [\n\t        1,\n\t        1.483,\n\t        1.932,\n\t        2.546,\n\t        2.63,\n\t        3.897\n\t    ];\n\t    /**\n\t\t *  @class  A highly inharmonic and spectrally complex source with a highpass filter\n\t\t *          and amplitude envelope which is good for making metalophone sounds. Based\n\t\t *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n\t\t *          Inspiration from [Sound on Sound](http://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] The options availble for the synth\n\t\t *                             see defaults below\n\t\t */\n\t    Tone.MetalSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.MetalSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The frequency of the cymbal\n\t\t\t *  @type  {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The array of FMOscillators\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillators = [];\n\t        /**\n\t\t\t *  The frequency multipliers\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._freqMultipliers = [];\n\t        /**\n\t\t\t *  The amplitude for the body\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitue = new Tone.Gain(0).connect(this.output);\n\t        /**\n\t\t\t *  highpass the output\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._highpass = new Tone.Filter({\n\t            'type': 'highpass',\n\t            'Q': -3.0102999566398125\n\t        }).connect(this._amplitue);\n\t        /**\n\t\t\t *  The number of octaves the highpass\n\t\t\t *  filter frequency ramps\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  Scale the body envelope\n\t\t\t *  for the bandpass\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);\n\t        /**\n\t\t\t *  The envelope which is connected both to the \n\t\t\t *  amplitude and highpass filter's cutoff frequency\n\t\t\t *  @type  {Tone.Envelope}\n\t\t\t */\n\t        this.envelope = new Tone.Envelope({\n\t            'attack': options.envelope.attack,\n\t            'attackCurve': 'linear',\n\t            'decay': options.envelope.decay,\n\t            'sustain': 0,\n\t            'release': options.envelope.release\n\t        }).chain(this._filterFreqScaler, this._highpass.frequency);\n\t        this.envelope.connect(this._amplitue.gain);\n\t        for (var i = 0; i < inharmRatios.length; i++) {\n\t            var osc = new Tone.FMOscillator({\n\t                'type': 'square',\n\t                'modulationType': 'square',\n\t                'harmonicity': options.harmonicity,\n\t                'modulationIndex': options.modulationIndex\n\t            });\n\t            osc.connect(this._highpass).start(0);\n\t            this._oscillators[i] = osc;\n\t            var mult = new Tone.Multiply(inharmRatios[i]);\n\t            this._freqMultipliers[i] = mult;\n\t            this.frequency.chain(mult, osc.frequency);\n\t        }\n\t        //set the octaves\n\t        this.octaves = options.octaves;\n\t    };\n\t    Tone.extend(Tone.MetalSynth, Tone.Instrument);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MetalSynth.defaults = {\n\t        'frequency': 200,\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 1.4,\n\t            'release': 0.2\n\t        },\n\t        'harmonicity': 5.1,\n\t        'modulationIndex': 32,\n\t        'resonance': 4000,\n\t        'octaves': 1.5\n\t    };\n\t    /**\n\t\t *  Trigger the attack.\n\t\t *  @param  {Time}  time      When the attack should be triggered.\n\t\t *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {\n\t        time = this.toSeconds(time);\n\t        vel = this.defaultArg(vel, 1);\n\t        this.envelope.triggerAttack(time, vel);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release of the envelope.\n\t\t *  @param  {Time}  time      When the release should be triggered.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and release of the envelope after the given \n\t\t *  duration. \n\t\t *  @param  {Time}  duration  The duration before triggering the release\n\t\t *  @param  {Time}  time      When the attack should be triggered.\n\t\t *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The modulationIndex of the oscillators which make up the source.\n\t\t *  see Tone.FMOscillator.modulationIndex\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Positive}\n\t\t *  @name  modulationIndex\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {\n\t        get: function () {\n\t            return this._oscillators[0].modulationIndex.value;\n\t        },\n\t        set: function (val) {\n\t            for (var i = 0; i < this._oscillators.length; i++) {\n\t                this._oscillators[i].modulationIndex.value = val;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The harmonicity of the oscillators which make up the source.\n\t\t *  see Tone.FMOscillator.harmonicity\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Positive}\n\t\t *  @name  harmonicity\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {\n\t        get: function () {\n\t            return this._oscillators[0].harmonicity.value;\n\t        },\n\t        set: function (val) {\n\t            for (var i = 0; i < this._oscillators.length; i++) {\n\t                this._oscillators[i].harmonicity.value = val;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The frequency of the highpass filter attached to the envelope\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Frequency}\n\t\t *  @name  resonance\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {\n\t        get: function () {\n\t            return this._filterFreqScaler.min;\n\t        },\n\t        set: function (val) {\n\t            this._filterFreqScaler.min = val;\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of octaves above the \"resonance\" frequency\n\t\t *  that the filter ramps during the attack/decay envelope\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Number}\n\t\t *  @name  octaves\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octs) {\n\t            this._octaves = octs;\n\t            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.MetalSynth} this\n\t\t */\n\t    Tone.MetalSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        for (var i = 0; i < this._oscillators.length; i++) {\n\t            this._oscillators[i].dispose();\n\t            this._freqMultipliers[i].dispose();\n\t        }\n\t        this._oscillators = null;\n\t        this._freqMultipliers = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._filterFreqScaler.dispose();\n\t        this._filterFreqScaler = null;\n\t        this._amplitue.dispose();\n\t        this._amplitue = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this._highpass.dispose();\n\t        this._highpass = null;\n\t    };\n\t    return Tone.MetalSynth;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  BufferSource polyfill\n\t\t */\n\t    if (window.AudioBufferSourceNode && !AudioBufferSourceNode.prototype.start) {\n\t        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;\n\t        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the native BufferSourceNode.\n\t\t *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n\t\t *  @param  {Function}  onended  The callback to invoke when the \n\t\t *                               buffer is done playing.\n\t\t */\n\t    Tone.BufferSource = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'buffer',\n\t            'onended'\n\t        ], Tone.BufferSource.defaults);\n\t        /**\n\t\t\t *  The callback to invoke after the \n\t\t\t *  buffer source is done playing. \n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.onended = options.onended;\n\t        /**\n\t\t\t *  The time that the buffer was started.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startTime = -1;\n\t        /**\n\t\t\t *  The time that the buffer is scheduled to stop.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stopTime = -1;\n\t        /**\n\t\t\t *  The gain node which envelopes the BufferSource\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gainNode = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  The buffer source\n\t\t\t *  @type  {AudioBufferSourceNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._source = this.context.createBufferSource();\n\t        this._source.connect(this._gainNode);\n\t        /**\n\t\t\t *  The playbackRate of the buffer\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);\n\t        /**\n\t\t\t *  The fadeIn time of the amplitude envelope.\n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.fadeIn = options.fadeIn;\n\t        /**\n\t\t\t *  The fadeOut time of the amplitude envelope.\n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.fadeOut = options.fadeOut;\n\t        /**\n\t\t\t *  The value that the buffer ramps to\n\t\t\t *  @type {Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gain = 1;\n\t        /**\n\t\t\t * The onended timeout\n\t\t\t * @type {Number}\n\t\t\t * @private\n\t\t\t */\n\t        this._onendedTimeout = -1;\n\t        //set the buffer initially\n\t        if (!this.isUndef(options.buffer)) {\n\t            this.buffer = options.buffer;\n\t        }\n\t        this.loop = options.loop;\n\t    };\n\t    Tone.extend(Tone.BufferSource);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.BufferSource.defaults = {\n\t        'onended': Tone.noOp,\n\t        'fadeIn': 0,\n\t        'fadeOut': 0\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.BufferSource#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'state', {\n\t        get: function () {\n\t            var now = this.now();\n\t            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {\n\t                return Tone.State.Started;\n\t            } else {\n\t                return Tone.State.Stopped;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the buffer\n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.\n\t\t *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {\n\t        if (this._startTime !== -1) {\n\t            throw new Error('Tone.BufferSource: can only be started once.');\n\t        }\n\t        if (this.buffer) {\n\t            time = this.toSeconds(time);\n\t            //if it's a loop the default offset is the loopstart point\n\t            if (this.loop) {\n\t                offset = this.defaultArg(offset, this.loopStart);\n\t            } else {\n\t                //otherwise the default offset is 0\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toSeconds(offset);\n\t            //the values in seconds\n\t            time = this.toSeconds(time);\n\t            this._source.start(time, offset);\n\t            gain = this.defaultArg(gain, 1);\n\t            this._gain = gain;\n\t            //the fadeIn time\n\t            if (this.isUndef(fadeInTime)) {\n\t                fadeInTime = this.toSeconds(this.fadeIn);\n\t            } else {\n\t                fadeInTime = this.toSeconds(fadeInTime);\n\t            }\n\t            if (fadeInTime > 0) {\n\t                this._gainNode.gain.setValueAtTime(0, time);\n\t                this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);\n\t            } else {\n\t                this._gainNode.gain.setValueAtTime(gain, time);\n\t            }\n\t            this._startTime = time + fadeInTime;\n\t            if (!this.isUndef(duration)) {\n\t                duration = this.defaultArg(duration, this.buffer.duration - offset);\n\t                duration = this.toSeconds(duration);\n\t                this.stop(time + duration + fadeInTime, fadeInTime);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the buffer. Optionally add a ramp time to fade the \n\t\t *  buffer out. \n\t\t *  @param  {Time=}  time         The time the buffer should stop.\n\t\t *  @param  {Time=}  fadeOutTime  How long the gain should fade out for\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {\n\t        if (this.buffer) {\n\t            time = this.toSeconds(time);\n\t            //the fadeOut time\n\t            if (this.isUndef(fadeOutTime)) {\n\t                fadeOutTime = this.toSeconds(this.fadeOut);\n\t            } else {\n\t                fadeOutTime = this.toSeconds(fadeOutTime);\n\t            }\n\t            this._stopTime = time + fadeOutTime;\n\t            //cancel the end curve\n\t            this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t            //set a new one\n\t            if (fadeOutTime > 0) {\n\t                this._gainNode.gain.setValueAtTime(this._gain, time);\n\t                this._gainNode.gain.linearRampToValueAtTime(0, time + fadeOutTime);\n\t                time += fadeOutTime;\n\t            } else {\n\t                this._gainNode.gain.setValueAtTime(0, time);\n\t            }\n\t            // fix for safari bug and old FF\n\t            if (!this.isNumber(this._source.playbackState) || this._source.playbackState === 2) {\n\t                this._source.stop(time);\n\t            }\n\t            clearTimeout(this._onendedTimeout);\n\t            this._onendedTimeout = setTimeout(this._onended.bind(this), (this._stopTime - this.now()) * 1000);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Internal callback when the buffer is ended. \n\t\t *  Invokes `onended` and disposes the node.\n\t\t *  @private\n\t\t */\n\t    Tone.BufferSource.prototype._onended = function () {\n\t        this.onended(this);\n\t        this.dispose();\n\t    };\n\t    /**\n\t\t * If loop is true, the loop will start at this position. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._source.loopStart;\n\t        },\n\t        set: function (loopStart) {\n\t            this._source.loopStart = this.toSeconds(loopStart);\n\t        }\n\t    });\n\t    /**\n\t\t * If loop is true, the loop will end at this position.\n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._source.loopEnd;\n\t        },\n\t        set: function (loopEnd) {\n\t            this._source.loopEnd = this.toSeconds(loopEnd);\n\t        }\n\t    });\n\t    /**\n\t\t * The audio buffer belonging to the player. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {AudioBuffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {\n\t        get: function () {\n\t            if (this._source) {\n\t                return this._source.buffer;\n\t            } else {\n\t                return null;\n\t            }\n\t        },\n\t        set: function (buffer) {\n\t            if (buffer instanceof Tone.Buffer) {\n\t                this._source.buffer = buffer.get();\n\t            } else {\n\t                this._source.buffer = buffer;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * If the buffer should loop once it's over. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {boolean}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {\n\t        get: function () {\n\t            return this._source.loop;\n\t        },\n\t        set: function (loop) {\n\t            this._source.loop = loop;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.dispose = function () {\n\t        this.onended = null;\n\t        if (this._source) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        if (this._gainNode) {\n\t            this._gainNode.dispose();\n\t            this._gainNode = null;\n\t        }\n\t        this._startTime = -1;\n\t        this.playbackRate = null;\n\t        this.output = null;\n\t        clearTimeout(this._onendedTimeout);\n\t        return this;\n\t    };\n\t    return Tone.BufferSource;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.\n\t\t *          Tone.Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n\t\t *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Source}\n\t\t *  @param {string} type the noise type (white|pink|brown)\n\t\t *  @example\n\t\t * //initialize the noise and start\n\t\t * var noise = new Tone.Noise(\"pink\").start();\n\t\t * \n\t\t * //make an autofilter to shape the noise\n\t\t * var autoFilter = new Tone.AutoFilter({\n\t\t * \t\"frequency\" : \"8m\", \n\t\t * \t\"min\" : 800, \n\t\t * \t\"max\" : 15000\n\t\t * }).connect(Tone.Master);\n\t\t * \n\t\t * //connect the noise\n\t\t * noise.connect(autoFilter);\n\t\t * //start the autofilter LFO\n\t\t * autoFilter.start()\n\t\t */\n\t    Tone.Noise = function () {\n\t        var options = this.optionsObject(arguments, ['type'], Tone.Noise.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {AudioBufferSourceNode}\n\t\t\t */\n\t        this._source = null;\n\t        /**\n\t\t\t *  the buffer\n\t\t\t *  @private\n\t\t\t *  @type {AudioBuffer}\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The playback rate of the noise. Affects\n\t\t\t *  the \"frequency\" of the noise.\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t    };\n\t    Tone.extend(Tone.Noise, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Noise.defaults = {\n\t        'type': 'white',\n\t        'playbackRate': 1\n\t    };\n\t    /**\n\t\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\". \n\t\t * @memberOf Tone.Noise#\n\t\t * @type {string}\n\t\t * @name type\n\t\t * @example\n\t\t * noise.type = \"white\";\n\t\t */\n\t    Object.defineProperty(Tone.Noise.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            if (this._type !== type) {\n\t                if (type in _noiseBuffers) {\n\t                    this._type = type;\n\t                    //if it's playing, stop and restart it\n\t                    if (this.state === Tone.State.Started) {\n\t                        var now = this.now() + this.blockTime;\n\t                        this._stop(now);\n\t                        this._start(now);\n\t                    }\n\t                } else {\n\t                    throw new TypeError('Tone.Noise: invalid type: ' + type);\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The playback rate of the noise. Affects\n\t\t *  the \"frequency\" of the noise.\n\t\t *  @type {Positive}\n\t\t *  @signal\n\t\t */\n\t    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            if (this._source) {\n\t                this._source.playbackRate.value = rate;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  internal start method\n\t\t *\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.Noise.prototype._start = function (time) {\n\t        var buffer = _noiseBuffers[this._type];\n\t        this._source = new Tone.BufferSource(buffer).connect(this.output);\n\t        this._source.loop = true;\n\t        this._source.playbackRate.value = this._playbackRate;\n\t        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t    };\n\t    /**\n\t\t *  internal stop method\n\t\t *\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.Noise.prototype._stop = function (time) {\n\t        if (this._source) {\n\t            this._source.stop(this.toSeconds(time));\n\t            this._source = null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Noise} this\n\t\t */\n\t    Tone.Noise.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._source !== null) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // THE BUFFERS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //Noise buffer stats\n\t    var bufferLength = 44100 * 5;\n\t    var channels = 2;\n\t    /**\n\t\t *\tthe noise arrays. only generated once on init\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Array}\n\t\t *  borrowed heavily from https://github.com/zacharydenton/noise.js \n\t\t *  (c) 2013 Zach Denton (MIT)\n\t\t */\n\t    var _noiseArrays = {\n\t        'pink': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                var b0, b1, b2, b3, b4, b5, b6;\n\t                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    var white = Math.random() * 2 - 1;\n\t                    b0 = 0.99886 * b0 + white * 0.0555179;\n\t                    b1 = 0.99332 * b1 + white * 0.0750759;\n\t                    b2 = 0.969 * b2 + white * 0.153852;\n\t                    b3 = 0.8665 * b3 + white * 0.3104856;\n\t                    b4 = 0.55 * b4 + white * 0.5329522;\n\t                    b5 = -0.7616 * b5 - white * 0.016898;\n\t                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t                    channel[i] *= 0.11;\n\t                    // (roughly) compensate for gain\n\t                    b6 = white * 0.115926;\n\t                }\n\t            }\n\t            return buffer;\n\t        }(),\n\t        'brown': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                var lastOut = 0;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    var white = Math.random() * 2 - 1;\n\t                    channel[i] = (lastOut + 0.02 * white) / 1.02;\n\t                    lastOut = channel[i];\n\t                    channel[i] *= 3.5;    // (roughly) compensate for gain\n\t                }\n\t            }\n\t            return buffer;\n\t        }(),\n\t        'white': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    channel[i] = Math.random() * 2 - 1;\n\t                }\n\t            }\n\t            return buffer;\n\t        }()\n\t    };\n\t    /**\n\t\t *\tstatic noise buffers\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Tone.Buffer}\n\t\t */\n\t    var _noiseBuffers = {};\n\t    //create the Tone.Buffers\n\t    function createBuffers() {\n\t        for (var type in _noiseArrays) {\n\t            _noiseBuffers[type] = new Tone.Buffer().fromArray(_noiseArrays[type]);\n\t        }\n\t    }\n\t    createBuffers();\n\t    Tone.Context.on('init', createBuffers);\n\t    return Tone.Noise;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), \n\t\t *          and two envelopes (Tone.Envelop). One envelope controls the amplitude\n\t\t *          of the noise and the other is controls the cutoff frequency of the filter. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t * @example\n\t\t * var noiseSynth = new Tone.NoiseSynth().toMaster();\n\t\t * noiseSynth.triggerAttackRelease(\"8n\");\n\t\t */\n\t    Tone.NoiseSynth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.NoiseSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The noise source.\n\t\t\t *  @type {Tone.Noise}\n\t\t\t *  @example\n\t\t\t * noiseSynth.set(\"noise.type\", \"brown\");\n\t\t\t */\n\t        this.noise = new Tone.Noise();\n\t        /**\n\t\t\t *  The amplitude envelope. \n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the noise to the output\n\t        this.noise.chain(this.envelope, this.output);\n\t        //start the noise\n\t        this.noise.start();\n\t        this._readOnly([\n\t            'noise',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.NoiseSynth, Tone.Instrument);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.NoiseSynth.defaults = {\n\t        'noise': { 'type': 'white' },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0\n\t        }\n\t    };\n\t    /**\n\t\t *  Start the attack portion of the envelopes. Unlike other \n\t\t *  instruments, Tone.NoiseSynth doesn't have a note. \n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {number} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t *  @example\n\t\t * noiseSynth.triggerAttack();\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the release portion of the envelopes.\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and then the release. \n\t\t *  @param  {Time} duration the duration of the note\n\t\t *  @param  {Time} [time=now]     the time of the attack\n\t\t *  @param  {number} [velocity=1] the velocity\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'noise',\n\t            'envelope'\n\t        ]);\n\t        this.noise.dispose();\n\t        this.noise = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.NoiseSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Karplus-String string synthesis. Often out of tune. \n\t\t *         Will change when the AudioWorkerNode is available across\n\t\t *         browsers. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] see the defaults\n\t\t *  @example\n\t\t * var plucky = new Tone.PluckSynth().toMaster();\n\t\t * plucky.triggerAttack(\"C4\");\n\t\t */\n\t    Tone.PluckSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.PluckSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  @type {Tone.Noise}\n\t\t\t *  @private\n\t\t\t */\n\t        this._noise = new Tone.Noise('pink');\n\t        /**\n\t\t\t *  The amount of noise at the attack. \n\t\t\t *  Nominal range of [0.1, 20]\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this.attackNoise = options.attackNoise;\n\t        /**\n\t\t\t *  the LFCF\n\t\t\t *  @type {Tone.LowpassCombFilter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfcf = new Tone.LowpassCombFilter({\n\t            'resonance': options.resonance,\n\t            'dampening': options.dampening\n\t        });\n\t        /**\n\t\t\t *  The resonance control. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._lfcf.resonance;\n\t        /**\n\t\t\t *  The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = this._lfcf.dampening;\n\t        //connections\n\t        this._noise.connect(this._lfcf);\n\t        this._lfcf.connect(this.output);\n\t        this._readOnly([\n\t            'resonance',\n\t            'dampening'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PluckSynth, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PluckSynth.defaults = {\n\t        'attackNoise': 1,\n\t        'dampening': 4000,\n\t        'resonance': 0.9\n\t    };\n\t    /**\n\t\t *  Trigger the note. \n\t\t *  @param {Frequency} note The note to trigger.\n\t\t *  @param {Time} [time=now] When the note should be triggered.\n\t\t *  @returns {Tone.PluckSynth} this\n\t\t */\n\t    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {\n\t        note = this.toFrequency(note);\n\t        time = this.toSeconds(time);\n\t        var delayAmount = 1 / note;\n\t        this._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t        this._noise.start(time);\n\t        this._noise.stop(time + delayAmount * this.attackNoise);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.PluckSynth} this\n\t\t */\n\t    Tone.PluckSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._noise.dispose();\n\t        this._lfcf.dispose();\n\t        this._noise = null;\n\t        this._lfcf = null;\n\t        this._writable([\n\t            'resonance',\n\t            'dampening'\n\t        ]);\n\t        this.dampening = null;\n\t        this.resonance = null;\n\t        return this;\n\t    };\n\t    return Tone.PluckSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.PolySynth handles voice creation and allocation for any\n\t\t *          instruments passed in as the second paramter. PolySynth is \n\t\t *          not a synthesizer by itself, it merely manages voices of \n\t\t *          one of the other types of synths, allowing any of the \n\t\t *          monophonic synthesizers to be polyphonic. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {number|Object} [polyphony=4] The number of voices to create\n\t\t *  @param {function} [voice=Tone.Synth] The constructor of the voices\n\t\t *                                            uses Tone.Synth by default. \n\t\t *  @example\n\t\t * //a polysynth composed of 6 Voices of Synth\n\t\t * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();\n\t\t * //set the attributes using the set interface\n\t\t * synth.set(\"detune\", -1200);\n\t\t * //play a chord\n\t\t * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], \"4n\");\n\t\t */\n\t    Tone.PolySynth = function () {\n\t        Tone.Instrument.call(this);\n\t        var options = this.optionsObject(arguments, [\n\t            'polyphony',\n\t            'voice'\n\t        ], Tone.PolySynth.defaults);\n\t        options = this.defaultArg(options, Tone.Instrument.defaults);\n\t        //max polyphony\n\t        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);\n\t        /**\n\t\t\t *  the array of voices\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.voices = new Array(options.polyphony);\n\t        /**\n\t\t\t *  The queue of voices with data about last trigger\n\t\t\t *  and the triggered note\n\t\t\t *  @private\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this._triggers = new Array(options.polyphony);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        this._readOnly('detune');\n\t        //create the voices\n\t        for (var i = 0; i < options.polyphony; i++) {\n\t            var v = new options.voice(arguments[2], arguments[3]);\n\t            this.voices[i] = v;\n\t            v.connect(this.output);\n\t            if (v.hasOwnProperty('detune')) {\n\t                this.detune.connect(v.detune);\n\t            }\n\t            this._triggers[i] = {\n\t                release: -1,\n\t                note: null,\n\t                voice: v\n\t            };\n\t        }\n\t        //set the volume initially\n\t        this.volume.value = options.volume;\n\t    };\n\t    Tone.extend(Tone.PolySynth, Tone.Instrument);\n\t    /**\n\t\t *  the defaults\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PolySynth.defaults = {\n\t        'polyphony': 4,\n\t        'volume': 0,\n\t        'detune': 0,\n\t        'voice': Tone.Synth\n\t    };\n\t    /**\n\t\t *  Trigger the attack portion of the note\n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} [time=now]  The start time of the note.\n\t\t *  @param {number} [velocity=1] The velocity of the note.\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * //trigger a chord immediately with a velocity of 0.2\n\t\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"], undefined, 0.2);\n\t\t */\n\t    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {\n\t        if (!Array.isArray(notes)) {\n\t            notes = [notes];\n\t        }\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < notes.length; i++) {\n\t            var val = notes[i];\n\t            //trigger the oldest voice\n\t            var oldest = this._triggers[0];\n\t            var oldestIndex = 0;\n\t            for (var j = 1; j < this._triggers.length; j++) {\n\t                if (this._triggers[j].release < oldest.release) {\n\t                    oldest = this._triggers[j];\n\t                    oldestIndex = j;\n\t                }\n\t            }\n\t            oldest.release = Infinity;\n\t            oldest.note = JSON.stringify(val);\n\t            oldest.voice.triggerAttack(val, time, velocity);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and release after the specified duration\n\t\t *  \n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} duration the duration of the note\n\t\t *  @param  {Time} [time=now]     if no time is given, defaults to now\n\t\t *  @param  {number} [velocity=1] the velocity of the attack (0-1)\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * //trigger a chord for a duration of a half note \n\t\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], \"2n\");\n\t\t *  @example\n\t\t * //can pass in an array of durations as well\n\t\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], [\"2n\", \"4n\", \"4n\"]);\n\t\t */\n\t    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.triggerAttack(notes, time, velocity);\n\t        if (this.isArray(duration) && this.isArray(notes)) {\n\t            for (var i = 0; i < notes.length; i++) {\n\t                var d = duration[Math.min(i, duration.length - 1)];\n\t                this.triggerRelease(notes[i], time + this.toSeconds(d));\n\t            }\n\t        } else {\n\t            this.triggerRelease(notes, time + this.toSeconds(duration));\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release of the note. Unlike monophonic instruments, \n\t\t *  a note (or array of notes) needs to be passed in as the first argument.\n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} [time=now]  When the release will be triggered. \n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * poly.triggerRelease([\"Ab3\", \"C4\", \"F5\"], \"+2n\");\n\t\t */\n\t    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {\n\t        if (!Array.isArray(notes)) {\n\t            notes = [notes];\n\t        }\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < notes.length; i++) {\n\t            //get the voice\n\t            var stringified = JSON.stringify(notes[i]);\n\t            for (var v = 0; v < this._triggers.length; v++) {\n\t                var desc = this._triggers[v];\n\t                if (desc.note === stringified && desc.release > time) {\n\t                    desc.voice.triggerRelease(time);\n\t                    desc.release = time;\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set a member/attribute of the voices. \n\t\t *  @param {Object|string} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * poly.set({\n\t\t * \t\"filter\" : {\n\t\t * \t\t\"type\" : \"highpass\"\n\t\t * \t},\n\t\t * \t\"envelope\" : {\n\t\t * \t\t\"attack\" : 0.25\n\t\t * \t}\n\t\t * });\n\t\t */\n\t    Tone.PolySynth.prototype.set = function (params, value, rampTime) {\n\t        for (var i = 0; i < this.voices.length; i++) {\n\t            this.voices[i].set(params, value, rampTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the synth's attributes. Given no arguments get\n\t\t *  will return all available object properties and their corresponding\n\t\t *  values. Pass in a single attribute to retrieve or an array\n\t\t *  of attributes. The attribute strings can also include a \".\"\n\t\t *  to access deeper properties.\n\t\t *  @param {Array=} params the parameters to get, otherwise will return \n\t\t *  \t\t\t\t\t   all available.\n\t\t */\n\t    Tone.PolySynth.prototype.get = function (params) {\n\t        return this.voices[0].get(params);\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of all the currently active voices.\n\t\t *  @param {Time} [time=now] When the notes should be released.\n\t\t *  @return {Tone.PolySynth} this\n\t\t */\n\t    Tone.PolySynth.prototype.releaseAll = function (time) {\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < this._triggers.length; i++) {\n\t            var desc = this._triggers[i];\n\t            if (desc.release > time) {\n\t                desc.release = time;\n\t                desc.voice.triggerRelease(time);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.PolySynth} this\n\t\t */\n\t    Tone.PolySynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        for (var i = 0; i < this.voices.length; i++) {\n\t            this.voices[i].dispose();\n\t            this.voices[i] = null;\n\t        }\n\t        this._writable('detune');\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.voices = null;\n\t        this._triggers = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The maximum number of notes that can be allocated \n\t\t *  to a polysynth. \n\t\t *  @type  {Number}\n\t\t *  @static\n\t\t */\n\t    Tone.PolySynth.MAX_POLYPHONY = 20;\n\t    return Tone.PolySynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Player is an audio file player with start, loop, and stop functions.\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Source} \n\t\t *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from\n\t\t *                                  which to load the AudioBuffer\n\t\t *  @param {function=} onload The function to invoke when the buffer is loaded. \n\t\t *                            Recommended to use Tone.Buffer.on('load') instead.\n\t\t *  @example\n\t\t * var player = new Tone.Player(\"./path/to/sample.mp3\").toMaster();\n\t\t * //play as soon as the buffer is loaded\n\t\t * player.autostart = true;\n\t\t */\n\t    Tone.Player = function (url) {\n\t        var options;\n\t        if (url instanceof Tone.Buffer) {\n\t            url = url.get();\n\t            options = Tone.Player.defaults;\n\t        } else {\n\t            options = this.optionsObject(arguments, [\n\t                'url',\n\t                'onload'\n\t            ], Tone.Player.defaults);\n\t        }\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {AudioBufferSourceNode}\n\t\t\t */\n\t        this._source = null;\n\t        /**\n\t\t\t *  If the file should play as soon\n\t\t\t *  as the buffer is loaded. \n\t\t\t *  @type {boolean}\n\t\t\t *  @example\n\t\t\t * //will play as soon as it's loaded\n\t\t\t * var player = new Tone.Player({\n\t\t\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t\t\t * \t\"autostart\" : true,\n\t\t\t * }).toMaster();\n\t\t\t */\n\t        this.autostart = options.autostart;\n\t        /**\n\t\t\t *  the buffer\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Buffer}\n\t\t\t */\n\t        this._buffer = new Tone.Buffer({\n\t            'url': options.url,\n\t            'onload': this._onload.bind(this, options.onload),\n\t            'reverse': options.reverse\n\t        });\n\t        if (url instanceof AudioBuffer) {\n\t            this._buffer.set(url);\n\t        }\n\t        /**\n\t\t\t *  if the buffer should loop once it's over\n\t\t\t *  @type {boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  if 'loop' is true, the loop will start at this position\n\t\t\t *  @type {Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = options.loopStart;\n\t        /**\n\t\t\t *  if 'loop' is true, the loop will end at this position\n\t\t\t *  @type {Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = options.loopEnd;\n\t        /**\n\t\t\t *  the playback rate\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  Enabling retrigger will allow a player to be restarted\n\t\t\t *  before the the previous 'start' is done playing. Otherwise, \n\t\t\t *  successive calls to Tone.Player.start will only start\n\t\t\t *  the sample if it had played all the way through. \n\t\t\t *  @type {boolean}\n\t\t\t */\n\t        this.retrigger = options.retrigger;\n\t    };\n\t    Tone.extend(Tone.Player, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Player.defaults = {\n\t        'onload': Tone.noOp,\n\t        'playbackRate': 1,\n\t        'loop': false,\n\t        'autostart': false,\n\t        'loopStart': 0,\n\t        'loopEnd': 0,\n\t        'retrigger': false,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Load the audio file as an audio buffer.\n\t\t *  Decodes the audio asynchronously and invokes\n\t\t *  the callback once the audio buffer loads. \n\t\t *  Note: this does not need to be called if a url\n\t\t *  was passed in to the constructor. Only use this\n\t\t *  if you want to manually load a new url. \n\t\t * @param {string} url The url of the buffer to load.\n\t\t *                     Filetype support depends on the\n\t\t *                     browser.\n\t\t *  @param  {function=} callback The function to invoke once\n\t\t *                               the sample is loaded.\n\t\t *  @returns {Promise}\n\t\t */\n\t    Tone.Player.prototype.load = function (url, callback) {\n\t        return this._buffer.load(url, this._onload.bind(this, callback));\n\t    };\n\t    /**\n\t\t * Internal callback when the buffer is loaded.\n\t\t * @private\n\t\t */\n\t    Tone.Player.prototype._onload = function (callback) {\n\t        callback = this.defaultArg(callback, Tone.noOp);\n\t        callback(this);\n\t        if (this.autostart) {\n\t            this.start();\n\t        }\n\t    };\n\t    /**\n\t\t *  Play the buffer at the given startTime. Optionally add an offset\n\t\t *  and/or duration which will play the buffer from a position\n\t\t *  within the buffer for the given duration. \n\t\t *  \n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @returns {Tone.Player} this\n\t\t *  @memberOf Tone.Player#\n\t\t *  @method start\n\t\t *  @name start\n\t\t */\n\t    /**\n\t\t *  Internal start method\n\t\t *  @private\n\t\t */\n\t    Tone.Player.prototype._start = function (startTime, offset, duration) {\n\t        if (this._buffer.loaded) {\n\t            //if it's a loop the default offset is the loopstart point\n\t            if (this._loop) {\n\t                offset = this.defaultArg(offset, this._loopStart);\n\t            } else {\n\t                //otherwise the default offset is 0\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toSeconds(offset);\n\t            //make sure it has a positive duration\n\t            duration = this.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));\n\t            duration = this.toSeconds(duration);\n\t            //the values in seconds\n\t            startTime = this.toSeconds(startTime);\n\t            //make the source\n\t            this._source = this.context.createBufferSource();\n\t            this._source.buffer = this._buffer.get();\n\t            //set the looping properties\n\t            if (this._loop) {\n\t                this._source.loop = this._loop;\n\t                this._source.loopStart = this.toSeconds(this._loopStart);\n\t                this._source.loopEnd = this.toSeconds(this._loopEnd);\n\t            } else if (!this._synced) {\n\t                //if it's not looping, set the state change at the end of the sample\n\t                this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);\n\t            }\n\t            //and other properties\n\t            this._source.playbackRate.value = this._playbackRate;\n\t            this._source.connect(this.output);\n\t            //start it\n\t            if (this._loop) {\n\t                //modify the offset if it's greater than the loop time\n\t                var loopEnd = this._source.loopEnd || this._buffer.duration;\n\t                var loopStart = this._source.loopStart;\n\t                var loopDuration = loopEnd - loopStart;\n\t                if (offset > loopEnd) {\n\t                    //move the offset back\n\t                    while (offset > loopEnd) {\n\t                        offset -= loopDuration;\n\t                    }\n\t                }\n\t                this._source.start(startTime, offset);\n\t            } else {\n\t                this._source.start(startTime, offset, duration);\n\t            }\n\t        } else {\n\t            throw Error('Tone.Player: tried to start Player before the buffer was loaded');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop playback.\n\t\t *  @private\n\t\t *  @param  {Time} [time=now]\n\t\t *  @returns {Tone.Player} this\n\t\t */\n\t    Tone.Player.prototype._stop = function (time) {\n\t        if (this._source) {\n\t            this._source.stop(this.toSeconds(time));\n\t            this._source = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Seek to a specific time in the player's buffer. If the \n\t\t *  source is no longer playing at that time, it will stop.\n\t\t *  If you seek to a time that \n\t\t *  @param {Time} offset The time to seek to.\n\t\t *  @param {Time=} time The time for the seek event to occur.\n\t\t *  @return {Tone.Player} this\n\t\t *  @example\n\t\t * source.start(0.2);\n\t\t * source.stop(0.4);\n\t\t */\n\t    Tone.Player.prototype.seek = function (offset, time) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            offset = this.toSeconds(offset);\n\t            // if it's currently playing, stop it\n\t            this._stop(time);\n\t            //restart it at the given time\n\t            this._start(time, offset);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the loop start and end. Will only loop if loop is \n\t\t *  set to true. \n\t\t *  @param {Time} loopStart The loop end time\n\t\t *  @param {Time} loopEnd The loop end time\n\t\t *  @returns {Tone.Player} this\n\t\t *  @example\n\t\t * //loop 0.1 seconds of the file. \n\t\t * player.setLoopPoints(0.2, 0.3);\n\t\t * player.loop = true;\n\t\t */\n\t    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {\n\t        this.loopStart = loopStart;\n\t        this.loopEnd = loopEnd;\n\t        return this;\n\t    };\n\t    /**\n\t\t * If loop is true, the loop will start at this position. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._loopStart;\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = loopStart;\n\t            if (this._source) {\n\t                this._source.loopStart = this.toSeconds(loopStart);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * If loop is true, the loop will end at this position.\n\t\t * @memberOf Tone.Player#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._loopEnd;\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = loopEnd;\n\t            if (this._source) {\n\t                this._source.loopEnd = this.toSeconds(loopEnd);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The audio buffer belonging to the player. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {Tone.Buffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'buffer', {\n\t        get: function () {\n\t            return this._buffer;\n\t        },\n\t        set: function (buffer) {\n\t            this._buffer.set(buffer);\n\t        }\n\t    });\n\t    /**\n\t\t * If the buffer should loop once it's over. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {boolean}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            if (this._source) {\n\t                this._source.loop = loop;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The playback speed. 1 is normal speed. This is not a signal because\n\t\t * Safari and iOS currently don't support playbackRate as a signal.\n\t\t * @memberOf Tone.Player#\n\t\t * @type {number}\n\t\t * @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            if (this._source) {\n\t                this._source.playbackRate.value = rate;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.Player#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'reverse', {\n\t        get: function () {\n\t            return this._buffer.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this._buffer.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t *  Dispose and disconnect.\n\t\t *  @return {Tone.Player} this\n\t\t */\n\t    Tone.Player.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._source !== null) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        this._buffer.dispose();\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    return Tone.Player;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Sampler wraps Tone.Player in an AmplitudeEnvelope.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {String} url the url of the audio file\n\t\t *  @param {Function=} onload The callback to invoke when the sample is loaded.\n\t\t *  @example\n\t\t * var sampler = new Sampler(\"./audio/casio/A1.mp3\", function(){\n\t\t * \t//repitch the sample down a half step\n\t\t * \tsampler.triggerAttack(-1);\n\t\t * }).toMaster();\n\t\t */\n\t    Tone.Sampler = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.Sampler.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The sample player.\n\t\t\t *  @type {Tone.Player}\n\t\t\t */\n\t        this.player = new Tone.Player(options.url, options.onload);\n\t        this.player.retrigger = true;\n\t        /**\n\t\t\t *  The amplitude envelope. \n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        this.player.chain(this.envelope, this.output);\n\t        this._readOnly([\n\t            'player',\n\t            'envelope'\n\t        ]);\n\t        this.loop = options.loop;\n\t        this.reverse = options.reverse;\n\t    };\n\t    Tone.extend(Tone.Sampler, Tone.Instrument);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.Sampler.defaults = {\n\t        'onload': Tone.noOp,\n\t        'loop': false,\n\t        'reverse': false,\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.1\n\t        }\n\t    };\n\t    /**\n\t\t *  Trigger the start of the sample. \n\t\t *  @param {Interval} [pitch=0] The amount the sample should\n\t\t *                              be repitched. \n\t\t *  @param {Time} [time=now] The time when the sample should start\n\t\t *  @param {NormalRange} [velocity=1] The velocity of the note\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * sampler.triggerAttack(0, \"+0.1\", 0.5);\n\t\t */\n\t    Tone.Sampler.prototype.triggerAttack = function (pitch, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        pitch = this.defaultArg(pitch, 0);\n\t        this.player.playbackRate = this.intervalToFrequencyRatio(pitch);\n\t        this.player.start(time);\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the release portion of the sample. Will stop the sample once the \n\t\t *  envelope has fully released. \n\t\t *  \n\t\t *  @param {Time} [time=now] The time when the note should release\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * sampler.triggerRelease();\n\t\t */\n\t    Tone.Sampler.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        this.player.stop(this.toSeconds(this.envelope.release) + time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and then the release after the duration. \n\t\t *  @param  {Interval} interval     The interval in half-steps that the\n\t\t *                                  sample should be pitch shifted.\n\t\t *  @param  {Time} duration How long the note should be held for before\n\t\t *                          triggering the release.\n\t\t *  @param {Time} [time=now]  When the note should be triggered.\n\t\t *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * //trigger the unpitched note for the duration of an 8th note\n\t\t * synth.triggerAttackRelease(0, \"8n\");\n\t\t *  @memberOf Tone.Sampler#\n\t\t *  @name triggerAttackRelease\n\t\t *  @method triggerAttackRelease\n\t\t */\n\t    /**\n\t\t * If the output sample should loop or not.\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {number|string}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'loop', {\n\t        get: function () {\n\t            return this.player.loop;\n\t        },\n\t        set: function (loop) {\n\t            this.player.loop = loop;\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'reverse', {\n\t        get: function () {\n\t            return this.player.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this.player.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t * The buffer to play.\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {Tone.Buffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'buffer', {\n\t        get: function () {\n\t            return this.player.buffer;\n\t        },\n\t        set: function (buff) {\n\t            this.player.buffer = buff;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Sampler} this\n\t\t */\n\t    Tone.Sampler.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'player',\n\t            'envelope'\n\t        ]);\n\t        this.player.dispose();\n\t        this.player = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.Sampler;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. \n\t\t *         See also Tone.AudioToGain. \n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t * var g2a = new Tone.GainToAudio();\n\t\t */\n\t    Tone.GainToAudio = function () {\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {\n\t            return Math.abs(x) * 2 - 1;\n\t        });\n\t    };\n\t    Tone.extend(Tone.GainToAudio, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.GainToAudio} this\n\t\t */\n\t    Tone.GainToAudio.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._norm.dispose();\n\t        this._norm = null;\n\t        return this;\n\t    };\n\t    return Tone.GainToAudio;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {number} inputMin the min input value\n\t\t *  @param {number} inputMax the max input value\n\t\t *  @example\n\t\t * var norm = new Tone.Normalize(2, 4);\n\t\t * var sig = new Tone.Signal(3).connect(norm);\n\t\t * //output of norm is 0.5. \n\t\t */\n\t    Tone.Normalize = function (inputMin, inputMax) {\n\t        /**\n\t\t\t *  the min input value\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputMin = this.defaultArg(inputMin, 0);\n\t        /**\n\t\t\t *  the max input value\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputMax = this.defaultArg(inputMax, 1);\n\t        /**\n\t\t\t *  subtract the min from the input\n\t\t\t *  @type {Tone.Add}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sub = this.input = new Tone.Add(0);\n\t        /**\n\t\t\t *  divide by the difference between the input and output\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._div = this.output = new Tone.Multiply(1);\n\t        this._sub.connect(this._div);\n\t        this._setRange();\n\t    };\n\t    Tone.extend(Tone.Normalize, Tone.SignalBase);\n\t    /**\n\t\t * The minimum value the input signal will reach.\n\t\t * @memberOf Tone.Normalize#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.Normalize.prototype, 'min', {\n\t        get: function () {\n\t            return this._inputMin;\n\t        },\n\t        set: function (min) {\n\t            this._inputMin = min;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum value the input signal will reach.\n\t\t * @memberOf Tone.Normalize#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.Normalize.prototype, 'max', {\n\t        get: function () {\n\t            return this._inputMax;\n\t        },\n\t        set: function (max) {\n\t            this._inputMax = max;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t *  set the values\n\t\t *  @private\n\t\t */\n\t    Tone.Normalize.prototype._setRange = function () {\n\t        this._sub.value = -this._inputMin;\n\t        this._div.value = 1 / (this._inputMax - this._inputMin);\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Normalize} this\n\t\t */\n\t    Tone.Normalize.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sub.dispose();\n\t        this._sub = null;\n\t        this._div.dispose();\n\t        this._div = null;\n\t        return this;\n\t    };\n\t    return Tone.Normalize;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.MultiPlayer is well suited for one-shots, multi-sampled instruments\n\t\t *         or any time you need to play a bunch of audio buffers. \n\t\t *  @param  {Object|Array|Tone.Buffers}  buffers  The buffers which are available\n\t\t *                                                to the MultiPlayer\n\t\t *  @param {Function} onload The callback to invoke when all of the buffers are loaded.\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var multiPlayer = new MultiPlayer({\n\t\t * \t\"kick\" : \"path/to/kick.mp3\",\n\t\t * \t\"snare\" : \"path/to/snare.mp3\",\n\t\t * }, function(){\n\t\t * \tmultiPlayer.start(\"kick\");\n\t\t * });\n\t\t *  @example\n\t\t * //can also store the values in an array\n\t\t * var multiPlayer = new MultiPlayer([\"path/to/kick.mp3\", \"path/to/snare.mp3\"], \n\t\t * function(){\n\t\t * \t//if an array is passed in, the samples are referenced to by index\n\t\t * \tmultiPlayer.start(1);\n\t\t * });\n\t\t */\n\t    Tone.MultiPlayer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'urls',\n\t            'onload'\n\t        ], Tone.MultiPlayer.defaults);\n\t        if (options.urls instanceof Tone.Buffers) {\n\t            /**\n\t\t\t\t *  All the buffers belonging to the player.\n\t\t\t\t *  @type  {Tone.Buffers}\n\t\t\t\t */\n\t            this.buffers = options.urls;\n\t        } else {\n\t            this.buffers = new Tone.Buffers(options.urls, options.onload);\n\t        }\n\t        /**\n\t\t\t *  Keeps track of the currently playing sources.\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._activeSources = {};\n\t        /**\n\t\t\t *  The fade in envelope which is applied\n\t\t\t *  to the beginning of the BufferSource\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.fadeIn = options.fadeIn;\n\t        /**\n\t\t\t *  The fade out envelope which is applied\n\t\t\t *  to the end of the BufferSource\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.fadeOut = options.fadeOut;\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        //make the output explicitly stereo\n\t        this._volume.output.output.channelCount = 2;\n\t        this._volume.output.output.channelCountMode = 'explicit';\n\t        //mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.MultiPlayer, Tone.Source);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.MultiPlayer.defaults = {\n\t        'onload': Tone.noOp,\n\t        'fadeIn': 0,\n\t        'fadeOut': 0\n\t    };\n\t    /**\n\t\t * Make the source from the buffername\n\t\t * @param  {String} bufferName\n\t\t * @return {Tone.BufferSource}\n\t\t * @private\n\t\t */\n\t    Tone.MultiPlayer.prototype._makeSource = function (bufferName) {\n\t        var buffer;\n\t        if (this.isString(bufferName) || this.isNumber(bufferName)) {\n\t            buffer = this.buffers.get(bufferName).get();\n\t        } else if (bufferName instanceof Tone.Buffer) {\n\t            buffer = bufferName.get();\n\t        } else if (bufferName instanceof AudioBuffer) {\n\t            buffer = bufferName;\n\t        }\n\t        var source = new Tone.BufferSource(buffer).connect(this.output);\n\t        if (!this._activeSources.hasOwnProperty(bufferName)) {\n\t            this._activeSources[bufferName] = [];\n\t        }\n\t        this._activeSources[bufferName].push(source);\n\t        return source;\n\t    };\n\t    /**\n\t\t *  Start a buffer by name. The `start` method allows a number of options\n\t\t *  to be passed in such as offset, interval, and gain. This is good for multi-sampled \n\t\t *  instruments and sound sprites where samples are repitched played back at different velocities.\n\t\t *  @param  {String}  bufferName    The name of the buffer to start.\n\t\t *  @param  {Time}  time      When to start the buffer.\n\t\t *  @param  {Time}  [offset=0]    The offset into the buffer to play from.\n\t\t *  @param  {Time=}  duration   How long to play the buffer for.\n\t\t *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.\n\t\t *  @param  {Gain}  [gain=1]      The gain to play the sample at.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.start = function (bufferName, time, offset, duration, pitch, gain) {\n\t        time = this.toSeconds(time);\n\t        var source = this._makeSource(bufferName);\n\t        source.start(time, offset, duration, this.defaultArg(gain, 1), this.fadeIn);\n\t        if (duration) {\n\t            source.stop(time + this.toSeconds(duration), this.fadeOut);\n\t        }\n\t        pitch = this.defaultArg(pitch, 0);\n\t        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start a looping buffer by name. Similar to `start`, but the buffer\n\t\t *  is looped instead of played straight through. Can still be stopped with `stop`. \n\t\t *  @param  {String}  bufferName    The name of the buffer to start.\n\t\t *  @param  {Time}  time      When to start the buffer.\n\t\t *  @param  {Time}  [offset=0]    The offset into the buffer to play from.\n\t\t *  @param  {Time=}  loopStart   The start of the loop.\n\t\t *  @param  {Time=}  loopEnd\tThe end of the loop.\n\t\t *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.\n\t\t *  @param  {Gain}  [gain=1]      The gain to play the sample at.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.startLoop = function (bufferName, time, offset, loopStart, loopEnd, pitch, gain) {\n\t        time = this.toSeconds(time);\n\t        var source = this._makeSource(bufferName);\n\t        source.loop = true;\n\t        source.loopStart = this.toSeconds(this.defaultArg(loopStart, 0));\n\t        source.loopEnd = this.toSeconds(this.defaultArg(loopEnd, 0));\n\t        source.start(time, offset, undefined, this.defaultArg(gain, 1), this.fadeIn);\n\t        pitch = this.defaultArg(pitch, 0);\n\t        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the first played instance of the buffer name.\n\t\t *  @param  {String}  bufferName  The buffer to stop.\n\t\t *  @param  {Time=}  time    When to stop the buffer\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.stop = function (bufferName, time) {\n\t        if (this._activeSources[bufferName] && this._activeSources[bufferName].length) {\n\t            time = this.toSeconds(time);\n\t            this._activeSources[bufferName].shift().stop(time, this.fadeOut);\n\t        } else {\n\t            throw new Error('Tone.MultiPlayer: cannot stop a buffer that hasn\\'t been started or is already stopped');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop all currently playing buffers at the given time.\n\t\t *  @param  {Time=}  time  When to stop the buffers.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.stopAll = function (time) {\n\t        time = this.toSeconds(time);\n\t        for (var bufferName in this._activeSources) {\n\t            var sources = this._activeSources[bufferName];\n\t            for (var i = 0; i < sources.length; i++) {\n\t                sources[i].stop(time);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add another buffer to the available buffers.\n\t\t *  @param {String} name The name to that the buffer is refered\n\t\t *                       to in start/stop methods. \n\t\t *  @param {String|Tone.Buffer} url The url of the buffer to load\n\t\t *                                  or the buffer.\n\t\t *  @param {Function} callback The function to invoke after the buffer is loaded.\n\t\t */\n\t    Tone.MultiPlayer.prototype.add = function (name, url, callback) {\n\t        this.buffers.add(name, url, callback);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source. \"started\"\n\t\t *  if there are any buffers playing. \"stopped\" otherwise.\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.MultiPlayer#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.MultiPlayer.prototype, 'state', {\n\t        get: function () {\n\t            return this._activeSources.length > 0 ? Tone.State.Started : Tone.State.Stopped;\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.MultiPlayer#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * source.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.MultiPlayer.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this._writable('volume');\n\t        this.volume = null;\n\t        for (var bufferName in this._activeSources) {\n\t            this._activeSources[bufferName].forEach(function (source) {\n\t                source.dispose();\n\t            });\n\t        }\n\t        this.buffers.dispose();\n\t        this.buffers = null;\n\t        this._activeSources = null;\n\t        return this;\n\t    };\n\t    return Tone.MultiPlayer;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n\t\t *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the \n\t\t *        amount of time each small chunk of audio is played for and the overlap is the \n\t\t *        amount of crossfading transition time between successive grains.\n\t\t * @extends {Tone}\n\t\t * @param {String|Tone.Buffer} url\tThe url to load, or the Tone.Buffer to play.\n\t\t * @param {Function=} callback The callback to invoke after the url is loaded.\n\t\t */\n\t    Tone.GrainPlayer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.GrainPlayer.defaults);\n\t        Tone.Source.call(this);\n\t        /**\n\t\t\t *  The audio buffer belonging to the player.\n\t\t\t *  @type  {Tone.Buffer}\n\t\t\t */\n\t        this.buffer = new Tone.Buffer(options.url, options.onload);\n\t        /**\n\t\t\t *  Plays the buffer with a small envelope\n\t\t\t *  @type  {Tone.MultiPlayer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._player = new Tone.MultiPlayer().connect(this.output);\n\t        /**\n\t\t\t *  Create a repeating tick to schedule\n\t\t\t *  the grains.\n\t\t\t *  @type  {Tone.Clock}\n\t\t\t *  @private\n\t\t\t */\n\t        this._clock = new Tone.Clock(this._tick.bind(this), 1);\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = 0;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = 0;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._grainSize = options.grainSize;\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Number}\n\t\t\t */\n\t        this._overlap = options.overlap;\n\t        /**\n\t\t\t *  Adjust the pitch independently of the playbackRate.\n\t\t\t *  @type  {Cents}\n\t\t\t */\n\t        this.detune = options.detune;\n\t        /**\n\t\t\t *  The amount of time randomly added\n\t\t\t *  or subtracted from the grain's offset\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.drift = options.drift;\n\t        //setup\n\t        this.overlap = options.overlap;\n\t        this.loop = options.loop;\n\t        this.playbackRate = options.playbackRate;\n\t        this.grainSize = options.grainSize;\n\t        this.loopStart = options.loopStart;\n\t        this.loopEnd = options.loopEnd;\n\t        this.reverse = options.reverse;\n\t    };\n\t    Tone.extend(Tone.GrainPlayer, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.GrainPlayer.defaults = {\n\t        'onload': Tone.noOp,\n\t        'overlap': 0.1,\n\t        'grainSize': 0.2,\n\t        'drift': 0,\n\t        'playbackRate': 1,\n\t        'detune': 0,\n\t        'loop': false,\n\t        'loopStart': 0,\n\t        'loopEnd': 0,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Play the buffer at the given startTime. Optionally add an offset\n\t\t *  and/or duration which will play the buffer from a position\n\t\t *  within the buffer for the given duration. \n\t\t *  \n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @returns {Tone.GrainPlayer} this\n\t\t *  @memberOf Tone.GrainPlayer#\n\t\t *  @method start\n\t\t *  @name start\n\t\t */\n\t    /**\n\t\t *  Internal start method\n\t\t *  @param {Time} time\n\t\t *  @param {Time} offset\n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._start = function (time, offset, duration) {\n\t        offset = this.defaultArg(offset, 0);\n\t        offset = this.toSeconds(offset);\n\t        time = this.toSeconds(time);\n\t        this._offset = offset;\n\t        this._clock.start(time);\n\t        //unmute the player\n\t        this._player.volume.setValueAtTime(0, time);\n\t        if (duration) {\n\t            this._stop(time + this.toSeconds(duration));\n\t        }\n\t    };\n\t    /**\n\t\t *  Internal start method\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._stop = function (time) {\n\t        this._clock.stop(time);\n\t        //mute the player\n\t        this._player.volume.cancelScheduledValues(time);\n\t        this._player.volume.setValueAtTime(-Infinity, time);\n\t    };\n\t    /**\n\t\t *  Invoked on each clock tick. scheduled a new\n\t\t *  grain at this time.\n\t\t *  @param  {Time}  time \n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._tick = function (time) {\n\t        var bufferDuration = this.buffer.duration;\n\t        if (this.loop && this._loopEnd > 0) {\n\t            bufferDuration = this._loopEnd;\n\t        }\n\t        var drift = (Math.random() * 2 - 1) * this.drift;\n\t        var offset = this._offset - this._overlap + drift;\n\t        var detune = this.detune / 100;\n\t        //keep the offset within the limits of the buffer\n\t        offset = Math.max(offset, 0);\n\t        offset = Math.min(offset, bufferDuration);\n\t        var originalFadeIn = this._player.fadeIn;\n\t        if (this.loop && this._offset > bufferDuration) {\n\t            //play the end\n\t            var endSegmentDuration = this._offset - bufferDuration;\n\t            this._player.start(this.buffer, time, offset, endSegmentDuration + this._overlap, detune);\n\t            //and play the beginning \n\t            offset = this._offset % bufferDuration;\n\t            this._offset = this._loopStart;\n\t            this._player.fadeIn = 0;\n\t            this._player.start(this.buffer, time + endSegmentDuration, this._offset, offset + this._overlap, detune);\n\t        } else if (this._offset > bufferDuration) {\n\t            //set the state to stopped. \n\t            this.stop(time);\n\t        } else {\n\t            if (offset === 0) {\n\t                this._player.fadeIn = 0;\n\t            }\n\t            this._player.start(this.buffer, time, offset, this.grainSize + this._overlap, detune);\n\t        }\n\t        this._player.fadeIn = originalFadeIn;\n\t        //increment the offset\n\t        var duration = this._clock._nextTick - time;\n\t        this._offset += duration * this._playbackRate;\n\t    };\n\t    /**\n\t\t *  Jump to a specific time and play it.\n\t\t *  @param  {Time}  offset  The offset to jump to.\n\t\t *  @param {Time=} time When to make the jump.\n\t\t *  @return  {[type]}  [description]\n\t\t */\n\t    Tone.GrainPlayer.prototype.scrub = function (offset, time) {\n\t        this._offset = this.toSeconds(offset);\n\t        this._tick(this.toSeconds(time));\n\t        return this;\n\t    };\n\t    /**\n\t\t * The playback rate of the sample\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Positive}\n\t\t * @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this.grainSize = this._grainSize;\n\t        }\n\t    });\n\t    /**\n\t\t * The loop start time. \n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._loopStart;\n\t        },\n\t        set: function (time) {\n\t            this._loopStart = this.toSeconds(time);\n\t        }\n\t    });\n\t    /**\n\t\t * The loop end time. \n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._loopEnd;\n\t        },\n\t        set: function (time) {\n\t            this._loopEnd = this.toSeconds(time);\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {\n\t        get: function () {\n\t            return this.buffer.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this.buffer.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t * The size of each chunk of audio that the \n\t\t * buffer is chopped into and played back at.\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name grainSize\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {\n\t        get: function () {\n\t            return this._grainSize;\n\t        },\n\t        set: function (size) {\n\t            this._grainSize = this.toSeconds(size);\n\t            this._clock.frequency.value = this._playbackRate / this._grainSize;\n\t        }\n\t    });\n\t    /**\n\t\t * This is the duration of the cross-fade between \n\t\t * sucessive grains.\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name overlap\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {\n\t        get: function () {\n\t            return this._overlap;\n\t        },\n\t        set: function (time) {\n\t            time = this.toSeconds(time);\n\t            this._overlap = time;\n\t            if (this._overlap < 0) {\n\t                this._player.fadeIn = 0.01;\n\t                this._player.fadeOut = 0.01;\n\t            } else {\n\t                this._player.fadeIn = time;\n\t                this._player.fadeOut = time;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Clean up\n\t\t * @return {Tone.GrainPlayer} this\n\t\t */\n\t    Tone.GrainPlayer.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this.buffer.dispose();\n\t        this.buffer = null;\n\t        this._player.dispose();\n\t        this._player = null;\n\t        this._clock.dispose();\n\t        this._clock = null;\n\t        return this;\n\t    };\n\t    return Tone.GrainPlayer;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up\n\t\t *          and external microphone or audio input. Check \n\t\t *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n\t\t *          to see which browsers are supported. Access to an external input\n\t\t *          is limited to secure (HTTPS) connections.\n\t\t *         \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Decibels=} volume The level of the input\n\t\t *  @example\n\t\t * //list the inputs and open the third one\n\t\t * var motu = new Tone.UserMedia();\n\t\t * \n\t\t * //opening the input asks the user to activate their mic\n\t\t * motu.open().then(function(){\n\t\t * \t//opening is activates the microphone\n\t\t * \t//starting lets audio through\n\t\t * \tmotu.start(10);\n\t\t * });\n\t\t */\n\t    Tone.UserMedia = function () {\n\t        var options = this.optionsObject(arguments, ['volume'], Tone.UserMedia.defaults);\n\t        /**\n\t\t\t *  The MediaStreamNode \n\t\t\t *  @type {MediaStreamAudioSourceNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mediaStream = null;\n\t        /**\n\t\t\t *  The media stream created by getUserMedia.\n\t\t\t *  @type {LocalMediaStream}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stream = null;\n\t        /**\n\t\t\t *  The open device\n\t\t\t *  @type  {MediaDeviceInfo}\n\t\t\t *  @private\n\t\t\t */\n\t        this._device = null;\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * input.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.UserMedia);\n\t    /**\n\t\t * the default parameters\n\t\t * @type {Object}\n\t\t */\n\t    Tone.UserMedia.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Open the media stream. If a string is passed in, it is assumed\n\t\t *  to be the label or id of the stream, if a number is passed in,\n\t\t *  it is the input number of the stream.\n\t\t *  @param  {String|Number} [labelOrId=\"default\"] The label or id of the audio input media device. \n\t\t *                                                With no argument, the default stream is opened.\n\t\t *  @return {Promise} The promise is resolved when the stream is open.\n\t\t */\n\t    Tone.UserMedia.prototype.open = function (labelOrId) {\n\t        labelOrId = this.defaultArg(labelOrId, 'default');\n\t        return this.enumerateDevices().then(function (devices) {\n\t            var device;\n\t            if (this.isNumber(labelOrId)) {\n\t                device = devices[labelOrId];\n\t            } else {\n\t                device = devices.find(function (device) {\n\t                    return device.label === labelOrId || device.deviceId === labelOrId;\n\t                });\n\t                if (!device) {\n\t                    //otherwise just take the first one\n\t                    device = devices[0];\n\t                }\n\t            }\n\t            //didn't find a matching device\n\t            if (!device) {\n\t                throw new Error('Tone.UserMedia: no matching audio inputs.');\n\t            }\n\t            this._device = device;\n\t            //do getUserMedia\n\t            var constraints = {\n\t                audio: {\n\t                    'deviceId': device.deviceId,\n\t                    'echoCancellation': false,\n\t                    'sampleRate': this.context.sampleRate\n\t                }\n\t            };\n\t            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n\t                //start a new source only if the previous one is closed\n\t                if (!this._stream) {\n\t                    this._stream = stream;\n\t                    //Wrap a MediaStreamSourceNode around the live input stream.\n\t                    this._mediaStream = this.context.createMediaStreamSource(stream);\n\t                    //Connect the MediaStreamSourceNode to a gate gain node\n\t                    this._mediaStream.connect(this.output);\n\t                }\n\t                return this;\n\t            }.bind(this));\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Close the media stream\n\t\t *  @return {Tone.UserMedia} this\n\t\t */\n\t    Tone.UserMedia.prototype.close = function () {\n\t        if (this._stream) {\n\t            this._stream.getAudioTracks().forEach(function (track) {\n\t                track.stop();\n\t            });\n\t            this._stream = null;\n\t            //remove the old media stream\n\t            this._mediaStream.disconnect();\n\t            this._mediaStream = null;\n\t        }\n\t        this._device = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns a promise which resolves with the list of audio input devices available.\n\t\t *  @return {Promise} The promise that is resolved with the devices\n\t\t *  @example\n\t\t * extInput.enumerateDevices().then(function(devices){\n\t\t * \tconsole.log(devices)\n\t\t * })\n\t\t */\n\t    Tone.UserMedia.prototype.enumerateDevices = function () {\n\t        return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n\t            return devices.filter(function (device) {\n\t                return device.kind === 'audioinput';\n\t            });\n\t        });\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, \"started\" when the microphone is open\n\t\t *  and \"stopped\" when the mic is closed.\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'state', {\n\t        get: function () {\n\t            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns an identifier for the represented device that is \n\t\t * \tpersisted across sessions. It is un-guessable by other applications and \n\t\t * \tunique to the origin of the calling application. It is reset when the \n\t\t * \tuser clears cookies (for Private Browsing, a different identifier is \n\t\t * \tused that is not persisted across sessions). Returns undefined when the \n\t\t * \tdevice is not open.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name deviceId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.deviceId;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns a group identifier. Two devices have the \n\t\t * \tsame group identifier if they belong to the same physical device.\n\t\t * \tReturns undefined when the device is not open.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name groupId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.groupId;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns a label describing this device (for example \"Built-in Microphone\"). \n\t\t * \tReturns undefined when the device is not open or label is not available\n\t\t * \tbecause of permissions.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name groupId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'label', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.label;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.UserMedia#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * userMedia.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t * Clean up.\n\t\t * @return {Tone.UserMedia} this\n\t\t */\n\t    Tone.UserMedia.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.close();\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  If getUserMedia is supported by the browser.\n\t\t *  @type  {Boolean}\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name supported\n\t\t *  @static\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia, 'supported', {\n\t        get: function () {\n\t            return !Tone.prototype.isUndef(navigator.mediaDevices) && Tone.prototype.isFunction(navigator.mediaDevices.getUserMedia);\n\t        }\n\t    });\n\t    return Tone.UserMedia;\n\t});\n\t\n\treturn Tone;\n}));\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))]), _vm._v(\" \"), _vm._l((_vm.notes), function(note) {\n    return _c('div', [_c('a', {\n      attrs: {\n        \"tabindex\": \"note.id\"\n      },\n      on: {\n        \"click\": function($event) {\n          _vm.makeSound(note.value)\n        }\n      }\n    }, [_vm._v(_vm._s(note.text))])])\n  })], 2)\n},staticRenderFns: []}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(4);\nif(typeof content === 'string') content = [[module.i, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = __webpack_require__(10)(\"abec262e\", content, true);\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = __webpack_require__(11)\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// build.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap e946022fb1078770e2fa","function injectStyle (ssrContext) {\n  require(\"!!vue-style-loader!css-loader!../node_modules/vue-loader/lib/style-compiler/index?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-271881da\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!sass-loader!../node_modules/vue-loader/lib/selector?type=styles&index=0!./Main.vue\")\n}\nvar Component = require(\"!../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./Main.vue\"),\n  /* template */\n  require(\"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-271881da\\\",\\\"hasScoped\\\":false}!../node_modules/vue-loader/lib/selector?type=template&index=0!./Main.vue\"),\n  /* styles */\n  injectStyle,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Main.vue\n// module id = 0\n// module chunks = 0","/*!\n * Vue.js v2.4.2\n * (c) 2014-2017 Evan You\n * Released under the MIT License.\n */\n/*  */\n\n// these helpers produces better vm code in JS engines due to their\n// explicitness and function inlining\nfunction isUndef (v) {\n  return v === undefined || v === null\n}\n\nfunction isDef (v) {\n  return v !== undefined && v !== null\n}\n\nfunction isTrue (v) {\n  return v === true\n}\n\nfunction isFalse (v) {\n  return v === false\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return (\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean'\n  )\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\nvar _toString = Object.prototype.toString;\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nfunction isPlainObject (obj) {\n  return _toString.call(obj) === '[object Object]'\n}\n\nfunction isRegExp (v) {\n  return _toString.call(v) === '[object RegExp]'\n}\n\n/**\n * Check if val is a valid array index.\n */\nfunction isValidArrayIndex (val) {\n  var n = parseFloat(val);\n  return n >= 0 && Math.floor(n) === n && isFinite(val)\n}\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val);\n  return isNaN(n) ? val : n\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Check if a attribute is a reserved attribute.\n */\nvar isReservedAttribute = makeMap('key,ref,slot,is');\n\n/**\n * Remove an item from an array\n */\nfunction remove (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n * Stubbing args to make Flow happy without leaving useless transpiled code\n * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)\n */\nfunction noop (a, b, c) {}\n\n/**\n * Always return false.\n */\nvar no = function (a, b, c) { return false; };\n\n/**\n * Return same value\n */\nvar identity = function (_) { return _; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  if (a === b) { return true }\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      var isArrayA = Array.isArray(a);\n      var isArrayB = Array.isArray(b);\n      if (isArrayA && isArrayB) {\n        return a.length === b.length && a.every(function (e, i) {\n          return looseEqual(e, b[i])\n        })\n      } else if (!isArrayA && !isArrayB) {\n        var keysA = Object.keys(a);\n        var keysB = Object.keys(b);\n        return keysA.length === keysB.length && keysA.every(function (key) {\n          return looseEqual(a[key], b[key])\n        })\n      } else {\n        /* istanbul ignore next */\n        return false\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      return false\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/**\n * Ensure a function is called only once.\n */\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}\n\nvar SSR_ATTR = 'data-server-rendered';\n\nvar ASSET_TYPES = [\n  'component',\n  'directive',\n  'filter'\n];\n\nvar LIFECYCLE_HOOKS = [\n  'beforeCreate',\n  'created',\n  'beforeMount',\n  'mounted',\n  'beforeUpdate',\n  'updated',\n  'beforeDestroy',\n  'destroyed',\n  'activated',\n  'deactivated'\n];\n\n/*  */\n\nvar config = ({\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Show production mode tip message on boot?\n   */\n  productionTip: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Whether to record perf\n   */\n  performance: false,\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Warn handler for watcher warns\n   */\n  warnHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: [],\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if an attribute is reserved so that it cannot be used as a component\n   * prop. This is platform-dependent and may be overwritten.\n   */\n  isReservedAttr: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Parse the real tag name for the specific platform.\n   */\n  parsePlatformTagName: identity,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * Exposed for legacy reasons\n   */\n  _lifecycleHooks: LIFECYCLE_HOOKS\n});\n\n/*  */\n\nvar emptyObject = Object.freeze({});\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  }\n  var segments = path.split('.');\n  return function (obj) {\n    for (var i = 0; i < segments.length; i++) {\n      if (!obj) { return }\n      obj = obj[segments[i]];\n    }\n    return obj\n  }\n}\n\n/*  */\n\nvar warn = noop;\nvar tip = noop;\nvar formatComponentName = (null); // work around flow check\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n  var classifyRE = /(?:^|[-_])(\\w)/g;\n  var classify = function (str) { return str\n    .replace(classifyRE, function (c) { return c.toUpperCase(); })\n    .replace(/[-_]/g, ''); };\n\n  warn = function (msg, vm) {\n    var trace = vm ? generateComponentTrace(vm) : '';\n\n    if (config.warnHandler) {\n      config.warnHandler.call(null, msg, vm, trace);\n    } else if (hasConsole && (!config.silent)) {\n      console.error((\"[Vue warn]: \" + msg + trace));\n    }\n  };\n\n  tip = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.warn(\"[Vue tip]: \" + msg + (\n        vm ? generateComponentTrace(vm) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm, includeFile) {\n    if (vm.$root === vm) {\n      return '<Root>'\n    }\n    var name = typeof vm === 'string'\n      ? vm\n      : typeof vm === 'function' && vm.options\n        ? vm.options.name\n        : vm._isVue\n          ? vm.$options.name || vm.$options._componentTag\n          : vm.name;\n\n    var file = vm._isVue && vm.$options.__file;\n    if (!name && file) {\n      var match = file.match(/([^/\\\\]+)\\.vue$/);\n      name = match && match[1];\n    }\n\n    return (\n      (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n      (file && includeFile !== false ? (\" at \" + file) : '')\n    )\n  };\n\n  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };\n\n  var generateComponentTrace = function (vm) {\n    if (vm._isVue && vm.$parent) {\n      var tree = [];\n      var currentRecursiveSequence = 0;\n      while (vm) {\n        if (tree.length > 0) {\n          var last = tree[tree.length - 1];\n          if (last.constructor === vm.constructor) {\n            currentRecursiveSequence++;\n            vm = vm.$parent;\n            continue\n          } else if (currentRecursiveSequence > 0) {\n            tree[tree.length - 1] = [last, currentRecursiveSequence];\n            currentRecursiveSequence = 0;\n          }\n        }\n        tree.push(vm);\n        vm = vm.$parent;\n      }\n      return '\\n\\nfound in\\n\\n' + tree\n        .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n            ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n            : formatComponentName(vm))); })\n        .join('\\n')\n    } else {\n      return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n    }\n  };\n}\n\n/*  */\n\nfunction handleError (err, vm, info) {\n  if (config.errorHandler) {\n    config.errorHandler.call(null, err, vm, info);\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if (inBrowser && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser = typeof window !== 'undefined';\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\nvar isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n\n// Firefix has a \"watch\" function on Object.prototype...\nvar nativeWatch = ({}).watch;\n\nvar supportsPassive = false;\nif (inBrowser) {\n  try {\n    var opts = {};\n    Object.defineProperty(opts, 'passive', ({\n      get: function get () {\n        /* istanbul ignore next */\n        supportsPassive = true;\n      }\n    })); // https://github.com/facebook/flow/issues/285\n    window.addEventListener('test-passive', null, opts);\n  } catch (e) {}\n}\n\n// this needs to be lazy-evaled because vue may be required before\n// vue-server-renderer can set VUE_ENV\nvar _isServer;\nvar isServerRendering = function () {\n  if (_isServer === undefined) {\n    /* istanbul ignore if */\n    if (!inBrowser && typeof global !== 'undefined') {\n      // detect presence of vue-server-renderer and avoid\n      // Webpack shimming the process\n      _isServer = global['process'].env.VUE_ENV === 'server';\n    } else {\n      _isServer = false;\n    }\n  }\n  return _isServer\n};\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n\nvar hasSymbol =\n  typeof Symbol !== 'undefined' && isNative(Symbol) &&\n  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    var logError = function (err) { console.error(err); };\n    timerFunc = function () {\n      p.then(nextTickHandler).catch(logError);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve, reject) {\n        _resolve = resolve;\n      })\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] === true\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = true;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/*  */\n\n\nvar uid = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stabilize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src, keys) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n */\n/* istanbul ignore next */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value, asRootData) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !isServerRendering() &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  if (asRootData && ob) {\n    ob.vmCount++;\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter,\n  shallow\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = !shallow && observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = !shallow && observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (target, key, val) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.length = Math.max(target.length, key);\n    target.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(target, key)) {\n    target[key] = val;\n    return val\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return val\n  }\n  if (!ob) {\n    target[key] = val;\n    return val\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (target, key) {\n  if (Array.isArray(target) && isValidArrayIndex(key)) {\n    target.splice(key, 1);\n    return\n  }\n  var ob = (target).__ob__;\n  if (target._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(target, key)) {\n    return\n  }\n  delete target[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nfunction mergeDataOrFn (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        typeof childVal === 'function' ? childVal.call(this) : childVal,\n        typeof parentVal === 'function' ? parentVal.call(this) : parentVal\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n}\n\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    if (childVal && typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n\n      return parentVal\n    }\n    return mergeDataOrFn.call(this, parentVal, childVal)\n  }\n\n  return mergeDataOrFn(parentVal, childVal, vm)\n};\n\n/**\n * Hooks and props are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nLIFECYCLE_HOOKS.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nASSET_TYPES.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  // work around Firefox's Object.prototype.watch...\n  if (parentVal === nativeWatch) { parentVal = undefined; }\n  if (childVal === nativeWatch) { childVal = undefined; }\n  /* istanbul ignore if */\n  if (!childVal) { return Object.create(parentVal || null) }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : Array.isArray(child) ? child : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.inject =\nstrats.computed = function (parentVal, childVal) {\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  if (childVal) { extend(ret, childVal); }\n  return ret\n};\nstrats.provide = mergeDataOrFn;\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize all injections into Object-based format\n */\nfunction normalizeInject (options) {\n  var inject = options.inject;\n  if (Array.isArray(inject)) {\n    var normalized = options.inject = {};\n    for (var i = 0; i < inject.length; i++) {\n      normalized[inject[i]] = inject[i];\n    }\n  }\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n\n  if (typeof child === 'function') {\n    child = child.options;\n  }\n\n  normalizeProps(child);\n  normalizeInject(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      parent = mergeOptions(parent, child.mixins[i], vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  // check local registration variations first\n  if (hasOwn(assets, id)) { return assets[id] }\n  var camelizedId = camelize(id);\n  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n  var PascalCaseId = capitalize(camelizedId);\n  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n  // fallback to prototype chain\n  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isType(Boolean, prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (process.env.NODE_ENV !== 'production' && isObject(def)) {\n    warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm._props[key] !== undefined\n  ) {\n    return vm._props[key]\n  }\n  // call factory function for non-Function types\n  // a value is Function if its prototype is function even across different execution context\n  return typeof def === 'function' && getType(prop.type) !== 'Function'\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType || '');\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\nvar simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (simpleCheckRE.test(expectedType)) {\n    valid = typeof value === expectedType.toLowerCase();\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match ? match[1] : ''\n}\n\nfunction isType (type, fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === getType(type)\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === getType(type)) {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n/*  */\n\nvar mark;\nvar measure;\n\nif (process.env.NODE_ENV !== 'production') {\n  var perf = inBrowser && window.performance;\n  /* istanbul ignore if */\n  if (\n    perf &&\n    perf.mark &&\n    perf.measure &&\n    perf.clearMarks &&\n    perf.clearMeasures\n  ) {\n    mark = function (tag) { return perf.mark(tag); };\n    measure = function (name, startTag, endTag) {\n      perf.measure(name, startTag, endTag);\n      perf.clearMarks(startTag);\n      perf.clearMarks(endTag);\n      perf.clearMeasures(name);\n    };\n  }\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  var warnNonPresent = function (target, key) {\n    warn(\n      \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n      \"referenced during render. Make sure to declare reactive data \" +\n      \"properties in the data option.\",\n      target\n    );\n  };\n\n  var hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  if (hasProxy) {\n    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta');\n    config.keyCodes = new Proxy(config.keyCodes, {\n      set: function set (target, key, value) {\n        if (isBuiltInModifier(key)) {\n          warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n          return false\n        } else {\n          target[key] = value;\n          return true\n        }\n      }\n    });\n  }\n\n  var hasHandler = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warnNonPresent(target, key);\n      }\n      return has || !isAllowed\n    }\n  };\n\n  var getHandler = {\n    get: function get (target, key) {\n      if (typeof key === 'string' && !(key in target)) {\n        warnNonPresent(target, key);\n      }\n      return target[key]\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      // determine which proxy handler to use\n      var options = vm.$options;\n      var handlers = options.render && options.render._withStripped\n        ? getHandler\n        : hasHandler;\n      vm._renderProxy = new Proxy(vm, handlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  context,\n  componentOptions,\n  asyncFactory\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = undefined;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.componentInstance = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n  this.asyncFactory = asyncFactory;\n  this.asyncMeta = undefined;\n  this.isAsyncPlaceholder = false;\n};\n\nvar prototypeAccessors = { child: {} };\n\n// DEPRECATED: alias for componentInstance for backwards compat.\n/* istanbul ignore next */\nprototypeAccessors.child.get = function () {\n  return this.componentInstance\n};\n\nObject.defineProperties( VNode.prototype, prototypeAccessors );\n\nvar createEmptyVNode = function (text) {\n  if ( text === void 0 ) text = '';\n\n  var node = new VNode();\n  node.text = text;\n  node.isComment = true;\n  return node\n};\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  );\n  cloned.ns = vnode.ns;\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isComment = vnode.isComment;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var len = vnodes.length;\n  var res = new Array(len);\n  for (var i = 0; i < len; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nvar normalizeEvent = cached(function (name) {\n  var passive = name.charAt(0) === '&';\n  name = passive ? name.slice(1) : name;\n  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n  name = once$$1 ? name.slice(1) : name;\n  var capture = name.charAt(0) === '!';\n  name = capture ? name.slice(1) : name;\n  return {\n    name: name,\n    once: once$$1,\n    capture: capture,\n    passive: passive\n  }\n});\n\nfunction createFnInvoker (fns) {\n  function invoker () {\n    var arguments$1 = arguments;\n\n    var fns = invoker.fns;\n    if (Array.isArray(fns)) {\n      var cloned = fns.slice();\n      for (var i = 0; i < cloned.length; i++) {\n        cloned[i].apply(null, arguments$1);\n      }\n    } else {\n      // return handler return value for single handlers\n      return fns.apply(null, arguments)\n    }\n  }\n  invoker.fns = fns;\n  return invoker\n}\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, event;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    event = normalizeEvent(name);\n    if (isUndef(cur)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (isUndef(old)) {\n      if (isUndef(cur.fns)) {\n        cur = on[name] = createFnInvoker(cur);\n      }\n      add(event.name, cur, event.once, event.capture, event.passive);\n    } else if (cur !== old) {\n      old.fns = cur;\n      on[name] = old;\n    }\n  }\n  for (name in oldOn) {\n    if (isUndef(on[name])) {\n      event = normalizeEvent(name);\n      remove$$1(event.name, oldOn[name], event.capture);\n    }\n  }\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook) {\n  var invoker;\n  var oldHook = def[hookKey];\n\n  function wrappedHook () {\n    hook.apply(this, arguments);\n    // important: remove merged hook to ensure it's called only once\n    // and prevent memory leak\n    remove(invoker.fns, wrappedHook);\n  }\n\n  if (isUndef(oldHook)) {\n    // no existing hook\n    invoker = createFnInvoker([wrappedHook]);\n  } else {\n    /* istanbul ignore if */\n    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n      // already a merged invoker\n      invoker = oldHook;\n      invoker.fns.push(wrappedHook);\n    } else {\n      // existing plain hook\n      invoker = createFnInvoker([oldHook, wrappedHook]);\n    }\n  }\n\n  invoker.merged = true;\n  def[hookKey] = invoker;\n}\n\n/*  */\n\nfunction extractPropsFromVNodeData (\n  data,\n  Ctor,\n  tag\n) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (isUndef(propOptions)) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  if (isDef(attrs) || isDef(props)) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      if (process.env.NODE_ENV !== 'production') {\n        var keyInLowerCase = key.toLowerCase();\n        if (\n          key !== keyInLowerCase &&\n          attrs && hasOwn(attrs, keyInLowerCase)\n        ) {\n          tip(\n            \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n            (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n            \" \\\"\" + key + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and camelCased \" +\n            \"props need to use their kebab-case equivalents when using in-DOM \" +\n            \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n          );\n        }\n      }\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey, false);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (isDef(hash)) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\n// The template compiler attempts to minimize the need for normalization by\n// statically analyzing the template at compile time.\n//\n// For plain HTML markup, normalization can be completely skipped because the\n// generated render function is guaranteed to return Array<VNode>. There are\n// two cases where extra normalization is needed:\n\n// 1. When the children contains components - because a functional component\n// may return an Array instead of a single root. In this case, just a simple\n// normalization is needed - if any child is an Array, we flatten the whole\n// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n// because functional components already normalize their own children.\nfunction simpleNormalizeChildren (children) {\n  for (var i = 0; i < children.length; i++) {\n    if (Array.isArray(children[i])) {\n      return Array.prototype.concat.apply([], children)\n    }\n  }\n  return children\n}\n\n// 2. When the children contains constructs that always generated nested Arrays,\n// e.g. <template>, <slot>, v-for, or when the children is provided by user\n// with hand-written render functions / JSX. In such cases a full normalization\n// is needed to cater to all possible types of children values.\nfunction normalizeChildren (children) {\n  return isPrimitive(children)\n    ? [createTextVNode(children)]\n    : Array.isArray(children)\n      ? normalizeArrayChildren(children)\n      : undefined\n}\n\nfunction isTextNode (node) {\n  return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n}\n\nfunction normalizeArrayChildren (children, nestedIndex) {\n  var res = [];\n  var i, c, last;\n  for (i = 0; i < children.length; i++) {\n    c = children[i];\n    if (isUndef(c) || typeof c === 'boolean') { continue }\n    last = res[res.length - 1];\n    //  nested\n    if (Array.isArray(c)) {\n      res.push.apply(res, normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i)));\n    } else if (isPrimitive(c)) {\n      if (isTextNode(last)) {\n        // merge adjacent text nodes\n        // this is necessary for SSR hydration because text nodes are\n        // essentially merged when rendered to HTML strings\n        (last).text += String(c);\n      } else if (c !== '') {\n        // convert primitive to vnode\n        res.push(createTextVNode(c));\n      }\n    } else {\n      if (isTextNode(c) && isTextNode(last)) {\n        // merge adjacent text nodes\n        res[res.length - 1] = createTextVNode(last.text + c.text);\n      } else {\n        // default key for nested array children (likely generated by v-for)\n        if (isTrue(children._isVList) &&\n          isDef(c.tag) &&\n          isUndef(c.key) &&\n          isDef(nestedIndex)) {\n          c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n        }\n        res.push(c);\n      }\n    }\n  }\n  return res\n}\n\n/*  */\n\nfunction ensureCtor (comp, base) {\n  if (comp.__esModule && comp.default) {\n    comp = comp.default;\n  }\n  return isObject(comp)\n    ? base.extend(comp)\n    : comp\n}\n\nfunction createAsyncPlaceholder (\n  factory,\n  data,\n  context,\n  children,\n  tag\n) {\n  var node = createEmptyVNode();\n  node.asyncFactory = factory;\n  node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n  return node\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  context\n) {\n  if (isTrue(factory.error) && isDef(factory.errorComp)) {\n    return factory.errorComp\n  }\n\n  if (isDef(factory.resolved)) {\n    return factory.resolved\n  }\n\n  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n    return factory.loadingComp\n  }\n\n  if (isDef(factory.contexts)) {\n    // already pending\n    factory.contexts.push(context);\n  } else {\n    var contexts = factory.contexts = [context];\n    var sync = true;\n\n    var forceRender = function () {\n      for (var i = 0, l = contexts.length; i < l; i++) {\n        contexts[i].$forceUpdate();\n      }\n    };\n\n    var resolve = once(function (res) {\n      // cache resolved\n      factory.resolved = ensureCtor(res, baseCtor);\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        forceRender();\n      }\n    });\n\n    var reject = once(function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n      if (isDef(factory.errorComp)) {\n        factory.error = true;\n        forceRender();\n      }\n    });\n\n    var res = factory(resolve, reject);\n\n    if (isObject(res)) {\n      if (typeof res.then === 'function') {\n        // () => Promise\n        if (isUndef(factory.resolved)) {\n          res.then(resolve, reject);\n        }\n      } else if (isDef(res.component) && typeof res.component.then === 'function') {\n        res.component.then(resolve, reject);\n\n        if (isDef(res.error)) {\n          factory.errorComp = ensureCtor(res.error, baseCtor);\n        }\n\n        if (isDef(res.loading)) {\n          factory.loadingComp = ensureCtor(res.loading, baseCtor);\n          if (res.delay === 0) {\n            factory.loading = true;\n          } else {\n            setTimeout(function () {\n              if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                factory.loading = true;\n                forceRender();\n              }\n            }, res.delay || 200);\n          }\n        }\n\n        if (isDef(res.timeout)) {\n          setTimeout(function () {\n            if (isUndef(factory.resolved)) {\n              reject(\n                process.env.NODE_ENV !== 'production'\n                  ? (\"timeout (\" + (res.timeout) + \"ms)\")\n                  : null\n              );\n            }\n          }, res.timeout);\n        }\n      }\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.loading\n      ? factory.loadingComp\n      : factory.resolved\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      var c = children[i];\n      if (isDef(c) && isDef(c.componentOptions)) {\n        return c\n      }\n    }\n  }\n}\n\n/*  */\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nvar target;\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\nfunction remove$1 (event, fn) {\n  target.$off(event, fn);\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction eventsMixin (Vue) {\n  var hookRE = /^hook:/;\n  Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i < l; i++) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\n      // optimize hook:event cost by using a boolean flag marked at registration\n      // instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // array of events\n    if (Array.isArray(event)) {\n      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n        this$1.$off(event[i$1], fn);\n      }\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    if (process.env.NODE_ENV !== 'production') {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n        tip(\n          \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n          (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n          \"Note that HTML attributes are case-insensitive and you cannot use \" +\n          \"v-on to listen to camelCase events when using in-DOM templates. \" +\n          \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        try {\n          cbs[i].apply(vm, args);\n        } catch (e) {\n          handleError(e, vm, (\"event handler for \\\"\" + event + \"\\\"\"));\n        }\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving raw children VNodes into a slot object.\n */\nfunction resolveSlots (\n  children,\n  context\n) {\n  var slots = {};\n  if (!children) {\n    return slots\n  }\n  var defaultSlot = [];\n  for (var i = 0, l = children.length; i < l; i++) {\n    var child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n      child.data && child.data.slot != null\n    ) {\n      var name = child.data.slot;\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore whitespace\n  if (!defaultSlot.every(isWhitespace)) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\nfunction isWhitespace (node) {\n  return node.isComment || node.text === ' '\n}\n\nfunction resolveScopedSlots (\n  fns, // see flow/vnode\n  res\n) {\n  res = res || {};\n  for (var i = 0; i < fns.length; i++) {\n    if (Array.isArray(fns[i])) {\n      resolveScopedSlots(fns[i], res);\n    } else {\n      res[fns[i].key] = fns[i].fn;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar activeInstance = null;\nvar isUpdatingChildComponent = false;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = null;\n  vm._directInactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevVnode = vm._vnode;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    vm._vnode = vnode;\n    // Vue.prototype.__patch__ is injected in entry points\n    // based on the rendering backend used.\n    if (!prevVnode) {\n      // initial render\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false /* removeOnly */,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      );\n      // no need for the ref nodes after initial patch\n      // this prevents keeping a detached DOM tree in memory (#5851)\n      vm.$options._parentElm = vm.$options._refElm = null;\n    } else {\n      // updates\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    // updated hook is called by the scheduler to ensure that children are\n    // updated in a parent's updated hook.\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n    // fire destroyed hook\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n  };\n}\n\nfunction mountComponent (\n  vm,\n  el,\n  hydrating\n) {\n  vm.$el = el;\n  if (!vm.$options.render) {\n    vm.$options.render = createEmptyVNode;\n    if (process.env.NODE_ENV !== 'production') {\n      /* istanbul ignore if */\n      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n        vm.$options.el || el) {\n        warn(\n          'You are using the runtime-only build of Vue where the template ' +\n          'compiler is not available. Either pre-compile the templates into ' +\n          'render functions, or use the compiler-included build.',\n          vm\n        );\n      } else {\n        warn(\n          'Failed to mount component: template or render function not defined.',\n          vm\n        );\n      }\n    }\n  }\n  callHook(vm, 'beforeMount');\n\n  var updateComponent;\n  /* istanbul ignore if */\n  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n    updateComponent = function () {\n      var name = vm._name;\n      var id = vm._uid;\n      var startTag = \"vue-perf-start:\" + id;\n      var endTag = \"vue-perf-end:\" + id;\n\n      mark(startTag);\n      var vnode = vm._render();\n      mark(endTag);\n      measure((name + \" render\"), startTag, endTag);\n\n      mark(startTag);\n      vm._update(vnode, hydrating);\n      mark(endTag);\n      measure((name + \" patch\"), startTag, endTag);\n    };\n  } else {\n    updateComponent = function () {\n      vm._update(vm._render(), hydrating);\n    };\n  }\n\n  vm._watcher = new Watcher(vm, updateComponent, noop);\n  hydrating = false;\n\n  // manually mounted instance, call mounted on self\n  // mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true;\n    callHook(vm, 'mounted');\n  }\n  return vm\n}\n\nfunction updateChildComponent (\n  vm,\n  propsData,\n  listeners,\n  parentVnode,\n  renderChildren\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = true;\n  }\n\n  // determine whether component has slot children\n  // we need to do this before overwriting $options._renderChildren\n  var hasChildren = !!(\n    renderChildren ||               // has new static slots\n    vm.$options._renderChildren ||  // has old static slots\n    parentVnode.data.scopedSlots || // has new scoped slots\n    vm.$scopedSlots !== emptyObject // has old scoped slots\n  );\n\n  vm.$options._parentVnode = parentVnode;\n  vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n  if (vm._vnode) { // update child tree's parent\n    vm._vnode.parent = parentVnode;\n  }\n  vm.$options._renderChildren = renderChildren;\n\n  // update $attrs and $listensers hash\n  // these are also reactive so they may trigger child update if the child\n  // used them during render\n  vm.$attrs = parentVnode.data && parentVnode.data.attrs;\n  vm.$listeners = listeners;\n\n  // update props\n  if (propsData && vm.$options.props) {\n    observerState.shouldConvert = false;\n    var props = vm._props;\n    var propKeys = vm.$options._propKeys || [];\n    for (var i = 0; i < propKeys.length; i++) {\n      var key = propKeys[i];\n      props[key] = validateProp(key, vm.$options.props, propsData, vm);\n    }\n    observerState.shouldConvert = true;\n    // keep a copy of raw propsData\n    vm.$options.propsData = propsData;\n  }\n\n  // update listeners\n  if (listeners) {\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n  }\n  // resolve slots + force update if has children\n  if (hasChildren) {\n    vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n    vm.$forceUpdate();\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    isUpdatingChildComponent = false;\n  }\n}\n\nfunction isInInactiveTree (vm) {\n  while (vm && (vm = vm.$parent)) {\n    if (vm._inactive) { return true }\n  }\n  return false\n}\n\nfunction activateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = false;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  } else if (vm._directInactive) {\n    return\n  }\n  if (vm._inactive || vm._inactive === null) {\n    vm._inactive = false;\n    for (var i = 0; i < vm.$children.length; i++) {\n      activateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'activated');\n  }\n}\n\nfunction deactivateChildComponent (vm, direct) {\n  if (direct) {\n    vm._directInactive = true;\n    if (isInInactiveTree(vm)) {\n      return\n    }\n  }\n  if (!vm._inactive) {\n    vm._inactive = true;\n    for (var i = 0; i < vm.$children.length; i++) {\n      deactivateChildComponent(vm.$children[i]);\n    }\n    callHook(vm, 'deactivated');\n  }\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      try {\n        handlers[i].call(vm);\n      } catch (e) {\n        handleError(e, vm, (hook + \" hook\"));\n      }\n    }\n  }\n  if (vm._hasHookEvent) {\n    vm.$emit('hook:' + hook);\n  }\n}\n\n/*  */\n\n\nvar MAX_UPDATE_COUNT = 100;\n\nvar queue = [];\nvar activatedChildren = [];\nvar has = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  index = queue.length = activatedChildren.length = 0;\n  has = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n  var watcher, id;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    watcher = queue[index];\n    id = watcher.id;\n    has[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > MAX_UPDATE_COUNT) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // keep copies of post queues before resetting state\n  var activatedQueue = activatedChildren.slice();\n  var updatedQueue = queue.slice();\n\n  resetSchedulerState();\n\n  // call component updated and activated hooks\n  callActivatedHooks(activatedQueue);\n  callUpdatedHooks(updatedQueue);\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n}\n\nfunction callUpdatedHooks (queue) {\n  var i = queue.length;\n  while (i--) {\n    var watcher = queue[i];\n    var vm = watcher.vm;\n    if (vm._watcher === watcher && vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  }\n}\n\n/**\n * Queue a kept-alive component that was activated during patch.\n * The queue will be processed after the entire tree has been patched.\n */\nfunction queueActivatedComponent (vm) {\n  // setting _inactive to false here so that a render function can\n  // rely on checking whether it's in an inactive tree (e.g. router-view)\n  vm._inactive = false;\n  activatedChildren.push(vm);\n}\n\nfunction callActivatedHooks (queue) {\n  for (var i = 0; i < queue.length; i++) {\n    queue[i]._inactive = true;\n    activateChildComponent(queue[i], true /* true */);\n  }\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has[id] == null) {\n    has[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i > index && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(i + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$2 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  if (options) {\n    this.deep = !!options.deep;\n    this.user = !!options.user;\n    this.lazy = !!options.lazy;\n    this.sync = !!options.sync;\n  } else {\n    this.deep = this.user = this.lazy = this.sync = false;\n  }\n  this.cb = cb;\n  this.id = ++uid$2; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  this.expression = process.env.NODE_ENV !== 'production'\n    ? expOrFn.toString()\n    : '';\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value;\n  var vm = this.vm;\n  try {\n    value = this.getter.call(vm, vm);\n  } catch (e) {\n    if (this.user) {\n      handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n    } else {\n      throw e\n    }\n  } finally {\n    // \"touch\" every property so they are all tracked as\n    // dependencies for deep watching\n    if (this.deep) {\n      traverse(value);\n    }\n    popTarget();\n    this.cleanupDeps();\n  }\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n    if (\n      value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed.\n    if (!this.vm._isBeingDestroyed) {\n      remove(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*  */\n\nvar sharedPropertyDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction proxy (target, sourceKey, key) {\n  sharedPropertyDefinition.get = function proxyGetter () {\n    return this[sourceKey][key]\n  };\n  sharedPropertyDefinition.set = function proxySetter (val) {\n    this[sourceKey][key] = val;\n  };\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true /* asRootData */);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch && opts.watch !== nativeWatch) {\n    initWatch(vm, opts.watch);\n  }\n}\n\nfunction checkOptionType (vm, name) {\n  var option = vm.$options[name];\n  if (!isPlainObject(option)) {\n    warn(\n      (\"component option \\\"\" + name + \"\\\" should be an object.\"),\n      vm\n    );\n  }\n}\n\nfunction initProps (vm, propsOptions) {\n  var propsData = vm.$options.propsData || {};\n  var props = vm._props = {};\n  // cache prop keys so that future props updates can iterate using Array\n  // instead of dynamic object key enumeration.\n  var keys = vm.$options._propKeys = [];\n  var isRoot = !vm.$parent;\n  // root instance props should be converted\n  observerState.shouldConvert = isRoot;\n  var loop = function ( key ) {\n    keys.push(key);\n    var value = validateProp(key, propsOptions, propsData, vm);\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      if (isReservedAttribute(key) || config.isReservedAttr(key)) {\n        warn(\n          (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n          vm\n        );\n      }\n      defineReactive$$1(props, key, value, function () {\n        if (vm.$parent && !isUpdatingChildComponent) {\n          warn(\n            \"Avoid mutating a prop directly since the value will be \" +\n            \"overwritten whenever the parent component re-renders. \" +\n            \"Instead, use a data or computed property based on the prop's \" +\n            \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        }\n      });\n    } else {\n      defineReactive$$1(props, key, value);\n    }\n    // static props are already proxied on the component's prototype\n    // during Vue.extend(). We only need to proxy props defined at\n    // instantiation here.\n    if (!(key in vm)) {\n      proxy(vm, \"_props\", key);\n    }\n  };\n\n  for (var key in propsOptions) loop( key );\n  observerState.shouldConvert = true;\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? getData(data, vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object:\\n' +\n      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var methods = vm.$options.methods;\n  var i = keys.length;\n  while (i--) {\n    var key = keys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods && hasOwn(methods, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n          vm\n        );\n      }\n    }\n    if (props && hasOwn(props, key)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else if (!isReserved(key)) {\n      proxy(vm, \"_data\", key);\n    }\n  }\n  // observe data\n  observe(data, true /* asRootData */);\n}\n\nfunction getData (data, vm) {\n  try {\n    return data.call(vm)\n  } catch (e) {\n    handleError(e, vm, \"data()\");\n    return {}\n  }\n}\n\nvar computedWatcherOptions = { lazy: true };\n\nfunction initComputed (vm, computed) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'computed');\n  var watchers = vm._computedWatchers = Object.create(null);\n\n  for (var key in computed) {\n    var userDef = computed[key];\n    var getter = typeof userDef === 'function' ? userDef : userDef.get;\n    if (process.env.NODE_ENV !== 'production' && getter == null) {\n      warn(\n        (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n        vm\n      );\n    }\n    // create internal watcher for the computed property.\n    watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);\n\n    // component-defined computed properties are already defined on the\n    // component prototype. We only need to define computed properties defined\n    // at instantiation here.\n    if (!(key in vm)) {\n      defineComputed(vm, key, userDef);\n    } else if (process.env.NODE_ENV !== 'production') {\n      if (key in vm.$data) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n      } else if (vm.$options.props && key in vm.$options.props) {\n        warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n      }\n    }\n  }\n}\n\nfunction defineComputed (target, key, userDef) {\n  if (typeof userDef === 'function') {\n    sharedPropertyDefinition.get = createComputedGetter(key);\n    sharedPropertyDefinition.set = noop;\n  } else {\n    sharedPropertyDefinition.get = userDef.get\n      ? userDef.cache !== false\n        ? createComputedGetter(key)\n        : userDef.get\n      : noop;\n    sharedPropertyDefinition.set = userDef.set\n      ? userDef.set\n      : noop;\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n      sharedPropertyDefinition.set === noop) {\n    sharedPropertyDefinition.set = function () {\n      warn(\n        (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n        this\n      );\n    };\n  }\n  Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n\nfunction createComputedGetter (key) {\n  return function computedGetter () {\n    var watcher = this._computedWatchers && this._computedWatchers[key];\n    if (watcher) {\n      if (watcher.dirty) {\n        watcher.evaluate();\n      }\n      if (Dep.target) {\n        watcher.depend();\n      }\n      return watcher.value\n    }\n  }\n}\n\nfunction initMethods (vm, methods) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'methods');\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\n    if (process.env.NODE_ENV !== 'production') {\n      if (methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          (\"method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm, watch) {\n  process.env.NODE_ENV !== 'production' && checkOptionType(vm, 'watch');\n  for (var key in watch) {\n    var handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (var i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nfunction createWatcher (\n  vm,\n  keyOrFn,\n  handler,\n  options\n) {\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  return vm.$watch(keyOrFn, handler, options)\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () { return this._data };\n  var propsDef = {};\n  propsDef.get = function () { return this._props };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n    propsDef.set = function () {\n      warn(\"$props is readonly.\", this);\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n  Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    if (isPlainObject(cb)) {\n      return createWatcher(vm, expOrFn, cb, options)\n    }\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\n/*  */\n\nfunction initProvide (vm) {\n  var provide = vm.$options.provide;\n  if (provide) {\n    vm._provided = typeof provide === 'function'\n      ? provide.call(vm)\n      : provide;\n  }\n}\n\nfunction initInjections (vm) {\n  var result = resolveInject(vm.$options.inject, vm);\n  if (result) {\n    observerState.shouldConvert = false;\n    Object.keys(result).forEach(function (key) {\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        defineReactive$$1(vm, key, result[key], function () {\n          warn(\n            \"Avoid mutating an injected value directly since the changes will be \" +\n            \"overwritten whenever the provided component re-renders. \" +\n            \"injection being mutated: \\\"\" + key + \"\\\"\",\n            vm\n          );\n        });\n      } else {\n        defineReactive$$1(vm, key, result[key]);\n      }\n    });\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction resolveInject (inject, vm) {\n  if (inject) {\n    // inject is :any because flow is not smart enough to figure out cached\n    var result = Object.create(null);\n    var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var provideKey = inject[key];\n      var source = vm;\n      while (source) {\n        if (source._provided && provideKey in source._provided) {\n          result[key] = source._provided[provideKey];\n          break\n        }\n        source = source.$parent;\n      }\n      if (process.env.NODE_ENV !== 'production' && !source) {\n        warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n      }\n    }\n    return result\n  }\n}\n\n/*  */\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (isDef(propOptions)) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData || {});\n    }\n  } else {\n    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n    if (isDef(data.props)) { mergeProps(props, data.props); }\n  }\n  // ensure the createElement function in functional components\n  // gets a unique context - this is necessary for correct named slot check\n  var _context = Object.create(context);\n  var h = function (a, b, c, d) { return createElement(_context, a, b, c, d, true); };\n  var vnode = Ctor.options.render.call(null, h, {\n    data: data,\n    props: props,\n    children: children,\n    parent: context,\n    listeners: data.on || {},\n    injections: resolveInject(Ctor.options.inject, context),\n    slots: function () { return resolveSlots(children, context); }\n  });\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    vnode.functionalOptions = Ctor.options;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction mergeProps (to, from) {\n  for (var key in from) {\n    to[camelize(key)] = from[key];\n  }\n}\n\n/*  */\n\n// hooks to be invoked on component VNodes during patch\nvar componentVNodeHooks = {\n  init: function init (\n    vnode,\n    hydrating,\n    parentElm,\n    refElm\n  ) {\n    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {\n      var child = vnode.componentInstance = createComponentInstanceForVnode(\n        vnode,\n        activeInstance,\n        parentElm,\n        refElm\n      );\n      child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n    } else if (vnode.data.keepAlive) {\n      // kept-alive components, treat as a patch\n      var mountedNode = vnode; // work around flow\n      componentVNodeHooks.prepatch(mountedNode, mountedNode);\n    }\n  },\n\n  prepatch: function prepatch (oldVnode, vnode) {\n    var options = vnode.componentOptions;\n    var child = vnode.componentInstance = oldVnode.componentInstance;\n    updateChildComponent(\n      child,\n      options.propsData, // updated props\n      options.listeners, // updated listeners\n      vnode, // new parent vnode\n      options.children // new children\n    );\n  },\n\n  insert: function insert (vnode) {\n    var context = vnode.context;\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isMounted) {\n      componentInstance._isMounted = true;\n      callHook(componentInstance, 'mounted');\n    }\n    if (vnode.data.keepAlive) {\n      if (context._isMounted) {\n        // vue-router#1212\n        // During updates, a kept-alive component's child components may\n        // change, so directly walking the tree here may call activated hooks\n        // on incorrect children. Instead we push them into a queue which will\n        // be processed after the whole patch process ended.\n        queueActivatedComponent(componentInstance);\n      } else {\n        activateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  },\n\n  destroy: function destroy (vnode) {\n    var componentInstance = vnode.componentInstance;\n    if (!componentInstance._isDestroyed) {\n      if (!vnode.data.keepAlive) {\n        componentInstance.$destroy();\n      } else {\n        deactivateChildComponent(componentInstance, true /* direct */);\n      }\n    }\n  }\n};\n\nvar hooksToMerge = Object.keys(componentVNodeHooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  // plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  // if at this stage it's not a constructor or an async component factory,\n  // reject.\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  var asyncFactory;\n  if (isUndef(Ctor.cid)) {\n    asyncFactory = Ctor;\n    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);\n    if (Ctor === undefined) {\n      // return a placeholder node for async component, which is rendered\n      // as a comment node but preserves all the raw information for the node.\n      // the information will be used for async server-rendering and hydration.\n      return createAsyncPlaceholder(\n        asyncFactory,\n        data,\n        context,\n        children,\n        tag\n      )\n    }\n  }\n\n  data = data || {};\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  // transform component v-model data into props & events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  // extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  // functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  // so it gets processed during parent component patch.\n  data.on = data.nativeOn;\n\n  if (isTrue(Ctor.options.abstract)) {\n    // abstract components do not keep anything\n    // other than props & listeners & slot\n\n    // work around flow\n    var slot = data.slot;\n    data = {};\n    if (slot) {\n      data.slot = slot;\n    }\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n    asyncFactory\n  );\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent, // activeInstance in lifecycle state\n  parentElm,\n  refElm\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children,\n    _parentElm: parentElm || null,\n    _refElm: refElm || null\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (isDef(inlineTemplate)) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = componentVNodeHooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (one, two) {\n  return function (a, b, c, d) {\n    one(a, b, c, d);\n    two(a, b, c, d);\n  }\n}\n\n// transform component v-model info (value and callback) into\n// prop and event handler respectively.\nfunction transformModel (options, data) {\n  var prop = (options.model && options.model.prop) || 'value';\n  var event = (options.model && options.model.event) || 'input';(data.props || (data.props = {}))[prop] = data.model.value;\n  var on = data.on || (data.on = {});\n  if (isDef(on[event])) {\n    on[event] = [data.model.callback].concat(on[event]);\n  } else {\n    on[event] = data.model.callback;\n  }\n}\n\n/*  */\n\nvar SIMPLE_NORMALIZE = 1;\nvar ALWAYS_NORMALIZE = 2;\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType,\n  alwaysNormalize\n) {\n  if (Array.isArray(data) || isPrimitive(data)) {\n    normalizationType = children;\n    children = data;\n    data = undefined;\n  }\n  if (isTrue(alwaysNormalize)) {\n    normalizationType = ALWAYS_NORMALIZE;\n  }\n  return _createElement(context, tag, data, children, normalizationType)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children,\n  normalizationType\n) {\n  if (isDef(data) && isDef((data).__ob__)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return createEmptyVNode()\n  }\n  // object syntax in v-bind\n  if (isDef(data) && isDef(data.is)) {\n    tag = data.is;\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return createEmptyVNode()\n  }\n  // warn against non-primitive key\n  if (process.env.NODE_ENV !== 'production' &&\n    isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n  ) {\n    warn(\n      'Avoid using non-primitive value as key, ' +\n      'use string/number value instead.',\n      context\n    );\n  }\n  // support single function children as default scoped slot\n  if (Array.isArray(children) &&\n    typeof children[0] === 'function'\n  ) {\n    data = data || {};\n    data.scopedSlots = { default: children[0] };\n    children.length = 0;\n  }\n  if (normalizationType === ALWAYS_NORMALIZE) {\n    children = normalizeChildren(children);\n  } else if (normalizationType === SIMPLE_NORMALIZE) {\n    children = simpleNormalizeChildren(children);\n  }\n  var vnode, ns;\n  if (typeof tag === 'string') {\n    var Ctor;\n    ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      vnode = new VNode(\n        config.parsePlatformTagName(tag), data, children,\n        undefined, undefined, context\n      );\n    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      vnode = createComponent(Ctor, data, context, children, tag);\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      vnode = new VNode(\n        tag, data, children,\n        undefined, undefined, context\n      );\n    }\n  } else {\n    // direct component options / constructor\n    vnode = createComponent(tag, data, context, children);\n  }\n  if (isDef(vnode)) {\n    if (ns) { applyNS(vnode, ns); }\n    return vnode\n  } else {\n    return createEmptyVNode()\n  }\n}\n\nfunction applyNS (vnode, ns) {\n  vnode.ns = ns;\n  if (vnode.tag === 'foreignObject') {\n    // use default namespace inside foreignObject\n    return\n  }\n  if (isDef(vnode.children)) {\n    for (var i = 0, l = vnode.children.length; i < l; i++) {\n      var child = vnode.children[i];\n      if (isDef(child.tag) && isUndef(child.ns)) {\n        applyNS(child, ns);\n      }\n    }\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering v-for lists.\n */\nfunction renderList (\n  val,\n  render\n) {\n  var ret, i, l, keys, key;\n  if (Array.isArray(val) || typeof val === 'string') {\n    ret = new Array(val.length);\n    for (i = 0, l = val.length; i < l; i++) {\n      ret[i] = render(val[i], i);\n    }\n  } else if (typeof val === 'number') {\n    ret = new Array(val);\n    for (i = 0; i < val; i++) {\n      ret[i] = render(i + 1, i);\n    }\n  } else if (isObject(val)) {\n    keys = Object.keys(val);\n    ret = new Array(keys.length);\n    for (i = 0, l = keys.length; i < l; i++) {\n      key = keys[i];\n      ret[i] = render(val[key], key, i);\n    }\n  }\n  if (isDef(ret)) {\n    (ret)._isVList = true;\n  }\n  return ret\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering <slot>\n */\nfunction renderSlot (\n  name,\n  fallback,\n  props,\n  bindObject\n) {\n  var scopedSlotFn = this.$scopedSlots[name];\n  if (scopedSlotFn) { // scoped slot\n    props = props || {};\n    if (bindObject) {\n      props = extend(extend({}, bindObject), props);\n    }\n    return scopedSlotFn(props) || fallback\n  } else {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for resolving filters\n */\nfunction resolveFilter (id) {\n  return resolveAsset(this.$options, 'filters', id, true) || identity\n}\n\n/*  */\n\n/**\n * Runtime helper for checking keyCodes from config.\n */\nfunction checkKeyCodes (\n  eventKeyCode,\n  key,\n  builtInAlias\n) {\n  var keyCodes = config.keyCodes[key] || builtInAlias;\n  if (Array.isArray(keyCodes)) {\n    return keyCodes.indexOf(eventKeyCode) === -1\n  } else {\n    return keyCodes !== eventKeyCode\n  }\n}\n\n/*  */\n\n/**\n * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n */\nfunction bindObjectProps (\n  data,\n  tag,\n  value,\n  asProp,\n  isSync\n) {\n  if (value) {\n    if (!isObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-bind without argument expects an Object or Array value',\n        this\n      );\n    } else {\n      if (Array.isArray(value)) {\n        value = toObject(value);\n      }\n      var hash;\n      var loop = function ( key ) {\n        if (\n          key === 'class' ||\n          key === 'style' ||\n          isReservedAttribute(key)\n        ) {\n          hash = data;\n        } else {\n          var type = data.attrs && data.attrs.type;\n          hash = asProp || config.mustUseProp(tag, type, key)\n            ? data.domProps || (data.domProps = {})\n            : data.attrs || (data.attrs = {});\n        }\n        if (!(key in hash)) {\n          hash[key] = value[key];\n\n          if (isSync) {\n            var on = data.on || (data.on = {});\n            on[(\"update:\" + key)] = function ($event) {\n              value[key] = $event;\n            };\n          }\n        }\n      };\n\n      for (var key in value) loop( key );\n    }\n  }\n  return data\n}\n\n/*  */\n\n/**\n * Runtime helper for rendering static trees.\n */\nfunction renderStatic (\n  index,\n  isInFor\n) {\n  var tree = this._staticTrees[index];\n  // if has already-rendered static tree and not inside v-for,\n  // we can reuse the same tree by doing a shallow clone.\n  if (tree && !isInFor) {\n    return Array.isArray(tree)\n      ? cloneVNodes(tree)\n      : cloneVNode(tree)\n  }\n  // otherwise, render a fresh tree.\n  tree = this._staticTrees[index] =\n    this.$options.staticRenderFns[index].call(this._renderProxy);\n  markStatic(tree, (\"__static__\" + index), false);\n  return tree\n}\n\n/**\n * Runtime helper for v-once.\n * Effectively it means marking the node as static with a unique key.\n */\nfunction markOnce (\n  tree,\n  index,\n  key\n) {\n  markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n  return tree\n}\n\nfunction markStatic (\n  tree,\n  key,\n  isOnce\n) {\n  if (Array.isArray(tree)) {\n    for (var i = 0; i < tree.length; i++) {\n      if (tree[i] && typeof tree[i] !== 'string') {\n        markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n      }\n    }\n  } else {\n    markStaticNode(tree, key, isOnce);\n  }\n}\n\nfunction markStaticNode (node, key, isOnce) {\n  node.isStatic = true;\n  node.key = key;\n  node.isOnce = isOnce;\n}\n\n/*  */\n\nfunction bindObjectListeners (data, value) {\n  if (value) {\n    if (!isPlainObject(value)) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'v-on without argument expects an Object value',\n        this\n      );\n    } else {\n      var on = data.on = data.on ? extend({}, data.on) : {};\n      for (var key in value) {\n        var existing = on[key];\n        var ours = value[key];\n        on[key] = existing ? [].concat(ours, existing) : ours;\n      }\n    }\n  }\n  return data\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  var parentVnode = vm.$vnode = vm.$options._parentVnode; // the placeholder node in parent tree\n  var renderContext = parentVnode && parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, renderContext);\n  vm.$scopedSlots = emptyObject;\n  // bind the createElement fn to this instance\n  // so that we get proper render context inside it.\n  // args order: tag, data, children, normalizationType, alwaysNormalize\n  // internal version is used by render functions compiled from templates\n  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n  // normalization is always applied for the public version, used in\n  // user-written render functions.\n  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n  // $attrs & $listeners are exposed for easier HOC creation.\n  // they need to be reactive so that HOCs using them are always updated\n  var parentData = parentVnode && parentVnode.data;\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== 'production') {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, function () {\n      !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n    }, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, function () {\n      !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n    }, true);\n  } else {\n    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs, null, true);\n    defineReactive$$1(vm, '$listeners', vm.$options._parentListeners, null, true);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    return nextTick(fn, this)\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    vm.$scopedSlots = (_parentVnode && _parentVnode.data.scopedSlots) || emptyObject;\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      handleError(e, vm, \"render function\");\n      // return error render result,\n      // or previous vnode to prevent render error causing blank component\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        vnode = vm.$options.renderError\n          ? vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)\n          : vm._vnode;\n      } else {\n        vnode = vm._vnode;\n      }\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = createEmptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // internal render helpers.\n  // these are exposed on the instance prototype to reduce generated render\n  // code size.\n  Vue.prototype._o = markOnce;\n  Vue.prototype._n = toNumber;\n  Vue.prototype._s = toString;\n  Vue.prototype._l = renderList;\n  Vue.prototype._t = renderSlot;\n  Vue.prototype._q = looseEqual;\n  Vue.prototype._i = looseIndexOf;\n  Vue.prototype._m = renderStatic;\n  Vue.prototype._f = resolveFilter;\n  Vue.prototype._k = checkKeyCodes;\n  Vue.prototype._b = bindObjectProps;\n  Vue.prototype._v = createTextVNode;\n  Vue.prototype._e = createEmptyVNode;\n  Vue.prototype._u = resolveScopedSlots;\n  Vue.prototype._g = bindObjectListeners;\n}\n\n/*  */\n\nvar uid$1 = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid$1++;\n\n    var startTag, endTag;\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      startTag = \"vue-perf-init:\" + (vm._uid);\n      endTag = \"vue-perf-end:\" + (vm._uid);\n      mark(startTag);\n    }\n\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    initRender(vm);\n    callHook(vm, 'beforeCreate');\n    initInjections(vm); // resolve injections before data/props\n    initState(vm);\n    initProvide(vm); // resolve provide after data/props\n    callHook(vm, 'created');\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n      vm._name = formatComponentName(vm, false);\n      mark(endTag);\n      measure(((vm._name) + \" init\"), startTag, endTag);\n    }\n\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el);\n    }\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  opts._parentElm = options._parentElm;\n  opts._refElm = options._refElm;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = resolveConstructorOptions(Ctor.super);\n    var cachedSuperOptions = Ctor.superOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed,\n      // need to resolve new options.\n      Ctor.superOptions = superOptions;\n      // check if there are any late-modified/attached options (#4976)\n      var modifiedOptions = resolveModifiedOptions(Ctor);\n      // update base extend options\n      if (modifiedOptions) {\n        extend(Ctor.extendOptions, modifiedOptions);\n      }\n      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction resolveModifiedOptions (Ctor) {\n  var modified;\n  var latest = Ctor.options;\n  var extended = Ctor.extendOptions;\n  var sealed = Ctor.sealedOptions;\n  for (var key in latest) {\n    if (latest[key] !== sealed[key]) {\n      if (!modified) { modified = {}; }\n      modified[key] = dedupe(latest[key], extended[key], sealed[key]);\n    }\n  }\n  return modified\n}\n\nfunction dedupe (latest, extended, sealed) {\n  // compare latest and sealed to ensure lifecycle hooks won't be duplicated\n  // between merges\n  if (Array.isArray(latest)) {\n    var res = [];\n    sealed = Array.isArray(sealed) ? sealed : [sealed];\n    extended = Array.isArray(extended) ? extended : [extended];\n    for (var i = 0; i < latest.length; i++) {\n      // push original options and not sealed options to exclude duplicated options\n      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {\n        res.push(latest[i]);\n      }\n    }\n    return res\n  } else {\n    return latest\n  }\n}\n\nfunction Vue$3 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$3)\n  ) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$3);\nstateMixin(Vue$3);\neventsMixin(Vue$3);\nlifecycleMixin(Vue$3);\nrenderMixin(Vue$3);\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n    if (installedPlugins.indexOf(plugin) > -1) {\n      return this\n    }\n\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else if (typeof plugin === 'function') {\n      plugin.apply(null, args);\n    }\n    installedPlugins.push(plugin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n    return this\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characters and the hyphen, ' +\n          'and must start with a letter.'\n        );\n      }\n    }\n\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n\n    // For props and computed properties, we define the proxy getters on\n    // the Vue instances at extension time, on the extended prototype. This\n    // avoids Object.defineProperty calls for each instance created.\n    if (Sub.options.props) {\n      initProps$1(Sub);\n    }\n    if (Sub.options.computed) {\n      initComputed$1(Sub);\n    }\n\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    ASSET_TYPES.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    Sub.sealedOptions = extend({}, Sub.options);\n\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\nfunction initProps$1 (Comp) {\n  var props = Comp.options.props;\n  for (var key in props) {\n    proxy(Comp.prototype, \"_props\", key);\n  }\n}\n\nfunction initComputed$1 (Comp) {\n  var computed = Comp.options.computed;\n  for (var key in computed) {\n    defineComputed(Comp.prototype, key, computed[key]);\n  }\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  ASSET_TYPES.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\n/*  */\n\nvar patternTypes = [String, RegExp, Array];\n\nfunction getComponentName (opts) {\n  return opts && (opts.Ctor.options.name || opts.tag)\n}\n\nfunction matches (pattern, name) {\n  if (Array.isArray(pattern)) {\n    return pattern.indexOf(name) > -1\n  } else if (typeof pattern === 'string') {\n    return pattern.split(',').indexOf(name) > -1\n  } else if (isRegExp(pattern)) {\n    return pattern.test(name)\n  }\n  /* istanbul ignore next */\n  return false\n}\n\nfunction pruneCache (cache, current, filter) {\n  for (var key in cache) {\n    var cachedNode = cache[key];\n    if (cachedNode) {\n      var name = getComponentName(cachedNode.componentOptions);\n      if (name && !filter(name)) {\n        if (cachedNode !== current) {\n          pruneCacheEntry(cachedNode);\n        }\n        cache[key] = null;\n      }\n    }\n  }\n}\n\nfunction pruneCacheEntry (vnode) {\n  if (vnode) {\n    vnode.componentInstance.$destroy();\n  }\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n\n  props: {\n    include: patternTypes,\n    exclude: patternTypes\n  },\n\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this$1.cache) {\n      pruneCacheEntry(this$1.cache[key]);\n    }\n  },\n\n  watch: {\n    include: function include (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return matches(val, name); });\n    },\n    exclude: function exclude (val) {\n      pruneCache(this.cache, this._vnode, function (name) { return !matches(val, name); });\n    }\n  },\n\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    var componentOptions = vnode && vnode.componentOptions;\n    if (componentOptions) {\n      // check pattern\n      var name = getComponentName(componentOptions);\n      if (name && (\n        (this.include && !matches(this.include, name)) ||\n        (this.exclude && matches(this.exclude, name))\n      )) {\n        return vnode\n      }\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.componentInstance = this.cache[key].componentInstance;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n\n  // exposed util methods.\n  // NOTE: these are not considered part of the public API - avoid relying on\n  // them unless you are aware of the risk.\n  Vue.util = {\n    warn: warn,\n    extend: extend,\n    mergeOptions: mergeOptions,\n    defineReactive: defineReactive$$1\n  };\n\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  ASSET_TYPES.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$3);\n\nObject.defineProperty(Vue$3.prototype, '$isServer', {\n  get: isServerRendering\n});\n\nObject.defineProperty(Vue$3.prototype, '$ssrContext', {\n  get: function get () {\n    /* istanbul ignore next */\n    return this.$vnode && this.$vnode.ssrContext\n  }\n});\n\nVue$3.version = '2.4.2';\n\n/*  */\n\n// these are reserved for web because they are directly compiled away\n// during template compilation\nvar isReservedAttr = makeMap('style,class');\n\n// attributes that should be using props for binding\nvar acceptValue = makeMap('input,textarea,option,select');\nvar mustUseProp = function (tag, type, attr) {\n  return (\n    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (isDef(childNode.componentInstance)) {\n    childNode = childNode.componentInstance._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while (isDef(parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return renderClass(data.staticClass, data.class)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: isDef(child.class)\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction renderClass (\n  staticClass,\n  dynamicClass\n) {\n  if (isDef(staticClass) || isDef(dynamicClass)) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  if (Array.isArray(value)) {\n    return stringifyArray(value)\n  }\n  if (isObject(value)) {\n    return stringifyObject(value)\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction stringifyArray (value) {\n  var res = '';\n  var stringified;\n  for (var i = 0, l = value.length; i < l; i++) {\n    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n      if (res) { res += ' '; }\n      res += stringified;\n    }\n  }\n  return res\n}\n\nfunction stringifyObject (value) {\n  var res = '';\n  for (var key in value) {\n    if (value[key]) {\n      if (res) { res += ' '; }\n      res += key;\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template,blockquote,iframe,tfoot'\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\nvar isPreTag = function (tag) { return tag === 'pre'; };\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selected = document.querySelector(el);\n    if (!selected) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + el\n      );\n      return document.createElement('div')\n    }\n    return selected\n  } else {\n    return el\n  }\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  // false or null will remove the attribute but undefined will not\n  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.componentInstance || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (!Array.isArray(refs[key])) {\n        refs[key] = [ref];\n      } else if (refs[key].indexOf(ref) < 0) {\n        // $flow-disable-line\n        refs[key].push(ref);\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\nfunction sameVnode (a, b) {\n  return (\n    a.key === b.key && (\n      (\n        a.tag === b.tag &&\n        a.isComment === b.isComment &&\n        isDef(a.data) === isDef(b.data) &&\n        sameInputType(a, b)\n      ) || (\n        isTrue(a.isAsyncPlaceholder) &&\n        a.asyncFactory === b.asyncFactory &&\n        isUndef(b.asyncFactory.error)\n      )\n    )\n  )\n}\n\n// Some browsers do not support dynamically changing type for <input>\n// so they need to be treated as different nodes\nfunction sameInputType (a, b) {\n  if (a.tag !== 'input') { return true }\n  var i;\n  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n  return typeA === typeB\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks.length; ++i) {\n    cbs[hooks[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (isDef(modules[j][hooks[i]])) {\n        cbs[hooks[i]].push(modules[j][hooks[i]]);\n      }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeNode(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeNode (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html / v-text\n    if (isDef(parent)) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  var inPre = 0;\n  function createElm (vnode, insertedVnodeQueue, parentElm, refElm, nested) {\n    vnode.isRootInsert = !nested; // for transition enter check\n    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n      return\n    }\n\n    var data = vnode.data;\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (data && data.pre) {\n          inPre++;\n        }\n        if (\n          !inPre &&\n          !vnode.ns &&\n          !(config.ignoredElements.length && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n\n      /* istanbul ignore if */\n      {\n        createChildren(vnode, children, insertedVnodeQueue);\n        if (isDef(data)) {\n          invokeCreateHooks(vnode, insertedVnodeQueue);\n        }\n        insert(parentElm, vnode.elm, refElm);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && data && data.pre) {\n        inPre--;\n      }\n    } else if (isTrue(vnode.isComment)) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n      insert(parentElm, vnode.elm, refElm);\n    }\n  }\n\n  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i = vnode.data;\n    if (isDef(i)) {\n      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n      if (isDef(i = i.hook) && isDef(i = i.init)) {\n        i(vnode, false /* hydrating */, parentElm, refElm);\n      }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(vnode.componentInstance)) {\n        initComponent(vnode, insertedVnodeQueue);\n        if (isTrue(isReactivated)) {\n          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n        }\n        return true\n      }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (isDef(vnode.data.pendingInsert)) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n      vnode.data.pendingInsert = null;\n    }\n    vnode.elm = vnode.componentInstance.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n    var i;\n    // hack for #4339: a reactivated component with inner transition\n    // does not trigger because the inner node's created hooks are not called\n    // again. It's not ideal to involve module-specific logic in here but\n    // there doesn't seem to be a better way to do it.\n    var innerNode = vnode;\n    while (innerNode.componentInstance) {\n      innerNode = innerNode.componentInstance._vnode;\n      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n        for (i = 0; i < cbs.activate.length; ++i) {\n          cbs.activate[i](emptyNode, innerNode);\n        }\n        insertedVnodeQueue.push(innerNode);\n        break\n      }\n    }\n    // unlike a newly created component,\n    // a reactivated keep-alive component doesn't insert itself\n    insert(parentElm, vnode.elm, refElm);\n  }\n\n  function insert (parent, elm, ref$$1) {\n    if (isDef(parent)) {\n      if (isDef(ref$$1)) {\n        if (ref$$1.parentNode === parent) {\n          nodeOps.insertBefore(parent, elm, ref$$1);\n        }\n      } else {\n        nodeOps.appendChild(parent, elm);\n      }\n    }\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.componentInstance) {\n      vnode = vnode.componentInstance._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (isDef(i.create)) { i.create(emptyNode, vnode); }\n      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    var ancestor = vnode;\n    while (ancestor) {\n      if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n        nodeOps.setAttribute(vnode.elm, i, '');\n      }\n      ancestor = ancestor.parent;\n    }\n    // for slot content they should also get the scopeId from the host instance.\n    if (isDef(i = activeInstance) &&\n      i !== vnode.context &&\n      isDef(i = i.$options._scopeId)\n    ) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          removeNode(ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (isDef(rm) || isDef(vnode.data)) {\n      var i;\n      var listeners = cbs.remove.length + 1;\n      if (isDef(rm)) {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      } else {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeNode(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, refElm;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            // same key but different element. treat as new element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n\n    var elm = vnode.elm = oldVnode.elm;\n\n    if (isTrue(oldVnode.isAsyncPlaceholder)) {\n      if (isDef(vnode.asyncFactory.resolved)) {\n        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n      } else {\n        vnode.isAsyncPlaceholder = true;\n      }\n      return\n    }\n\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (isTrue(vnode.isStatic) &&\n      isTrue(oldVnode.isStatic) &&\n      vnode.key === oldVnode.key &&\n      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n    ) {\n      vnode.componentInstance = oldVnode.componentInstance;\n      return\n    }\n\n    var i;\n    var data = vnode.data;\n    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (isDef(data) && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (isTrue(initial) && isDef(vnode.parent)) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  // list of modules that can skip create hook during hydration because they\n  // are already rendered on the client or has no need for initialization\n  var isRenderedModule = makeMap('attrs,style,class,staticClass,staticStyle,key');\n\n  // Note: this is a browser-only function so we can assume elms are DOM nodes.\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n      vnode.elm = elm;\n      vnode.isAsyncPlaceholder = true;\n      return true\n    }\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.componentInstance)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        // empty element, allow client to pick up and populate children\n        if (!elm.hasChildNodes()) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          var childNode = elm.firstChild;\n          for (var i$1 = 0; i$1 < children.length; i$1++) {\n            if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue)) {\n              childrenMatch = false;\n              break\n            }\n            childNode = childNode.nextSibling;\n          }\n          // if childNode is not null, it means the actual childNodes list is\n          // longer than the virtual children list.\n          if (!childrenMatch || childNode) {\n            if (process.env.NODE_ENV !== 'production' &&\n              typeof console !== 'undefined' &&\n              !bailed\n            ) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        for (var key in data) {\n          if (!isRenderedModule(key)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n            break\n          }\n        }\n      }\n    } else if (elm.data !== vnode.text) {\n      elm.data = vnode.text;\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (isDef(vnode.tag)) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n      )\n    } else {\n      return node.nodeType === (vnode.isComment ? 8 : 3)\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n    if (isUndef(vnode)) {\n      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (isUndef(oldVnode)) {\n      // empty mount (likely as component), create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue, parentElm, refElm);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        // patch existing root node\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n            oldVnode.removeAttribute(SSR_ATTR);\n            hydrating = true;\n          }\n          if (isTrue(hydrating)) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        // replacing existing element\n        var oldElm = oldVnode.elm;\n        var parentElm$1 = nodeOps.parentNode(oldElm);\n        createElm(\n          vnode,\n          insertedVnodeQueue,\n          // extremely rare edge case: do not insert if old element is in a\n          // leaving transition. Only happens when combining transition +\n          // keep-alive + HOCs. (#4590)\n          oldElm._leaveCb ? null : parentElm$1,\n          nodeOps.nextSibling(oldElm)\n        );\n\n        if (isDef(vnode.parent)) {\n          // component root element replaced.\n          // update parent placeholder node element, recursively\n          var ancestor = vnode.parent;\n          while (ancestor) {\n            ancestor.elm = vnode.elm;\n            ancestor = ancestor.parent;\n          }\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (isDef(parentElm$1)) {\n          removeVnodes(parentElm$1, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (oldVnode, vnode) {\n  if (oldVnode.data.directives || vnode.data.directives) {\n    _update(oldVnode, vnode);\n  }\n}\n\nfunction _update (oldVnode, vnode) {\n  var isCreate = oldVnode === emptyNode;\n  var isDestroy = vnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      for (var i = 0; i < dirsWithInsert.length; i++) {\n        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n      }\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert);\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      for (var i = 0; i < dirsWithPostpatch.length; i++) {\n        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n      }\n    });\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    try {\n      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n    } catch (e) {\n      handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n    }\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  var opts = vnode.componentOptions;\n  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n    return\n  }\n  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(attrs.__ob__)) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  // #4391: in IE9, setting type can reset value for input[type=radio]\n  /* istanbul ignore if */\n  if (isIE9 && attrs.value !== oldAttrs.value) {\n    setAttr(elm, 'value', attrs.value);\n  }\n  for (key in oldAttrs) {\n    if (isUndef(attrs[key])) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (\n    isUndef(data.staticClass) &&\n    isUndef(data.class) && (\n      isUndef(oldData) || (\n        isUndef(oldData.staticClass) &&\n        isUndef(oldData.class)\n      )\n    )\n  ) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (isDef(transitionClass)) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n/*  */\n\nvar validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\nfunction parseFilters (exp) {\n  var inSingle = false;\n  var inDouble = false;\n  var inTemplateString = false;\n  var inRegex = false;\n  var curly = 0;\n  var square = 0;\n  var paren = 0;\n  var lastFilterIndex = 0;\n  var c, prev, i, expression, filters;\n\n  for (i = 0; i < exp.length; i++) {\n    prev = c;\n    c = exp.charCodeAt(i);\n    if (inSingle) {\n      if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n    } else if (inDouble) {\n      if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n    } else if (inTemplateString) {\n      if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n    } else if (inRegex) {\n      if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n    } else if (\n      c === 0x7C && // pipe\n      exp.charCodeAt(i + 1) !== 0x7C &&\n      exp.charCodeAt(i - 1) !== 0x7C &&\n      !curly && !square && !paren\n    ) {\n      if (expression === undefined) {\n        // first filter, end of expression\n        lastFilterIndex = i + 1;\n        expression = exp.slice(0, i).trim();\n      } else {\n        pushFilter();\n      }\n    } else {\n      switch (c) {\n        case 0x22: inDouble = true; break         // \"\n        case 0x27: inSingle = true; break         // '\n        case 0x60: inTemplateString = true; break // `\n        case 0x28: paren++; break                 // (\n        case 0x29: paren--; break                 // )\n        case 0x5B: square++; break                // [\n        case 0x5D: square--; break                // ]\n        case 0x7B: curly++; break                 // {\n        case 0x7D: curly--; break                 // }\n      }\n      if (c === 0x2f) { // /\n        var j = i - 1;\n        var p = (void 0);\n        // find first non-whitespace prev char\n        for (; j >= 0; j--) {\n          p = exp.charAt(j);\n          if (p !== ' ') { break }\n        }\n        if (!p || !validDivisionCharRE.test(p)) {\n          inRegex = true;\n        }\n      }\n    }\n  }\n\n  if (expression === undefined) {\n    expression = exp.slice(0, i).trim();\n  } else if (lastFilterIndex !== 0) {\n    pushFilter();\n  }\n\n  function pushFilter () {\n    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n    lastFilterIndex = i + 1;\n  }\n\n  if (filters) {\n    for (i = 0; i < filters.length; i++) {\n      expression = wrapFilter(expression, filters[i]);\n    }\n  }\n\n  return expression\n}\n\nfunction wrapFilter (exp, filter) {\n  var i = filter.indexOf('(');\n  if (i < 0) {\n    // _f: resolveFilter\n    return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n  } else {\n    var name = filter.slice(0, i);\n    var args = filter.slice(i + 1);\n    return (\"_f(\\\"\" + name + \"\\\")(\" + exp + \",\" + args)\n  }\n}\n\n/*  */\n\nfunction baseWarn (msg) {\n  console.error((\"[Vue compiler]: \" + msg));\n}\n\nfunction pluckModuleFunction (\n  modules,\n  key\n) {\n  return modules\n    ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n    : []\n}\n\nfunction addProp (el, name, value) {\n  (el.props || (el.props = [])).push({ name: name, value: value });\n}\n\nfunction addAttr (el, name, value) {\n  (el.attrs || (el.attrs = [])).push({ name: name, value: value });\n}\n\nfunction addDirective (\n  el,\n  name,\n  rawName,\n  value,\n  arg,\n  modifiers\n) {\n  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });\n}\n\nfunction addHandler (\n  el,\n  name,\n  value,\n  modifiers,\n  important,\n  warn\n) {\n  // warn prevent and passive modifier\n  /* istanbul ignore if */\n  if (\n    process.env.NODE_ENV !== 'production' && warn &&\n    modifiers && modifiers.prevent && modifiers.passive\n  ) {\n    warn(\n      'passive and prevent can\\'t be used together. ' +\n      'Passive handler can\\'t prevent default event.'\n    );\n  }\n  // check capture modifier\n  if (modifiers && modifiers.capture) {\n    delete modifiers.capture;\n    name = '!' + name; // mark the event as captured\n  }\n  if (modifiers && modifiers.once) {\n    delete modifiers.once;\n    name = '~' + name; // mark the event as once\n  }\n  /* istanbul ignore if */\n  if (modifiers && modifiers.passive) {\n    delete modifiers.passive;\n    name = '&' + name; // mark the event as passive\n  }\n  var events;\n  if (modifiers && modifiers.native) {\n    delete modifiers.native;\n    events = el.nativeEvents || (el.nativeEvents = {});\n  } else {\n    events = el.events || (el.events = {});\n  }\n  var newHandler = { value: value, modifiers: modifiers };\n  var handlers = events[name];\n  /* istanbul ignore if */\n  if (Array.isArray(handlers)) {\n    important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n  } else if (handlers) {\n    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n  } else {\n    events[name] = newHandler;\n  }\n}\n\nfunction getBindingAttr (\n  el,\n  name,\n  getStatic\n) {\n  var dynamicValue =\n    getAndRemoveAttr(el, ':' + name) ||\n    getAndRemoveAttr(el, 'v-bind:' + name);\n  if (dynamicValue != null) {\n    return parseFilters(dynamicValue)\n  } else if (getStatic !== false) {\n    var staticValue = getAndRemoveAttr(el, name);\n    if (staticValue != null) {\n      return JSON.stringify(staticValue)\n    }\n  }\n}\n\nfunction getAndRemoveAttr (el, name) {\n  var val;\n  if ((val = el.attrsMap[name]) != null) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].name === name) {\n        list.splice(i, 1);\n        break\n      }\n    }\n  }\n  return val\n}\n\n/*  */\n\n/**\n * Cross-platform code generation for component v-model\n */\nfunction genComponentModel (\n  el,\n  value,\n  modifiers\n) {\n  var ref = modifiers || {};\n  var number = ref.number;\n  var trim = ref.trim;\n\n  var baseValueExpression = '$$v';\n  var valueExpression = baseValueExpression;\n  if (trim) {\n    valueExpression =\n      \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n  var assignment = genAssignmentCode(value, valueExpression);\n\n  el.model = {\n    value: (\"(\" + value + \")\"),\n    expression: (\"\\\"\" + value + \"\\\"\"),\n    callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n  };\n}\n\n/**\n * Cross-platform codegen helper for generating v-model value assignment code.\n */\nfunction genAssignmentCode (\n  value,\n  assignment\n) {\n  var modelRs = parseModel(value);\n  if (modelRs.idx === null) {\n    return (value + \"=\" + assignment)\n  } else {\n    return (\"$set(\" + (modelRs.exp) + \", \" + (modelRs.idx) + \", \" + assignment + \")\")\n  }\n}\n\n/**\n * parse directive model to do the array update transform. a[idx] = val => $$a.splice($$idx, 1, val)\n *\n * for loop possible cases:\n *\n * - test\n * - test[idx]\n * - test[test1[idx]]\n * - test[\"a\"][idx]\n * - xxx.test[a[a].test1[idx]]\n * - test.xxx.a[\"asa\"][test1[idx]]\n *\n */\n\nvar len;\nvar str;\nvar chr;\nvar index$1;\nvar expressionPos;\nvar expressionEndPos;\n\nfunction parseModel (val) {\n  str = val;\n  len = str.length;\n  index$1 = expressionPos = expressionEndPos = 0;\n\n  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n    return {\n      exp: val,\n      idx: null\n    }\n  }\n\n  while (!eof()) {\n    chr = next();\n    /* istanbul ignore if */\n    if (isStringStart(chr)) {\n      parseString(chr);\n    } else if (chr === 0x5B) {\n      parseBracket(chr);\n    }\n  }\n\n  return {\n    exp: val.substring(0, expressionPos),\n    idx: val.substring(expressionPos + 1, expressionEndPos)\n  }\n}\n\nfunction next () {\n  return str.charCodeAt(++index$1)\n}\n\nfunction eof () {\n  return index$1 >= len\n}\n\nfunction isStringStart (chr) {\n  return chr === 0x22 || chr === 0x27\n}\n\nfunction parseBracket (chr) {\n  var inBracket = 1;\n  expressionPos = index$1;\n  while (!eof()) {\n    chr = next();\n    if (isStringStart(chr)) {\n      parseString(chr);\n      continue\n    }\n    if (chr === 0x5B) { inBracket++; }\n    if (chr === 0x5D) { inBracket--; }\n    if (inBracket === 0) {\n      expressionEndPos = index$1;\n      break\n    }\n  }\n}\n\nfunction parseString (chr) {\n  var stringQuote = chr;\n  while (!eof()) {\n    chr = next();\n    if (chr === stringQuote) {\n      break\n    }\n  }\n}\n\n/*  */\n\nvar warn$1;\n\n// in some cases, the event used has to be determined at runtime\n// so we used some reserved tokens during compile.\nvar RANGE_TOKEN = '__r';\nvar CHECKBOX_RADIO_TOKEN = '__c';\n\nfunction model (\n  el,\n  dir,\n  _warn\n) {\n  warn$1 = _warn;\n  var value = dir.value;\n  var modifiers = dir.modifiers;\n  var tag = el.tag;\n  var type = el.attrsMap.type;\n\n  if (process.env.NODE_ENV !== 'production') {\n    var dynamicType = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n    if (tag === 'input' && dynamicType) {\n      warn$1(\n        \"<input :type=\\\"\" + dynamicType + \"\\\" v-model=\\\"\" + value + \"\\\">:\\n\" +\n        \"v-model does not support dynamic input types. Use v-if branches instead.\"\n      );\n    }\n    // inputs with type=\"file\" are read only and setting the input's\n    // value will throw an error.\n    if (tag === 'input' && type === 'file') {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n        \"File inputs are read only. Use a v-on:change listener instead.\"\n      );\n    }\n  }\n\n  if (el.component) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (tag === 'select') {\n    genSelect(el, value, modifiers);\n  } else if (tag === 'input' && type === 'checkbox') {\n    genCheckboxModel(el, value, modifiers);\n  } else if (tag === 'input' && type === 'radio') {\n    genRadioModel(el, value, modifiers);\n  } else if (tag === 'input' || tag === 'textarea') {\n    genDefaultModel(el, value, modifiers);\n  } else if (!config.isReservedTag(tag)) {\n    genComponentModel(el, value, modifiers);\n    // component v-model doesn't need extra runtime\n    return false\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$1(\n      \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n      \"v-model is not supported on this element type. \" +\n      'If you are working with contenteditable, it\\'s recommended to ' +\n      'wrap a library dedicated for that purpose inside a custom component.'\n    );\n  }\n\n  // ensure runtime directive metadata\n  return true\n}\n\nfunction genCheckboxModel (\n  el,\n  value,\n  modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n  addProp(el, 'checked',\n    \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n  );\n  addHandler(el, CHECKBOX_RADIO_TOKEN,\n    \"var $$a=\" + value + \",\" +\n        '$$el=$event.target,' +\n        \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n    'if(Array.isArray($$a)){' +\n      \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n          '$$i=_i($$a,$$v);' +\n      \"if($$el.checked){$$i<0&&(\" + value + \"=$$a.concat($$v))}\" +\n      \"else{$$i>-1&&(\" + value + \"=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}\" +\n    \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n    null, true\n  );\n}\n\nfunction genRadioModel (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var valueBinding = getBindingAttr(el, 'value') || 'null';\n  valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n  addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n  addHandler(el, CHECKBOX_RADIO_TOKEN, genAssignmentCode(value, valueBinding), null, true);\n}\n\nfunction genSelect (\n    el,\n    value,\n    modifiers\n) {\n  var number = modifiers && modifiers.number;\n  var selectedVal = \"Array.prototype.filter\" +\n    \".call($event.target.options,function(o){return o.selected})\" +\n    \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n    \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n  var code = \"var $$selectedVal = \" + selectedVal + \";\";\n  code = code + \" \" + (genAssignmentCode(value, assignment));\n  addHandler(el, 'change', code, null, true);\n}\n\nfunction genDefaultModel (\n  el,\n  value,\n  modifiers\n) {\n  var type = el.attrsMap.type;\n  var ref = modifiers || {};\n  var lazy = ref.lazy;\n  var number = ref.number;\n  var trim = ref.trim;\n  var needCompositionGuard = !lazy && type !== 'range';\n  var event = lazy\n    ? 'change'\n    : type === 'range'\n      ? RANGE_TOKEN\n      : 'input';\n\n  var valueExpression = '$event.target.value';\n  if (trim) {\n    valueExpression = \"$event.target.value.trim()\";\n  }\n  if (number) {\n    valueExpression = \"_n(\" + valueExpression + \")\";\n  }\n\n  var code = genAssignmentCode(value, valueExpression);\n  if (needCompositionGuard) {\n    code = \"if($event.target.composing)return;\" + code;\n  }\n\n  addProp(el, 'value', (\"(\" + value + \")\"));\n  addHandler(el, event, code, null, true);\n  if (trim || number) {\n    addHandler(el, 'blur', '$forceUpdate()');\n  }\n}\n\n/*  */\n\n// normalize v-model event tokens that can only be determined at runtime.\n// it's important to place the event as the first in the array because\n// the whole point is ensuring the v-model callback gets called before\n// user-attached handlers.\nfunction normalizeEvents (on) {\n  var event;\n  /* istanbul ignore if */\n  if (isDef(on[RANGE_TOKEN])) {\n    // IE input[type=range] only supports `change` event\n    event = isIE ? 'change' : 'input';\n    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n    delete on[RANGE_TOKEN];\n  }\n  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n    // Chrome fires microtasks in between click/change, leads to #4521\n    event = isChrome ? 'click' : 'change';\n    on[event] = [].concat(on[CHECKBOX_RADIO_TOKEN], on[event] || []);\n    delete on[CHECKBOX_RADIO_TOKEN];\n  }\n}\n\nvar target$1;\n\nfunction add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; // save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\n      : capture\n  );\n}\n\nfunction remove$2 (\n  event,\n  handler,\n  capture,\n  _target\n) {\n  (_target || target$1).removeEventListener(event, handler, capture);\n}\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  target$1 = vnode.elm;\n  normalizeEvents(on);\n  updateListeners(on, oldOn, add$1, remove$2, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (isDef(props.__ob__)) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (isUndef(props[key])) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = isUndef(cur) ? '' : String(cur);\n      if (shouldUpdateValue(elm, vnode, strCur)) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\n// check platforms/web/util/attrs.js acceptValue\n\n\nfunction shouldUpdateValue (\n  elm,\n  vnode,\n  checkVal\n) {\n  return (!elm.composing && (\n    vnode.tag === 'option' ||\n    isDirty(elm, checkVal) ||\n    isInputChanged(elm, checkVal)\n  ))\n}\n\nfunction isDirty (elm, checkVal) {\n  // return true when textbox (.number and .trim) loses focus and its value is\n  // not equal to the updated value\n  var notInFocus = true;\n  // #6157\n  // work around IE bug when accessing document.activeElement in an iframe\n  try { notInFocus = document.activeElement !== elm; } catch (e) {}\n  return notInFocus && elm.value !== checkVal\n}\n\nfunction isInputChanged (elm, newVal) {\n  var value = elm.value;\n  var modifiers = elm._vModifiers; // injected by v-model runtime\n  if (isDef(modifiers) && modifiers.number) {\n    return toNumber(value) !== toNumber(newVal)\n  }\n  if (isDef(modifiers) && modifiers.trim) {\n    return value.trim() !== newVal.trim()\n  }\n  return value !== newVal\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var listDelimiter = /;(?![^(]*\\))/g;\n  var propertyDelimiter = /:(.+)/;\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.componentInstance) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar importantRE = /\\s*!important$/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else if (importantRE.test(val)) {\n    el.style.setProperty(name, val.replace(importantRE, ''), 'important');\n  } else {\n    var normalizedName = normalize(name);\n    if (Array.isArray(val)) {\n      // Support values array created by autoprefixer, e.g.\n      // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n      // Set them one by one, and the browser will only set those it can recognize\n      for (var i = 0, len = val.length; i < len; i++) {\n        el.style[normalizedName] = val[i];\n      }\n    } else {\n      el.style[normalizedName] = val;\n    }\n  }\n};\n\nvar vendorNames = ['Webkit', 'Moz', 'ms'];\n\nvar emptyStyle;\nvar normalize = cached(function (prop) {\n  emptyStyle = emptyStyle || document.createElement('div').style;\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in emptyStyle)) {\n    return prop\n  }\n  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < vendorNames.length; i++) {\n    var name = vendorNames[i] + capName;\n    if (name in emptyStyle) {\n      return name\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (isUndef(data.staticStyle) && isUndef(data.style) &&\n    isUndef(oldData.staticStyle) && isUndef(oldData.style)\n  ) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldData.staticStyle;\n  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  // store normalized style under a different key for next diff\n  // make sure to clone it if it's reactive, since the user likley wants\n  // to mutate it.\n  vnode.data.normalizedStyle = isDef(style.__ob__)\n    ? extend({}, style)\n    : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (isUndef(newStyle[name])) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !(cls = cls.trim())) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n    if (!el.classList.length) {\n      el.removeAttribute('class');\n    }\n  } else {\n    var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    cur = cur.trim();\n    if (cur) {\n      el.setAttribute('class', cur);\n    } else {\n      el.removeAttribute('class');\n    }\n  }\n}\n\n/*  */\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    enterToClass: (name + \"-enter-to\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveClass: (name + \"-leave\"),\n    leaveToClass: (name + \"-leave-to\"),\n    leaveActiveClass: (name + \"-leave-active\")\n  }\n});\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined\n  ) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined\n  ) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\n// binding to window is necessary to make hot reload work in IE in strict mode\nvar raf = inBrowser && window.requestAnimationFrame\n  ? window.requestAnimationFrame.bind(window)\n  : setTimeout;\n\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n  if (transitionClasses.indexOf(cls) < 0) {\n    transitionClasses.push(cls);\n    addClass(el, cls);\n  }\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode, toggleDisplay) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (isDef(el._leaveCb)) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._enterCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterToClass = data.enterToClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearToClass = data.appearToClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n  var duration = data.duration;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var context = activeInstance;\n  var transitionNode = activeInstance.$vnode;\n  while (transitionNode && transitionNode.parent) {\n    transitionNode = transitionNode.parent;\n    context = transitionNode.context;\n  }\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear && appearClass\n    ? appearClass\n    : enterClass;\n  var activeClass = isAppear && appearActiveClass\n    ? appearActiveClass\n    : enterActiveClass;\n  var toClass = isAppear && appearToClass\n    ? appearToClass\n    : enterToClass;\n\n  var beforeEnterHook = isAppear\n    ? (beforeAppear || beforeEnter)\n    : beforeEnter;\n  var enterHook = isAppear\n    ? (typeof appear === 'function' ? appear : enter)\n    : enter;\n  var afterEnterHook = isAppear\n    ? (afterAppear || afterEnter)\n    : afterEnter;\n  var enterCancelledHook = isAppear\n    ? (appearCancelled || enterCancelled)\n    : enterCancelled;\n\n  var explicitEnterDuration = toNumber(\n    isObject(duration)\n      ? duration.enter\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && explicitEnterDuration != null) {\n    checkDuration(explicitEnterDuration, 'enter', vnode);\n  }\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(enterHook);\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, toClass);\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode &&\n        pendingNode.tag === vnode.tag &&\n        pendingNode.elm._leaveCb\n      ) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    });\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      addTransitionClass(el, toClass);\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        if (isValidDuration(explicitEnterDuration)) {\n          setTimeout(cb, explicitEnterDuration);\n        } else {\n          whenTransitionEnds(el, type, cb);\n        }\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    toggleDisplay && toggleDisplay();\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (isDef(el._enterCb)) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (isUndef(data)) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (isDef(el._leaveCb) || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveToClass = data.leaveToClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n  var duration = data.duration;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl = getHookArgumentsLength(leave);\n\n  var explicitLeaveDuration = toNumber(\n    isObject(duration)\n      ? duration.leave\n      : duration\n  );\n\n  if (process.env.NODE_ENV !== 'production' && isDef(explicitLeaveDuration)) {\n    checkDuration(explicitLeaveDuration, 'leave', vnode);\n  }\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveToClass);\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        addTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          if (isValidDuration(explicitLeaveDuration)) {\n            setTimeout(cb, explicitLeaveDuration);\n          } else {\n            whenTransitionEnds(el, type, cb);\n          }\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\n// only used in dev mode\nfunction checkDuration (val, name, vnode) {\n  if (typeof val !== 'number') {\n    warn(\n      \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n      \"got \" + (JSON.stringify(val)) + \".\",\n      vnode.context\n    );\n  } else if (isNaN(val)) {\n    warn(\n      \"<transition> explicit \" + name + \" duration is NaN - \" +\n      'the duration expression might be incorrect.',\n      vnode.context\n    );\n  }\n}\n\nfunction isValidDuration (val) {\n  return typeof val === 'number' && !isNaN(val)\n}\n\n/**\n * Normalize a transition hook's argument length. The hook may be:\n * - a merged hook (invoker) with the original in .fns\n * - a wrapped component method (check ._length)\n * - a plain function (.length)\n */\nfunction getHookArgumentsLength (fn) {\n  if (isUndef(fn)) {\n    return false\n  }\n  var invokerFns = fn.fns;\n  if (isDef(invokerFns)) {\n    // invoker\n    return getHookArgumentsLength(\n      Array.isArray(invokerFns)\n        ? invokerFns[0]\n        : invokerFns\n    )\n  } else {\n    return (fn._length || fn.length) > 1\n  }\n}\n\nfunction _enter (_, vnode) {\n  if (vnode.data.show !== true) {\n    enter(vnode);\n  }\n}\n\nvar transition = inBrowser ? {\n  create: _enter,\n  activate: _enter,\n  remove: function remove$$1 (vnode, rm) {\n    /* istanbul ignore else */\n    if (vnode.data.show !== true) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model$1 = {\n  inserted: function inserted (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n      el._vOptions = [].map.call(el.options, getValue);\n    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n      el._vModifiers = binding.modifiers;\n      if (!binding.modifiers.lazy) {\n        // Safari < 10.2 & UIWebView doesn't fire compositionend when\n        // switching focus before confirming composition choice\n        // this also fixes the issue where some browsers e.g. iOS Chrome\n        // fires \"change\" instead of \"input\" on autocomplete.\n        el.addEventListener('change', onCompositionEnd);\n        if (!isAndroid) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n        }\n        /* istanbul ignore if */\n        if (isIE9) {\n          el.vmodel = true;\n        }\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var prevOptions = el._vOptions;\n      var curOptions = el._vOptions = [].map.call(el.options, getValue);\n      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  // prevent triggering an input event for no reason\n  if (!e.target.composing) { return }\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.componentInstance._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    var originalDisplay = el.__vOriginalDisplay =\n      el.style.display === 'none' ? '' : el.style.display;\n    if (value && transition$$1) {\n      vnode.data.show = true;\n      enter(vnode, function () {\n        el.style.display = originalDisplay;\n      });\n    } else {\n      el.style.display = value ? originalDisplay : 'none';\n    }\n  },\n\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition$$1 = vnode.data && vnode.data.transition;\n    if (transition$$1) {\n      vnode.data.show = true;\n      if (value) {\n        enter(vnode, function () {\n          el.style.display = el.__vOriginalDisplay;\n        });\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  },\n\n  unbind: function unbind (\n    el,\n    binding,\n    vnode,\n    oldVnode,\n    isDestroy\n  ) {\n    if (!isDestroy) {\n      el.style.display = el.__vOriginalDisplay;\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model$1,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterToClass: String,\n  leaveToClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  duration: [Number, String, Object]\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1];\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  if (/\\d-keep-alive$/.test(rawChild.tag)) {\n    return h('keep-alive', {\n      props: rawChild.componentOptions.propsData\n    })\n  }\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nfunction isSameChild (child, oldChild) {\n  return oldChild.key === child.key && oldChild.tag === child.tag\n}\n\nfunction isAsyncPlaceholder (node) {\n  return node.isComment && node.asyncFactory\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$options._renderChildren;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag || isAsyncPlaceholder(c); });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n      mode && mode !== 'in-out' && mode !== 'out-in'\n    ) {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    // ensure a key that is unique to the vnode type and to this transition\n    // component instance. This key will be used to remove pending leaving nodes\n    // during entering.\n    var id = \"__transition-\" + (this._uid) + \"-\";\n    child.key = child.key == null\n      ? child.isComment\n        ? id + 'comment'\n        : id + child.tag\n      : isPrimitive(child.key)\n        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n        : child.key;\n\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (\n      oldChild &&\n      oldChild.data &&\n      !isSameChild(child, oldChild) &&\n      !isAsyncPlaceholder(oldChild)\n    ) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild && (oldChild.data.transition = extend({}, data));\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        });\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        if (isAsyncPlaceholder(child)) {\n          return oldRawChild\n        }\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave);\n        mergeVNodeHook(data, 'enterCancelled', performLeave);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final desired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var body = document.body;\n    var f = body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      /* istanbul ignore if */\n      if (this._hasMove) {\n        return this._hasMove\n      }\n      // Detect whether an element with the move class applied has\n      // CSS transitions. Since the element may be inside an entering\n      // transition at this very moment, we make a clone of it and remove\n      // all other transition classes applied to ensure only the move class\n      // is applied.\n      var clone = el.cloneNode();\n      if (el._transitionClasses) {\n        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n      }\n      addClass(clone, moveClass);\n      clone.style.display = 'none';\n      this.$el.appendChild(clone);\n      var info = getTransitionInfo(clone);\n      this.$el.removeChild(clone);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$3.config.mustUseProp = mustUseProp;\nVue$3.config.isReservedTag = isReservedTag;\nVue$3.config.isReservedAttr = isReservedAttr;\nVue$3.config.getTagNamespace = getTagNamespace;\nVue$3.config.isUnknownElement = isUnknownElement;\n\n// install platform runtime directives & components\nextend(Vue$3.options.directives, platformDirectives);\nextend(Vue$3.options.components, platformComponents);\n\n// install platform patch function\nVue$3.prototype.__patch__ = inBrowser ? patch : noop;\n\n// public mount method\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && inBrowser ? query(el) : undefined;\n  return mountComponent(this, el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$3);\n    } else if (process.env.NODE_ENV !== 'production' && isChrome) {\n      console[console.info ? 'info' : 'log'](\n        'Download the Vue Devtools extension for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n  if (process.env.NODE_ENV !== 'production' &&\n    config.productionTip !== false &&\n    inBrowser && typeof console !== 'undefined'\n  ) {\n    console[console.info ? 'info' : 'log'](\n      \"You are running Vue in development mode.\\n\" +\n      \"Make sure to turn on production mode when deploying for production.\\n\" +\n      \"See more tips at https://vuejs.org/guide/deployment.html\"\n    );\n  }\n}, 0);\n\n/*  */\n\n// check whether current browser encodes a char inside attribute values\nfunction shouldDecode (content, encoded) {\n  var div = document.createElement('div');\n  div.innerHTML = \"<div a=\\\"\" + content + \"\\\"/>\";\n  return div.innerHTML.indexOf(encoded) > 0\n}\n\n// #3663\n// IE encodes newlines inside attribute values while other browsers don't\nvar shouldDecodeNewlines = inBrowser ? shouldDecode('\\n', '&#10;') : false;\n\n/*  */\n\nvar defaultTagRE = /\\{\\{((?:.|\\n)+?)\\}\\}/g;\nvar regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\nvar buildRegex = cached(function (delimiters) {\n  var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n  var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n  return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n});\n\nfunction parseText (\n  text,\n  delimiters\n) {\n  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n  if (!tagRE.test(text)) {\n    return\n  }\n  var tokens = [];\n  var lastIndex = tagRE.lastIndex = 0;\n  var match, index;\n  while ((match = tagRE.exec(text))) {\n    index = match.index;\n    // push text token\n    if (index > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n    }\n    // tag token\n    var exp = parseFilters(match[1].trim());\n    tokens.push((\"_s(\" + exp + \")\"));\n    lastIndex = index + match[0].length;\n  }\n  if (lastIndex < text.length) {\n    tokens.push(JSON.stringify(text.slice(lastIndex)));\n  }\n  return tokens.join('+')\n}\n\n/*  */\n\nfunction transformNode (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticClass = getAndRemoveAttr(el, 'class');\n  if (process.env.NODE_ENV !== 'production' && staticClass) {\n    var expression = parseText(staticClass, options.delimiters);\n    if (expression) {\n      warn(\n        \"class=\\\"\" + staticClass + \"\\\": \" +\n        'Interpolation inside attributes has been removed. ' +\n        'Use v-bind or the colon shorthand instead. For example, ' +\n        'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.'\n      );\n    }\n  }\n  if (staticClass) {\n    el.staticClass = JSON.stringify(staticClass);\n  }\n  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n  if (classBinding) {\n    el.classBinding = classBinding;\n  }\n}\n\nfunction genData (el) {\n  var data = '';\n  if (el.staticClass) {\n    data += \"staticClass:\" + (el.staticClass) + \",\";\n  }\n  if (el.classBinding) {\n    data += \"class:\" + (el.classBinding) + \",\";\n  }\n  return data\n}\n\nvar klass$1 = {\n  staticKeys: ['staticClass'],\n  transformNode: transformNode,\n  genData: genData\n};\n\n/*  */\n\nfunction transformNode$1 (el, options) {\n  var warn = options.warn || baseWarn;\n  var staticStyle = getAndRemoveAttr(el, 'style');\n  if (staticStyle) {\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      var expression = parseText(staticStyle, options.delimiters);\n      if (expression) {\n        warn(\n          \"style=\\\"\" + staticStyle + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.'\n        );\n      }\n    }\n    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n  }\n\n  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n  if (styleBinding) {\n    el.styleBinding = styleBinding;\n  }\n}\n\nfunction genData$1 (el) {\n  var data = '';\n  if (el.staticStyle) {\n    data += \"staticStyle:\" + (el.staticStyle) + \",\";\n  }\n  if (el.styleBinding) {\n    data += \"style:(\" + (el.styleBinding) + \"),\";\n  }\n  return data\n}\n\nvar style$1 = {\n  staticKeys: ['staticStyle'],\n  transformNode: transformNode$1,\n  genData: genData$1\n};\n\nvar modules$1 = [\n  klass$1,\n  style$1\n];\n\n/*  */\n\nfunction text (el, dir) {\n  if (dir.value) {\n    addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\n/*  */\n\nfunction html (el, dir) {\n  if (dir.value) {\n    addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"));\n  }\n}\n\nvar directives$1 = {\n  model: model,\n  text: text,\n  html: html\n};\n\n/*  */\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr'\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track'\n);\n\n/*  */\n\nvar baseOptions = {\n  expectHTML: true,\n  modules: modules$1,\n  directives: directives$1,\n  isPreTag: isPreTag,\n  isUnaryTag: isUnaryTag,\n  mustUseProp: mustUseProp,\n  canBeLeftOpenTag: canBeLeftOpenTag,\n  isReservedTag: isReservedTag,\n  getTagNamespace: getTagNamespace,\n  staticKeys: genStaticKeys(modules$1)\n};\n\n/*  */\n\nvar decoder;\n\nvar he = {\n  decode: function decode (html) {\n    decoder = decoder || document.createElement('div');\n    decoder.innerHTML = html;\n    return decoder.textContent\n  }\n};\n\n/**\n * Not type-checking this file because it's mostly vendor code.\n */\n\n/*!\n * HTML Parser By John Resig (ejohn.org)\n * Modified by Juriy \"kangax\" Zaytsev\n * Original code by Erik Arvidsson, Mozilla Public License\n * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js\n */\n\n// Regular Expressions for parsing tags and attributes\nvar singleAttrIdentifier = /([^\\s\"'<>/=]+)/;\nvar singleAttrAssign = /(?:=)/;\nvar singleAttrValues = [\n  // attr value double quotes\n  /\"([^\"]*)\"+/.source,\n  // attr value, single quotes\n  /'([^']*)'+/.source,\n  // attr value, no quotes\n  /([^\\s\"'=<>`]+)/.source\n];\nvar attribute = new RegExp(\n  '^\\\\s*' + singleAttrIdentifier.source +\n  '(?:\\\\s*(' + singleAttrAssign.source + ')' +\n  '\\\\s*(?:' + singleAttrValues.join('|') + '))?'\n);\n\n// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName\n// but for Vue templates we can enforce a simple charset\nvar ncname = '[a-zA-Z_][\\\\w\\\\-\\\\.]*';\nvar qnameCapture = '((?:' + ncname + '\\\\:)?' + ncname + ')';\nvar startTagOpen = new RegExp('^<' + qnameCapture);\nvar startTagClose = /^\\s*(\\/?)>/;\nvar endTag = new RegExp('^<\\\\/' + qnameCapture + '[^>]*>');\nvar doctype = /^<!DOCTYPE [^>]+>/i;\nvar comment = /^<!--/;\nvar conditionalComment = /^<!\\[/;\n\nvar IS_REGEX_CAPTURING_BROKEN = false;\n'x'.replace(/x(.)?/g, function (m, g) {\n  IS_REGEX_CAPTURING_BROKEN = g === '';\n});\n\n// Special Elements (can contain anything)\nvar isPlainTextElement = makeMap('script,style,textarea', true);\nvar reCache = {};\n\nvar decodingMap = {\n  '&lt;': '<',\n  '&gt;': '>',\n  '&quot;': '\"',\n  '&amp;': '&',\n  '&#10;': '\\n'\n};\nvar encodedAttr = /&(?:lt|gt|quot|amp);/g;\nvar encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10);/g;\n\n// #5992\nvar isIgnoreNewlineTag = makeMap('pre,textarea', true);\nvar shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\nfunction decodeAttr (value, shouldDecodeNewlines) {\n  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n  return value.replace(re, function (match) { return decodingMap[match]; })\n}\n\nfunction parseHTML (html, options) {\n  var stack = [];\n  var expectHTML = options.expectHTML;\n  var isUnaryTag$$1 = options.isUnaryTag || no;\n  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n  var index = 0;\n  var last, lastTag;\n  while (html) {\n    last = html;\n    // Make sure we're not in a plaintext content element like script/style\n    if (!lastTag || !isPlainTextElement(lastTag)) {\n      var textEnd = html.indexOf('<');\n      if (textEnd === 0) {\n        // Comment:\n        if (comment.test(html)) {\n          var commentEnd = html.indexOf('-->');\n\n          if (commentEnd >= 0) {\n            if (options.shouldKeepComment) {\n              options.comment(html.substring(4, commentEnd));\n            }\n            advance(commentEnd + 3);\n            continue\n          }\n        }\n\n        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n        if (conditionalComment.test(html)) {\n          var conditionalEnd = html.indexOf(']>');\n\n          if (conditionalEnd >= 0) {\n            advance(conditionalEnd + 2);\n            continue\n          }\n        }\n\n        // Doctype:\n        var doctypeMatch = html.match(doctype);\n        if (doctypeMatch) {\n          advance(doctypeMatch[0].length);\n          continue\n        }\n\n        // End tag:\n        var endTagMatch = html.match(endTag);\n        if (endTagMatch) {\n          var curIndex = index;\n          advance(endTagMatch[0].length);\n          parseEndTag(endTagMatch[1], curIndex, index);\n          continue\n        }\n\n        // Start tag:\n        var startTagMatch = parseStartTag();\n        if (startTagMatch) {\n          handleStartTag(startTagMatch);\n          if (shouldIgnoreFirstNewline(lastTag, html)) {\n            advance(1);\n          }\n          continue\n        }\n      }\n\n      var text = (void 0), rest = (void 0), next = (void 0);\n      if (textEnd >= 0) {\n        rest = html.slice(textEnd);\n        while (\n          !endTag.test(rest) &&\n          !startTagOpen.test(rest) &&\n          !comment.test(rest) &&\n          !conditionalComment.test(rest)\n        ) {\n          // < in plain text, be forgiving and treat it as text\n          next = rest.indexOf('<', 1);\n          if (next < 0) { break }\n          textEnd += next;\n          rest = html.slice(textEnd);\n        }\n        text = html.substring(0, textEnd);\n        advance(textEnd);\n      }\n\n      if (textEnd < 0) {\n        text = html;\n        html = '';\n      }\n\n      if (options.chars && text) {\n        options.chars(text);\n      }\n    } else {\n      var endTagLength = 0;\n      var stackedTag = lastTag.toLowerCase();\n      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n        endTagLength = endTag.length;\n        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n          text = text\n            .replace(/<!--([\\s\\S]*?)-->/g, '$1')\n            .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n        }\n        if (shouldIgnoreFirstNewline(stackedTag, text)) {\n          text = text.slice(1);\n        }\n        if (options.chars) {\n          options.chars(text);\n        }\n        return ''\n      });\n      index += html.length - rest$1.length;\n      html = rest$1;\n      parseEndTag(stackedTag, index - endTagLength, index);\n    }\n\n    if (html === last) {\n      options.chars && options.chars(html);\n      if (process.env.NODE_ENV !== 'production' && !stack.length && options.warn) {\n        options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"));\n      }\n      break\n    }\n  }\n\n  // Clean up any remaining tags\n  parseEndTag();\n\n  function advance (n) {\n    index += n;\n    html = html.substring(n);\n  }\n\n  function parseStartTag () {\n    var start = html.match(startTagOpen);\n    if (start) {\n      var match = {\n        tagName: start[1],\n        attrs: [],\n        start: index\n      };\n      advance(start[0].length);\n      var end, attr;\n      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {\n        advance(attr[0].length);\n        match.attrs.push(attr);\n      }\n      if (end) {\n        match.unarySlash = end[1];\n        advance(end[0].length);\n        match.end = index;\n        return match\n      }\n    }\n  }\n\n  function handleStartTag (match) {\n    var tagName = match.tagName;\n    var unarySlash = match.unarySlash;\n\n    if (expectHTML) {\n      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n        parseEndTag(lastTag);\n      }\n      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n        parseEndTag(tagName);\n      }\n    }\n\n    var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n    var l = match.attrs.length;\n    var attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      var args = match.attrs[i];\n      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778\n      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('\"\"') === -1) {\n        if (args[3] === '') { delete args[3]; }\n        if (args[4] === '') { delete args[4]; }\n        if (args[5] === '') { delete args[5]; }\n      }\n      var value = args[3] || args[4] || args[5] || '';\n      attrs[i] = {\n        name: args[1],\n        value: decodeAttr(\n          value,\n          options.shouldDecodeNewlines\n        )\n      };\n    }\n\n    if (!unary) {\n      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });\n      lastTag = tagName;\n    }\n\n    if (options.start) {\n      options.start(tagName, attrs, unary, match.start, match.end);\n    }\n  }\n\n  function parseEndTag (tagName, start, end) {\n    var pos, lowerCasedTagName;\n    if (start == null) { start = index; }\n    if (end == null) { end = index; }\n\n    if (tagName) {\n      lowerCasedTagName = tagName.toLowerCase();\n    }\n\n    // Find the closest opened tag of the same type\n    if (tagName) {\n      for (pos = stack.length - 1; pos >= 0; pos--) {\n        if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n          break\n        }\n      }\n    } else {\n      // If no tag name is provided, clean shop\n      pos = 0;\n    }\n\n    if (pos >= 0) {\n      // Close all the open elements, up the stack\n      for (var i = stack.length - 1; i >= pos; i--) {\n        if (process.env.NODE_ENV !== 'production' &&\n          (i > pos || !tagName) &&\n          options.warn\n        ) {\n          options.warn(\n            (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\")\n          );\n        }\n        if (options.end) {\n          options.end(stack[i].tag, start, end);\n        }\n      }\n\n      // Remove the open elements from the stack\n      stack.length = pos;\n      lastTag = pos && stack[pos - 1].tag;\n    } else if (lowerCasedTagName === 'br') {\n      if (options.start) {\n        options.start(tagName, [], true, start, end);\n      }\n    } else if (lowerCasedTagName === 'p') {\n      if (options.start) {\n        options.start(tagName, [], false, start, end);\n      }\n      if (options.end) {\n        options.end(tagName, start, end);\n      }\n    }\n  }\n}\n\n/*  */\n\nvar onRE = /^@|^v-on:/;\nvar dirRE = /^v-|^@|^:/;\nvar forAliasRE = /(.*?)\\s+(?:in|of)\\s+(.*)/;\nvar forIteratorRE = /\\((\\{[^}]*\\}|[^,]*),([^,]*)(?:,([^,]*))?\\)/;\n\nvar argRE = /:(.*)$/;\nvar bindRE = /^:|^v-bind:/;\nvar modifierRE = /\\.[^.]+/g;\n\nvar decodeHTMLCached = cached(he.decode);\n\n// configurable state\nvar warn$2;\nvar delimiters;\nvar transforms;\nvar preTransforms;\nvar postTransforms;\nvar platformIsPreTag;\nvar platformMustUseProp;\nvar platformGetTagNamespace;\n\n/**\n * Convert HTML string to AST.\n */\nfunction parse (\n  template,\n  options\n) {\n  warn$2 = options.warn || baseWarn;\n\n  platformIsPreTag = options.isPreTag || no;\n  platformMustUseProp = options.mustUseProp || no;\n  platformGetTagNamespace = options.getTagNamespace || no;\n\n  transforms = pluckModuleFunction(options.modules, 'transformNode');\n  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n  delimiters = options.delimiters;\n\n  var stack = [];\n  var preserveWhitespace = options.preserveWhitespace !== false;\n  var root;\n  var currentParent;\n  var inVPre = false;\n  var inPre = false;\n  var warned = false;\n\n  function warnOnce (msg) {\n    if (!warned) {\n      warned = true;\n      warn$2(msg);\n    }\n  }\n\n  function endPre (element) {\n    // check pre state\n    if (element.pre) {\n      inVPre = false;\n    }\n    if (platformIsPreTag(element.tag)) {\n      inPre = false;\n    }\n  }\n\n  parseHTML(template, {\n    warn: warn$2,\n    expectHTML: options.expectHTML,\n    isUnaryTag: options.isUnaryTag,\n    canBeLeftOpenTag: options.canBeLeftOpenTag,\n    shouldDecodeNewlines: options.shouldDecodeNewlines,\n    shouldKeepComment: options.comments,\n    start: function start (tag, attrs, unary) {\n      // check namespace.\n      // inherit parent ns if there is one\n      var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n      // handle IE svg bug\n      /* istanbul ignore if */\n      if (isIE && ns === 'svg') {\n        attrs = guardIESVGBug(attrs);\n      }\n\n      var element = {\n        type: 1,\n        tag: tag,\n        attrsList: attrs,\n        attrsMap: makeAttrsMap(attrs),\n        parent: currentParent,\n        children: []\n      };\n      if (ns) {\n        element.ns = ns;\n      }\n\n      if (isForbiddenTag(element) && !isServerRendering()) {\n        element.forbidden = true;\n        process.env.NODE_ENV !== 'production' && warn$2(\n          'Templates should only be responsible for mapping the state to the ' +\n          'UI. Avoid placing tags with side-effects in your templates, such as ' +\n          \"<\" + tag + \">\" + ', as they will not be parsed.'\n        );\n      }\n\n      // apply pre-transforms\n      for (var i = 0; i < preTransforms.length; i++) {\n        preTransforms[i](element, options);\n      }\n\n      if (!inVPre) {\n        processPre(element);\n        if (element.pre) {\n          inVPre = true;\n        }\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = true;\n      }\n      if (inVPre) {\n        processRawAttrs(element);\n      } else {\n        processFor(element);\n        processIf(element);\n        processOnce(element);\n        processKey(element);\n\n        // determine whether this is a plain element after\n        // removing structural attributes\n        element.plain = !element.key && !attrs.length;\n\n        processRef(element);\n        processSlot(element);\n        processComponent(element);\n        for (var i$1 = 0; i$1 < transforms.length; i$1++) {\n          transforms[i$1](element, options);\n        }\n        processAttrs(element);\n      }\n\n      function checkRootConstraints (el) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (el.tag === 'slot' || el.tag === 'template') {\n            warnOnce(\n              \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n              'contain multiple nodes.'\n            );\n          }\n          if (el.attrsMap.hasOwnProperty('v-for')) {\n            warnOnce(\n              'Cannot use v-for on stateful component root element because ' +\n              'it renders multiple elements.'\n            );\n          }\n        }\n      }\n\n      // tree management\n      if (!root) {\n        root = element;\n        checkRootConstraints(root);\n      } else if (!stack.length) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          checkRootConstraints(element);\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else if (process.env.NODE_ENV !== 'production') {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\"\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else if (element.slotScope) { // scoped slot\n          currentParent.plain = false;\n          var name = element.slotTarget || '\"default\"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n        } else {\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n      if (!unary) {\n        currentParent = element;\n        stack.push(element);\n      } else {\n        endPre(element);\n      }\n      // apply post-transforms\n      for (var i$2 = 0; i$2 < postTransforms.length; i$2++) {\n        postTransforms[i$2](element, options);\n      }\n    },\n\n    end: function end () {\n      // remove trailing whitespace\n      var element = stack[stack.length - 1];\n      var lastNode = element.children[element.children.length - 1];\n      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {\n        element.children.pop();\n      }\n      // pop stack\n      stack.length -= 1;\n      currentParent = stack[stack.length - 1];\n      endPre(element);\n    },\n\n    chars: function chars (text) {\n      if (!currentParent) {\n        if (process.env.NODE_ENV !== 'production') {\n          if (text === template) {\n            warnOnce(\n              'Component template requires a root element, rather than just text.'\n            );\n          } else if ((text = text.trim())) {\n            warnOnce(\n              (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\")\n            );\n          }\n        }\n        return\n      }\n      // IE textarea placeholder bug\n      /* istanbul ignore if */\n      if (isIE &&\n        currentParent.tag === 'textarea' &&\n        currentParent.attrsMap.placeholder === text\n      ) {\n        return\n      }\n      var children = currentParent.children;\n      text = inPre || text.trim()\n        ? isTextTag(currentParent) ? text : decodeHTMLCached(text)\n        // only preserve whitespace if its not right after a starting tag\n        : preserveWhitespace && children.length ? ' ' : '';\n      if (text) {\n        var expression;\n        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {\n          children.push({\n            type: 2,\n            expression: expression,\n            text: text\n          });\n        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n          children.push({\n            type: 3,\n            text: text\n          });\n        }\n      }\n    },\n    comment: function comment (text) {\n      currentParent.children.push({\n        type: 3,\n        text: text,\n        isComment: true\n      });\n    }\n  });\n  return root\n}\n\nfunction processPre (el) {\n  if (getAndRemoveAttr(el, 'v-pre') != null) {\n    el.pre = true;\n  }\n}\n\nfunction processRawAttrs (el) {\n  var l = el.attrsList.length;\n  if (l) {\n    var attrs = el.attrs = new Array(l);\n    for (var i = 0; i < l; i++) {\n      attrs[i] = {\n        name: el.attrsList[i].name,\n        value: JSON.stringify(el.attrsList[i].value)\n      };\n    }\n  } else if (!el.pre) {\n    // non root node in pre blocks with no attributes\n    el.plain = true;\n  }\n}\n\nfunction processKey (el) {\n  var exp = getBindingAttr(el, 'key');\n  if (exp) {\n    if (process.env.NODE_ENV !== 'production' && el.tag === 'template') {\n      warn$2(\"<template> cannot be keyed. Place the key on real elements instead.\");\n    }\n    el.key = exp;\n  }\n}\n\nfunction processRef (el) {\n  var ref = getBindingAttr(el, 'ref');\n  if (ref) {\n    el.ref = ref;\n    el.refInFor = checkInFor(el);\n  }\n}\n\nfunction processFor (el) {\n  var exp;\n  if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) {\n      process.env.NODE_ENV !== 'production' && warn$2(\n        (\"Invalid v-for expression: \" + exp)\n      );\n      return\n    }\n    el.for = inMatch[2].trim();\n    var alias = inMatch[1].trim();\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      el.alias = iteratorMatch[1].trim();\n      el.iterator1 = iteratorMatch[2].trim();\n      if (iteratorMatch[3]) {\n        el.iterator2 = iteratorMatch[3].trim();\n      }\n    } else {\n      el.alias = alias;\n    }\n  }\n}\n\nfunction processIf (el) {\n  var exp = getAndRemoveAttr(el, 'v-if');\n  if (exp) {\n    el.if = exp;\n    addIfCondition(el, {\n      exp: exp,\n      block: el\n    });\n  } else {\n    if (getAndRemoveAttr(el, 'v-else') != null) {\n      el.else = true;\n    }\n    var elseif = getAndRemoveAttr(el, 'v-else-if');\n    if (elseif) {\n      el.elseif = elseif;\n    }\n  }\n}\n\nfunction processIfConditions (el, parent) {\n  var prev = findPrevElement(parent.children);\n  if (prev && prev.if) {\n    addIfCondition(prev, {\n      exp: el.elseif,\n      block: el\n    });\n  } else if (process.env.NODE_ENV !== 'production') {\n    warn$2(\n      \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n      \"used on element <\" + (el.tag) + \"> without corresponding v-if.\"\n    );\n  }\n}\n\nfunction findPrevElement (children) {\n  var i = children.length;\n  while (i--) {\n    if (children[i].type === 1) {\n      return children[i]\n    } else {\n      if (process.env.NODE_ENV !== 'production' && children[i].text !== ' ') {\n        warn$2(\n          \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n          \"will be ignored.\"\n        );\n      }\n      children.pop();\n    }\n  }\n}\n\nfunction addIfCondition (el, condition) {\n  if (!el.ifConditions) {\n    el.ifConditions = [];\n  }\n  el.ifConditions.push(condition);\n}\n\nfunction processOnce (el) {\n  var once$$1 = getAndRemoveAttr(el, 'v-once');\n  if (once$$1 != null) {\n    el.once = true;\n  }\n}\n\nfunction processSlot (el) {\n  if (el.tag === 'slot') {\n    el.slotName = getBindingAttr(el, 'name');\n    if (process.env.NODE_ENV !== 'production' && el.key) {\n      warn$2(\n        \"`key` does not work on <slot> because slots are abstract outlets \" +\n        \"and can possibly expand into multiple elements. \" +\n        \"Use the key on a wrapping element instead.\"\n      );\n    }\n  } else {\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n    }\n    if (el.tag === 'template') {\n      el.slotScope = getAndRemoveAttr(el, 'scope');\n    }\n  }\n}\n\nfunction processComponent (el) {\n  var binding;\n  if ((binding = getBindingAttr(el, 'is'))) {\n    el.component = binding;\n  }\n  if (getAndRemoveAttr(el, 'inline-template') != null) {\n    el.inlineTemplate = true;\n  }\n}\n\nfunction processAttrs (el) {\n  var list = el.attrsList;\n  var i, l, name, rawName, value, modifiers, isProp;\n  for (i = 0, l = list.length; i < l; i++) {\n    name = rawName = list[i].name;\n    value = list[i].value;\n    if (dirRE.test(name)) {\n      // mark element as dynamic\n      el.hasBindings = true;\n      // modifiers\n      modifiers = parseModifiers(name);\n      if (modifiers) {\n        name = name.replace(modifierRE, '');\n      }\n      if (bindRE.test(name)) { // v-bind\n        name = name.replace(bindRE, '');\n        value = parseFilters(value);\n        isProp = false;\n        if (modifiers) {\n          if (modifiers.prop) {\n            isProp = true;\n            name = camelize(name);\n            if (name === 'innerHtml') { name = 'innerHTML'; }\n          }\n          if (modifiers.camel) {\n            name = camelize(name);\n          }\n          if (modifiers.sync) {\n            addHandler(\n              el,\n              (\"update:\" + (camelize(name))),\n              genAssignmentCode(value, \"$event\")\n            );\n          }\n        }\n        if (isProp || (\n          !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n        )) {\n          addProp(el, name, value);\n        } else {\n          addAttr(el, name, value);\n        }\n      } else if (onRE.test(name)) { // v-on\n        name = name.replace(onRE, '');\n        addHandler(el, name, value, modifiers, false, warn$2);\n      } else { // normal directives\n        name = name.replace(dirRE, '');\n        // parse arg\n        var argMatch = name.match(argRE);\n        var arg = argMatch && argMatch[1];\n        if (arg) {\n          name = name.slice(0, -(arg.length + 1));\n        }\n        addDirective(el, name, rawName, value, arg, modifiers);\n        if (process.env.NODE_ENV !== 'production' && name === 'model') {\n          checkForAliasModel(el, value);\n        }\n      }\n    } else {\n      // literal attribute\n      if (process.env.NODE_ENV !== 'production') {\n        var expression = parseText(value, delimiters);\n        if (expression) {\n          warn$2(\n            name + \"=\\\"\" + value + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.'\n          );\n        }\n      }\n      addAttr(el, name, JSON.stringify(value));\n    }\n  }\n}\n\nfunction checkInFor (el) {\n  var parent = el;\n  while (parent) {\n    if (parent.for !== undefined) {\n      return true\n    }\n    parent = parent.parent;\n  }\n  return false\n}\n\nfunction parseModifiers (name) {\n  var match = name.match(modifierRE);\n  if (match) {\n    var ret = {};\n    match.forEach(function (m) { ret[m.slice(1)] = true; });\n    return ret\n  }\n}\n\nfunction makeAttrsMap (attrs) {\n  var map = {};\n  for (var i = 0, l = attrs.length; i < l; i++) {\n    if (\n      process.env.NODE_ENV !== 'production' &&\n      map[attrs[i].name] && !isIE && !isEdge\n    ) {\n      warn$2('duplicate attribute: ' + attrs[i].name);\n    }\n    map[attrs[i].name] = attrs[i].value;\n  }\n  return map\n}\n\n// for script (e.g. type=\"x/template\") or style, do not decode content\nfunction isTextTag (el) {\n  return el.tag === 'script' || el.tag === 'style'\n}\n\nfunction isForbiddenTag (el) {\n  return (\n    el.tag === 'style' ||\n    (el.tag === 'script' && (\n      !el.attrsMap.type ||\n      el.attrsMap.type === 'text/javascript'\n    ))\n  )\n}\n\nvar ieNSBug = /^xmlns:NS\\d+/;\nvar ieNSPrefix = /^NS\\d+:/;\n\n/* istanbul ignore next */\nfunction guardIESVGBug (attrs) {\n  var res = [];\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!ieNSBug.test(attr.name)) {\n      attr.name = attr.name.replace(ieNSPrefix, '');\n      res.push(attr);\n    }\n  }\n  return res\n}\n\nfunction checkForAliasModel (el, value) {\n  var _el = el;\n  while (_el) {\n    if (_el.for && _el.alias === value) {\n      warn$2(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"You are binding v-model directly to a v-for iteration alias. \" +\n        \"This will not be able to modify the v-for source array because \" +\n        \"writing to the alias is like modifying a function local variable. \" +\n        \"Consider using an array of objects and use v-model on an object property instead.\"\n      );\n    }\n    _el = _el.parent;\n  }\n}\n\n/*  */\n\nvar isStaticKey;\nvar isPlatformReservedTag;\n\nvar genStaticKeysCached = cached(genStaticKeys$1);\n\n/**\n * Goal of the optimizer: walk the generated template AST tree\n * and detect sub-trees that are purely static, i.e. parts of\n * the DOM that never needs to change.\n *\n * Once we detect these sub-trees, we can:\n *\n * 1. Hoist them into constants, so that we no longer need to\n *    create fresh nodes for them on each re-render;\n * 2. Completely skip them in the patching process.\n */\nfunction optimize (root, options) {\n  if (!root) { return }\n  isStaticKey = genStaticKeysCached(options.staticKeys || '');\n  isPlatformReservedTag = options.isReservedTag || no;\n  // first pass: mark all non-static nodes.\n  markStatic$1(root);\n  // second pass: mark static roots.\n  markStaticRoots(root, false);\n}\n\nfunction genStaticKeys$1 (keys) {\n  return makeMap(\n    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +\n    (keys ? ',' + keys : '')\n  )\n}\n\nfunction markStatic$1 (node) {\n  node.static = isStatic(node);\n  if (node.type === 1) {\n    // do not make component slot content static. this avoids\n    // 1. components not able to mutate slot nodes\n    // 2. static slot content fails for hot-reloading\n    if (\n      !isPlatformReservedTag(node.tag) &&\n      node.tag !== 'slot' &&\n      node.attrsMap['inline-template'] == null\n    ) {\n      return\n    }\n    for (var i = 0, l = node.children.length; i < l; i++) {\n      var child = node.children[i];\n      markStatic$1(child);\n      if (!child.static) {\n        node.static = false;\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        var block = node.ifConditions[i$1].block;\n        markStatic$1(block);\n        if (!block.static) {\n          node.static = false;\n        }\n      }\n    }\n  }\n}\n\nfunction markStaticRoots (node, isInFor) {\n  if (node.type === 1) {\n    if (node.static || node.once) {\n      node.staticInFor = isInFor;\n    }\n    // For a node to qualify as a static root, it should have children that\n    // are not just static text. Otherwise the cost of hoisting out will\n    // outweigh the benefits and it's better off to just always render it fresh.\n    if (node.static && node.children.length && !(\n      node.children.length === 1 &&\n      node.children[0].type === 3\n    )) {\n      node.staticRoot = true;\n      return\n    } else {\n      node.staticRoot = false;\n    }\n    if (node.children) {\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        markStaticRoots(node.children[i], isInFor || !!node.for);\n      }\n    }\n    if (node.ifConditions) {\n      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n        markStaticRoots(node.ifConditions[i$1].block, isInFor);\n      }\n    }\n  }\n}\n\nfunction isStatic (node) {\n  if (node.type === 2) { // expression\n    return false\n  }\n  if (node.type === 3) { // text\n    return true\n  }\n  return !!(node.pre || (\n    !node.hasBindings && // no dynamic bindings\n    !node.if && !node.for && // not v-if or v-for or v-else\n    !isBuiltInTag(node.tag) && // not a built-in\n    isPlatformReservedTag(node.tag) && // not a component\n    !isDirectChildOfTemplateFor(node) &&\n    Object.keys(node).every(isStaticKey)\n  ))\n}\n\nfunction isDirectChildOfTemplateFor (node) {\n  while (node.parent) {\n    node = node.parent;\n    if (node.tag !== 'template') {\n      return false\n    }\n    if (node.for) {\n      return true\n    }\n  }\n  return false\n}\n\n/*  */\n\nvar fnExpRE = /^\\s*([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*\\(/;\nvar simplePathRE = /^\\s*[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['.*?']|\\[\".*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*\\s*$/;\n\n// keyCode aliases\nvar keyCodes = {\n  esc: 27,\n  tab: 9,\n  enter: 13,\n  space: 32,\n  up: 38,\n  left: 37,\n  right: 39,\n  down: 40,\n  'delete': [8, 46]\n};\n\n// #4868: modifiers that prevent the execution of the listener\n// need to explicitly return null so that we can determine whether to remove\n// the listener for .once\nvar genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\nvar modifierCode = {\n  stop: '$event.stopPropagation();',\n  prevent: '$event.preventDefault();',\n  self: genGuard(\"$event.target !== $event.currentTarget\"),\n  ctrl: genGuard(\"!$event.ctrlKey\"),\n  shift: genGuard(\"!$event.shiftKey\"),\n  alt: genGuard(\"!$event.altKey\"),\n  meta: genGuard(\"!$event.metaKey\"),\n  left: genGuard(\"'button' in $event && $event.button !== 0\"),\n  middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n  right: genGuard(\"'button' in $event && $event.button !== 2\")\n};\n\nfunction genHandlers (\n  events,\n  isNative,\n  warn\n) {\n  var res = isNative ? 'nativeOn:{' : 'on:{';\n  for (var name in events) {\n    var handler = events[name];\n    // #5330: warn click.right, since right clicks do not actually fire click events.\n    if (process.env.NODE_ENV !== 'production' &&\n      name === 'click' &&\n      handler && handler.modifiers && handler.modifiers.right\n    ) {\n      warn(\n        \"Use \\\"contextmenu\\\" instead of \\\"click.right\\\" since right clicks \" +\n        \"do not actually fire \\\"click\\\" events.\"\n      );\n    }\n    res += \"\\\"\" + name + \"\\\":\" + (genHandler(name, handler)) + \",\";\n  }\n  return res.slice(0, -1) + '}'\n}\n\nfunction genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return 'function(){}'\n  }\n\n  if (Array.isArray(handler)) {\n    return (\"[\" + (handler.map(function (handler) { return genHandler(name, handler); }).join(',')) + \"]\")\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\n      ? handler.value\n      : (\"function($event){\" + (handler.value) + \"}\") // inline statement\n  } else {\n    var code = '';\n    var genModifierCode = '';\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode += modifierCode[key];\n        // left/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code += genKeyFilter(keys);\n    }\n    // Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code += genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value + '($event)'\n      : isFunctionExpression\n        ? (\"(\" + (handler.value) + \")($event)\")\n        : handler.value;\n    return (\"function($event){\" + code + handlerCode + \"}\")\n  }\n}\n\nfunction genKeyFilter (keys) {\n  return (\"if(!('button' in $event)&&\" + (keys.map(genFilterCode).join('&&')) + \")return null;\")\n}\n\nfunction genFilterCode (key) {\n  var keyVal = parseInt(key, 10);\n  if (keyVal) {\n    return (\"$event.keyCode!==\" + keyVal)\n  }\n  var alias = keyCodes[key];\n  return (\"_k($event.keyCode,\" + (JSON.stringify(key)) + (alias ? ',' + JSON.stringify(alias) : '') + \")\")\n}\n\n/*  */\n\nfunction on (el, dir) {\n  if (process.env.NODE_ENV !== 'production' && dir.modifiers) {\n    warn(\"v-on without argument does not support modifiers.\");\n  }\n  el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n}\n\n/*  */\n\nfunction bind$1 (el, dir) {\n  el.wrapData = function (code) {\n    return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n  };\n}\n\n/*  */\n\nvar baseDirectives = {\n  on: on,\n  bind: bind$1,\n  cloak: noop\n};\n\n/*  */\n\nvar CodegenState = function CodegenState (options) {\n  this.options = options;\n  this.warn = options.warn || baseWarn;\n  this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n  this.directives = extend(extend({}, baseDirectives), options.directives);\n  var isReservedTag = options.isReservedTag || no;\n  this.maybeComponent = function (el) { return !isReservedTag(el.tag); };\n  this.onceId = 0;\n  this.staticRenderFns = [];\n};\n\n\n\nfunction generate (\n  ast,\n  options\n) {\n  var state = new CodegenState(options);\n  var code = ast ? genElement(ast, state) : '_c(\"div\")';\n  return {\n    render: (\"with(this){return \" + code + \"}\"),\n    staticRenderFns: state.staticRenderFns\n  }\n}\n\nfunction genElement (el, state) {\n  if (el.staticRoot && !el.staticProcessed) {\n    return genStatic(el, state)\n  } else if (el.once && !el.onceProcessed) {\n    return genOnce(el, state)\n  } else if (el.for && !el.forProcessed) {\n    return genFor(el, state)\n  } else if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.tag === 'template' && !el.slotTarget) {\n    return genChildren(el, state) || 'void 0'\n  } else if (el.tag === 'slot') {\n    return genSlot(el, state)\n  } else {\n    // component or element\n    var code;\n    if (el.component) {\n      code = genComponent(el.component, el, state);\n    } else {\n      var data = el.plain ? undefined : genData$2(el, state);\n\n      var children = el.inlineTemplate ? null : genChildren(el, state, true);\n      code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n    }\n    // module transforms\n    for (var i = 0; i < state.transforms.length; i++) {\n      code = state.transforms[i](el, code);\n    }\n    return code\n  }\n}\n\n// hoist static sub-trees out\nfunction genStatic (el, state) {\n  el.staticProcessed = true;\n  state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n  return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n}\n\n// v-once\nfunction genOnce (el, state) {\n  el.onceProcessed = true;\n  if (el.if && !el.ifProcessed) {\n    return genIf(el, state)\n  } else if (el.staticInFor) {\n    var key = '';\n    var parent = el.parent;\n    while (parent) {\n      if (parent.for) {\n        key = parent.key;\n        break\n      }\n      parent = parent.parent;\n    }\n    if (!key) {\n      process.env.NODE_ENV !== 'production' && state.warn(\n        \"v-once can only be used inside v-for that is keyed. \"\n      );\n      return genElement(el, state)\n    }\n    return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + (key ? (\",\" + key) : \"\") + \")\")\n  } else {\n    return genStatic(el, state)\n  }\n}\n\nfunction genIf (\n  el,\n  state,\n  altGen,\n  altEmpty\n) {\n  el.ifProcessed = true; // avoid recursion\n  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n}\n\nfunction genIfConditions (\n  conditions,\n  state,\n  altGen,\n  altEmpty\n) {\n  if (!conditions.length) {\n    return altEmpty || '_e()'\n  }\n\n  var condition = conditions.shift();\n  if (condition.exp) {\n    return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n  } else {\n    return (\"\" + (genTernaryExp(condition.block)))\n  }\n\n  // v-if with v-once should generate code like (a)?_m(0):_m(1)\n  function genTernaryExp (el) {\n    return altGen\n      ? altGen(el, state)\n      : el.once\n        ? genOnce(el, state)\n        : genElement(el, state)\n  }\n}\n\nfunction genFor (\n  el,\n  state,\n  altGen,\n  altHelper\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n  if (process.env.NODE_ENV !== 'production' &&\n    state.maybeComponent(el) &&\n    el.tag !== 'slot' &&\n    el.tag !== 'template' &&\n    !el.key\n  ) {\n    state.warn(\n      \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n      \"v-for should have explicit keys. \" +\n      \"See https://vuejs.org/guide/list.html#key for more info.\",\n      true /* tip */\n    );\n  }\n\n  el.forProcessed = true; // avoid recursion\n  return (altHelper || '_l') + \"((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + ((altGen || genElement)(el, state)) +\n    '})'\n}\n\nfunction genData$2 (el, state) {\n  var data = '{';\n\n  // directives first.\n  // directives may mutate the el's other properties before they are generated.\n  var dirs = genDirectives(el, state);\n  if (dirs) { data += dirs + ','; }\n\n  // key\n  if (el.key) {\n    data += \"key:\" + (el.key) + \",\";\n  }\n  // ref\n  if (el.ref) {\n    data += \"ref:\" + (el.ref) + \",\";\n  }\n  if (el.refInFor) {\n    data += \"refInFor:true,\";\n  }\n  // pre\n  if (el.pre) {\n    data += \"pre:true,\";\n  }\n  // record original tag name for components using \"is\" attribute\n  if (el.component) {\n    data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n  }\n  // module data generation functions\n  for (var i = 0; i < state.dataGenFns.length; i++) {\n    data += state.dataGenFns[i](el);\n  }\n  // attributes\n  if (el.attrs) {\n    data += \"attrs:{\" + (genProps(el.attrs)) + \"},\";\n  }\n  // DOM props\n  if (el.props) {\n    data += \"domProps:{\" + (genProps(el.props)) + \"},\";\n  }\n  // event handlers\n  if (el.events) {\n    data += (genHandlers(el.events, false, state.warn)) + \",\";\n  }\n  if (el.nativeEvents) {\n    data += (genHandlers(el.nativeEvents, true, state.warn)) + \",\";\n  }\n  // slot target\n  if (el.slotTarget) {\n    data += \"slot:\" + (el.slotTarget) + \",\";\n  }\n  // scoped slots\n  if (el.scopedSlots) {\n    data += (genScopedSlots(el.scopedSlots, state)) + \",\";\n  }\n  // component v-model\n  if (el.model) {\n    data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n  }\n  // inline-template\n  if (el.inlineTemplate) {\n    var inlineTemplate = genInlineTemplate(el, state);\n    if (inlineTemplate) {\n      data += inlineTemplate + \",\";\n    }\n  }\n  data = data.replace(/,$/, '') + '}';\n  // v-bind data wrap\n  if (el.wrapData) {\n    data = el.wrapData(data);\n  }\n  // v-on data wrap\n  if (el.wrapListeners) {\n    data = el.wrapListeners(data);\n  }\n  return data\n}\n\nfunction genDirectives (el, state) {\n  var dirs = el.directives;\n  if (!dirs) { return }\n  var res = 'directives:[';\n  var hasRuntime = false;\n  var i, l, dir, needRuntime;\n  for (i = 0, l = dirs.length; i < l; i++) {\n    dir = dirs[i];\n    needRuntime = true;\n    var gen = state.directives[dir.name];\n    if (gen) {\n      // compile-time directive that manipulates AST.\n      // returns true if it also needs a runtime counterpart.\n      needRuntime = !!gen(el, dir, state.warn);\n    }\n    if (needRuntime) {\n      hasRuntime = true;\n      res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\\\"\" + (dir.arg) + \"\\\"\") : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n    }\n  }\n  if (hasRuntime) {\n    return res.slice(0, -1) + ']'\n  }\n}\n\nfunction genInlineTemplate (el, state) {\n  var ast = el.children[0];\n  if (process.env.NODE_ENV !== 'production' && (\n    el.children.length > 1 || ast.type !== 1\n  )) {\n    state.warn('Inline-template components must have exactly one child element.');\n  }\n  if (ast.type === 1) {\n    var inlineRenderFns = generate(ast, state.options);\n    return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n  }\n}\n\nfunction genScopedSlots (\n  slots,\n  state\n) {\n  return (\"scopedSlots:_u([\" + (Object.keys(slots).map(function (key) {\n      return genScopedSlot(key, slots[key], state)\n    }).join(',')) + \"])\")\n}\n\nfunction genScopedSlot (\n  key,\n  el,\n  state\n) {\n  if (el.for && !el.forProcessed) {\n    return genForScopedSlot(key, el, state)\n  }\n  return \"{key:\" + key + \",fn:function(\" + (String(el.attrsMap.scope)) + \"){\" +\n    \"return \" + (el.tag === 'template'\n      ? genChildren(el, state) || 'void 0'\n      : genElement(el, state)) + \"}}\"\n}\n\nfunction genForScopedSlot (\n  key,\n  el,\n  state\n) {\n  var exp = el.for;\n  var alias = el.alias;\n  var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n  var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n  el.forProcessed = true; // avoid recursion\n  return \"_l((\" + exp + \"),\" +\n    \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n      \"return \" + (genScopedSlot(key, el, state)) +\n    '})'\n}\n\nfunction genChildren (\n  el,\n  state,\n  checkSkip,\n  altGenElement,\n  altGenNode\n) {\n  var children = el.children;\n  if (children.length) {\n    var el$1 = children[0];\n    // optimize single v-for\n    if (children.length === 1 &&\n      el$1.for &&\n      el$1.tag !== 'template' &&\n      el$1.tag !== 'slot'\n    ) {\n      return (altGenElement || genElement)(el$1, state)\n    }\n    var normalizationType = checkSkip\n      ? getNormalizationType(children, state.maybeComponent)\n      : 0;\n    var gen = altGenNode || genNode;\n    return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType ? (\",\" + normalizationType) : ''))\n  }\n}\n\n// determine the normalization needed for the children array.\n// 0: no normalization needed\n// 1: simple normalization needed (possible 1-level deep nested array)\n// 2: full normalization needed\nfunction getNormalizationType (\n  children,\n  maybeComponent\n) {\n  var res = 0;\n  for (var i = 0; i < children.length; i++) {\n    var el = children[i];\n    if (el.type !== 1) {\n      continue\n    }\n    if (needsNormalization(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n      res = 2;\n      break\n    }\n    if (maybeComponent(el) ||\n        (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n      res = 1;\n    }\n  }\n  return res\n}\n\nfunction needsNormalization (el) {\n  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n}\n\nfunction genNode (node, state) {\n  if (node.type === 1) {\n    return genElement(node, state)\n  } if (node.type === 3 && node.isComment) {\n    return genComment(node)\n  } else {\n    return genText(node)\n  }\n}\n\nfunction genText (text) {\n  return (\"_v(\" + (text.type === 2\n    ? text.expression // no need for () because already wrapped in _s()\n    : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n}\n\nfunction genComment (comment) {\n  return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n}\n\nfunction genSlot (el, state) {\n  var slotName = el.slotName || '\"default\"';\n  var children = genChildren(el, state);\n  var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n  var attrs = el.attrs && (\"{\" + (el.attrs.map(function (a) { return ((camelize(a.name)) + \":\" + (a.value)); }).join(',')) + \"}\");\n  var bind$$1 = el.attrsMap['v-bind'];\n  if ((attrs || bind$$1) && !children) {\n    res += \",null\";\n  }\n  if (attrs) {\n    res += \",\" + attrs;\n  }\n  if (bind$$1) {\n    res += (attrs ? '' : ',null') + \",\" + bind$$1;\n  }\n  return res + ')'\n}\n\n// componentName is el.component, take it as argument to shun flow's pessimistic refinement\nfunction genComponent (\n  componentName,\n  el,\n  state\n) {\n  var children = el.inlineTemplate ? null : genChildren(el, state, true);\n  return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n}\n\nfunction genProps (props) {\n  var res = '';\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    res += \"\\\"\" + (prop.name) + \"\\\":\" + (transformSpecialNewlines(prop.value)) + \",\";\n  }\n  return res.slice(0, -1)\n}\n\n// #3895, #4268\nfunction transformSpecialNewlines (text) {\n  return text\n    .replace(/\\u2028/g, '\\\\u2028')\n    .replace(/\\u2029/g, '\\\\u2029')\n}\n\n/*  */\n\n// these keywords should not appear inside expressions, but operators like\n// typeof, instanceof and in are allowed\nvar prohibitedKeywordRE = new RegExp('\\\\b' + (\n  'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n  'super,throw,while,yield,delete,export,import,return,switch,default,' +\n  'extends,finally,continue,debugger,function,arguments'\n).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n// these unary operators should not be used as property/method names\nvar unaryOperatorsRE = new RegExp('\\\\b' + (\n  'delete,typeof,void'\n).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n// check valid identifier for v-for\nvar identRE = /[A-Za-z_$][\\w$]*/;\n\n// strip strings in expressions\nvar stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n// detect problematic expressions in a template\nfunction detectErrors (ast) {\n  var errors = [];\n  if (ast) {\n    checkNode(ast, errors);\n  }\n  return errors\n}\n\nfunction checkNode (node, errors) {\n  if (node.type === 1) {\n    for (var name in node.attrsMap) {\n      if (dirRE.test(name)) {\n        var value = node.attrsMap[name];\n        if (value) {\n          if (name === 'v-for') {\n            checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), errors);\n          } else if (onRE.test(name)) {\n            checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          } else {\n            checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), errors);\n          }\n        }\n      }\n    }\n    if (node.children) {\n      for (var i = 0; i < node.children.length; i++) {\n        checkNode(node.children[i], errors);\n      }\n    }\n  } else if (node.type === 2) {\n    checkExpression(node.expression, node.text, errors);\n  }\n}\n\nfunction checkEvent (exp, text, errors) {\n  var stipped = exp.replace(stripStringRE, '');\n  var keywordMatch = stipped.match(unaryOperatorsRE);\n  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n    errors.push(\n      \"avoid using JavaScript unary operator as property name: \" +\n      \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n    );\n  }\n  checkExpression(exp, text, errors);\n}\n\nfunction checkFor (node, text, errors) {\n  checkExpression(node.for || '', text, errors);\n  checkIdentifier(node.alias, 'v-for alias', text, errors);\n  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);\n  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);\n}\n\nfunction checkIdentifier (ident, type, text, errors) {\n  if (typeof ident === 'string' && !identRE.test(ident)) {\n    errors.push((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())));\n  }\n}\n\nfunction checkExpression (exp, text, errors) {\n  try {\n    new Function((\"return \" + exp));\n  } catch (e) {\n    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n    if (keywordMatch) {\n      errors.push(\n        \"avoid using JavaScript keyword as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim())\n      );\n    } else {\n      errors.push((\"invalid expression: \" + (text.trim())));\n    }\n  }\n}\n\n/*  */\n\nfunction createFunction (code, errors) {\n  try {\n    return new Function(code)\n  } catch (err) {\n    errors.push({ err: err, code: code });\n    return noop\n  }\n}\n\nfunction createCompileToFunctionFn (compile) {\n  var cache = Object.create(null);\n\n  return function compileToFunctions (\n    template,\n    options,\n    vm\n  ) {\n    options = options || {};\n\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      // detect possible CSP restriction\n      try {\n        new Function('return 1');\n      } catch (e) {\n        if (e.toString().match(/unsafe-eval|CSP/)) {\n          warn(\n            'It seems you are using the standalone build of Vue.js in an ' +\n            'environment with Content Security Policy that prohibits unsafe-eval. ' +\n            'The template compiler cannot work in this environment. Consider ' +\n            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n            'templates into render functions.'\n          );\n        }\n      }\n    }\n\n    // check cache\n    var key = options.delimiters\n      ? String(options.delimiters) + template\n      : template;\n    if (cache[key]) {\n      return cache[key]\n    }\n\n    // compile\n    var compiled = compile(template, options);\n\n    // check compilation errors/tips\n    if (process.env.NODE_ENV !== 'production') {\n      if (compiled.errors && compiled.errors.length) {\n        warn(\n          \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n          compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n          vm\n        );\n      }\n      if (compiled.tips && compiled.tips.length) {\n        compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n      }\n    }\n\n    // turn code into functions\n    var res = {};\n    var fnGenErrors = [];\n    res.render = createFunction(compiled.render, fnGenErrors);\n    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n      return createFunction(code, fnGenErrors)\n    });\n\n    // check function generation errors.\n    // this should only happen if there is a bug in the compiler itself.\n    // mostly for codegen development use\n    /* istanbul ignore if */\n    if (process.env.NODE_ENV !== 'production') {\n      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n        warn(\n          \"Failed to generate render function:\\n\\n\" +\n          fnGenErrors.map(function (ref) {\n            var err = ref.err;\n            var code = ref.code;\n\n            return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n        }).join('\\n'),\n          vm\n        );\n      }\n    }\n\n    return (cache[key] = res)\n  }\n}\n\n/*  */\n\nfunction createCompilerCreator (baseCompile) {\n  return function createCompiler (baseOptions) {\n    function compile (\n      template,\n      options\n    ) {\n      var finalOptions = Object.create(baseOptions);\n      var errors = [];\n      var tips = [];\n      finalOptions.warn = function (msg, tip) {\n        (tip ? tips : errors).push(msg);\n      };\n\n      if (options) {\n        // merge custom modules\n        if (options.modules) {\n          finalOptions.modules =\n            (baseOptions.modules || []).concat(options.modules);\n        }\n        // merge custom directives\n        if (options.directives) {\n          finalOptions.directives = extend(\n            Object.create(baseOptions.directives),\n            options.directives\n          );\n        }\n        // copy other options\n        for (var key in options) {\n          if (key !== 'modules' && key !== 'directives') {\n            finalOptions[key] = options[key];\n          }\n        }\n      }\n\n      var compiled = baseCompile(template, finalOptions);\n      if (process.env.NODE_ENV !== 'production') {\n        errors.push.apply(errors, detectErrors(compiled.ast));\n      }\n      compiled.errors = errors;\n      compiled.tips = tips;\n      return compiled\n    }\n\n    return {\n      compile: compile,\n      compileToFunctions: createCompileToFunctionFn(compile)\n    }\n  }\n}\n\n/*  */\n\n// `createCompilerCreator` allows creating compilers that use alternative\n// parser/optimizer/codegen, e.g the SSR optimizing compiler.\n// Here we just export a default compiler using the default parts.\nvar createCompiler = createCompilerCreator(function baseCompile (\n  template,\n  options\n) {\n  var ast = parse(template.trim(), options);\n  optimize(ast, options);\n  var code = generate(ast, options);\n  return {\n    ast: ast,\n    render: code.render,\n    staticRenderFns: code.staticRenderFns\n  }\n});\n\n/*  */\n\nvar ref$1 = createCompiler(baseOptions);\nvar compileToFunctions = ref$1.compileToFunctions;\n\n/*  */\n\nvar idToTemplate = cached(function (id) {\n  var el = query(id);\n  return el && el.innerHTML\n});\n\nvar mount = Vue$3.prototype.$mount;\nVue$3.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && query(el);\n\n  /* istanbul ignore if */\n  if (el === document.body || el === document.documentElement) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n    );\n    return this\n  }\n\n  var options = this.$options;\n  // resolve template/el and convert to render function\n  if (!options.render) {\n    var template = options.template;\n    if (template) {\n      if (typeof template === 'string') {\n        if (template.charAt(0) === '#') {\n          template = idToTemplate(template);\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !template) {\n            warn(\n              (\"Template element not found or is empty: \" + (options.template)),\n              this\n            );\n          }\n        }\n      } else if (template.nodeType) {\n        template = template.innerHTML;\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          warn('invalid template option:' + template, this);\n        }\n        return this\n      }\n    } else if (el) {\n      template = getOuterHTML(el);\n    }\n    if (template) {\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile');\n      }\n\n      var ref = compileToFunctions(template, {\n        shouldDecodeNewlines: shouldDecodeNewlines,\n        delimiters: options.delimiters,\n        comments: options.comments\n      }, this);\n      var render = ref.render;\n      var staticRenderFns = ref.staticRenderFns;\n      options.render = render;\n      options.staticRenderFns = staticRenderFns;\n\n      /* istanbul ignore if */\n      if (process.env.NODE_ENV !== 'production' && config.performance && mark) {\n        mark('compile end');\n        measure(((this._name) + \" compile\"), 'compile', 'compile end');\n      }\n    }\n  }\n  return mount.call(this, el, hydrating)\n};\n\n/**\n * Get outerHTML of elements, taking care\n * of SVG elements in IE as well.\n */\nfunction getOuterHTML (el) {\n  if (el.outerHTML) {\n    return el.outerHTML\n  } else {\n    var container = document.createElement('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\nVue$3.compile = compileToFunctions;\n\nexport default Vue$3;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue/dist/vue.esm.js\n// module id = 1\n// module chunks = 0","<template>\n  <div id=\"app\">\n    <h1>{{ msg }}</h1>\n    <div v-for=\"note in notes\">\n      <a @click=\"makeSound(note.value)\" tabindex=\"note.id\">{{ note.text }}</a>\n    </div >\n  </div>\n</template>\n\n<script>\nimport Tone from 'tone'\n\nexport default {\n  name: 'main',\n  created () {\n    this.init()\n  },\n  data () {\n    return {\n      msg: 'Welcome to Shruti',\n      base_note: \"C#4\",\n      notes: [\n        {id: 0 , text: 'S',   value: {num: 1,   den: 1  }},\n        {id: 1 , text: 'r1',  value: {num: 256, den: 243}},\n        {id: 2 , text: 'r2',  value: {num: 16 , den: 15 }},\n        {id: 3 , text: 'R1',  value: {num: 10 , den: 9  }},\n        {id: 4 , text: 'R2',  value: {num: 9  , den: 8  }},\n        {id: 5 , text: 'g1',  value: {num: 32 , den: 27 }},\n        {id: 6 , text: 'g2',  value: {num: 6  , den: 5  }},\n        {id: 7 , text: 'G1',  value: {num: 5  , den: 4  }},\n        {id: 8 , text: 'G2',  value: {num: 81 , den: 64 }},\n        {id: 9 , text: 'M1',  value: {num: 4  , den: 3  }},\n        {id: 10, text: 'M2',  value: {num: 27 , den: 20 }},\n        {id: 11, text: 'm1',  value: {num: 45 , den: 32 }},\n        {id: 12, text: 'm2',  value: {num: 729, den: 512}},\n        {id: 13, text: 'P',   value: {num: 3  , den: 2  }},\n        {id: 14, text: 'd1',  value: {num: 128, den: 81 }},\n        {id: 15, text: 'd2',  value: {num: 8  , den: 5  }},\n        {id: 16, text: 'D1',  value: {num: 5  , den: 3  }},\n        {id: 17, text: 'D2',  value: {num: 27 , den: 16 }},\n        {id: 18, text: 'n1',  value: {num: 16 , den: 9  }},\n        {id: 19, text: 'n2',  value: {num: 9  , den: 5  }},\n        {id: 20, text: 'N1',  value: {num: 15 , den: 8  }},\n        {id: 21, text: 'N2',  value: {num: 243, den: 128}},\n        {id: 22, text: 'S\\'', value: {num: 2  , den: 1  }}\n      ]\n    }\n  },\n  methods: {\n    init () {\n      console.log(\"Initializing...\");\n      this.synth = new Tone.Synth().toMaster();\n    },\n    makeSound (fraction) {\n      const freq = Tone.Frequency(this.base_note).toFrequency();\n      var playFreq = Tone.Frequency((freq / fraction.den) * fraction.num)\n      this.synth.triggerAttackRelease(playFreq, \"6n\");\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\">\n#app {\n  font-family: 'Avenir', Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n  margin-top: 60px;\n}\n\nh1, h2 {\n  font-weight: normal;\n}\n\nul {\n  list-style-type: none;\n  padding: 0;\n}\n\nli {\n  display: inline-block;\n  margin: 0 10px;\n}\n\n$a-tags: 'a, a:active, a:hover, a:visited';\n$a-hover: 'a:active, a:hover';\n#{$a-tags} {\n  color: hotpink;\n  text-decoration: underline;\n}\n#{$a-hover} {\n  color: deeppink\n}\n</style>\n\n\n\n// WEBPACK FOOTER //\n// Main.vue?0308d6ff","import Vue from 'vue'\nimport Main from './Main.vue'\n\nconst NotFound = { template: '<p>Page not found</p>' }\nconst routes = {\n  '/': Main\n}\n\nnew Vue({\n  el: '#app',\n  install: function(Vue,) {\n  },\n  data: {\n    currentRoute: window.location.pathname\n  },\n  computed: {\n    ViewComponent () {\n      console.log(this.currentRoute)\n      return routes[this.currentRoute] ||\n             routes[this.currentRoute.replace('shruti-practice','')] ||\n             routes[this.currentRoute.replace('shruti-practice/','')] ||\n             NotFound\n    }\n  },\n  render (h) { return h(this.ViewComponent) }\n})\n\n\n\n// WEBPACK FOOTER //\n// ./src/main.js","exports = module.exports = require(\"../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"#app{font-family:Avenir,Helvetica,Arial,sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-align:center;color:#2c3e50;margin-top:60px}h1,h2{font-weight:400}ul{list-style-type:none;padding:0}li{display:inline-block;margin:0 10px}a,a:active,a:hover,a:visited{color:hotpink;text-decoration:underline}a:active,a:hover{color:#ff1493}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-271881da\",\"scoped\":false,\"hasInlineConfig\":false}!./~/sass-loader/lib/loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/Main.vue\n// module id = 4\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 5\n// module chunks = 0","(function(root, factory){\n\n\t//UMD\n\tif ( typeof define === \"function\" && define.amd ) {\n\t\tdefine(function() {\n\t\t\treturn factory();\n\t\t});\n\t} else if (typeof module === \"object\") {\n\t\tmodule.exports = factory();\n \t} else {\n\t\troot.Tone = factory();\n\t}\n\n}(this, function(){\n\n\t\"use strict\";\n\t\n\tvar Tone;\n\t//constructs the main Tone object\n\tfunction Main(func){\n\t\tTone = func();\n\t}\n\t//invokes each of the modules with the main Tone object as the argument\n\tfunction Module(func){\n\t\tfunc(Tone);\n\t}\t/**\n\t *  Tone.js\n\t *  @author Yotam Mann\n\t *  @license http://opensource.org/licenses/MIT MIT License\n\t *  @copyright 2014-2017 Yotam Mann\n\t */\n\tMain(function () {\n\t    \n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTONE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  @class  Tone is the base class of all other classes. It provides \n\t\t *          a lot of methods and functionality to all classes that extend\n\t\t *          it. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @alias Tone\n\t\t *  @param {number} [inputs=1] the number of input nodes\n\t\t *  @param {number} [outputs=1] the number of output nodes\n\t\t */\n\t    var Tone = function (inputs, outputs) {\n\t        /**\n\t\t\t *  the input node(s)\n\t\t\t *  @type {GainNode|Array}\n\t\t\t */\n\t        if (this.isUndef(inputs) || inputs === 1) {\n\t            this.input = this.context.createGain();\n\t        } else if (inputs > 1) {\n\t            this.input = new Array(inputs);\n\t        }\n\t        /**\n\t\t\t *  the output node(s)\n\t\t\t *  @type {GainNode|Array}\n\t\t\t */\n\t        if (this.isUndef(outputs) || outputs === 1) {\n\t            this.output = this.context.createGain();\n\t        } else if (outputs > 1) {\n\t            this.output = new Array(inputs);\n\t        }\n\t    };\n\t    /**\n\t\t *  Set the parameters at once. Either pass in an\n\t\t *  object mapping parameters to values, or to set a\n\t\t *  single parameter, by passing in a string and value.\n\t\t *  The last argument is an optional ramp time which \n\t\t *  will ramp any signal values to their destination value\n\t\t *  over the duration of the rampTime.\n\t\t *  @param {Object|string} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * //set values using an object\n\t\t * filter.set({\n\t\t * \t\"frequency\" : 300,\n\t\t * \t\"type\" : highpass\n\t\t * });\n\t\t *  @example\n\t\t * filter.set(\"type\", \"highpass\");\n\t\t *  @example\n\t\t * //ramp to the value 220 over 3 seconds. \n\t\t * oscillator.set({\n\t\t * \t\"frequency\" : 220\n\t\t * }, 3);\n\t\t */\n\t    Tone.prototype.set = function (params, value, rampTime) {\n\t        if (this.isObject(params)) {\n\t            rampTime = value;\n\t        } else if (this.isString(params)) {\n\t            var tmpObj = {};\n\t            tmpObj[params] = value;\n\t            params = tmpObj;\n\t        }\n\t        paramLoop:\n\t            for (var attr in params) {\n\t                value = params[attr];\n\t                var parent = this;\n\t                if (attr.indexOf('.') !== -1) {\n\t                    var attrSplit = attr.split('.');\n\t                    for (var i = 0; i < attrSplit.length - 1; i++) {\n\t                        parent = parent[attrSplit[i]];\n\t                        if (parent instanceof Tone) {\n\t                            attrSplit.splice(0, i + 1);\n\t                            var innerParam = attrSplit.join('.');\n\t                            parent.set(innerParam, value);\n\t                            continue paramLoop;\n\t                        }\n\t                    }\n\t                    attr = attrSplit[attrSplit.length - 1];\n\t                }\n\t                var param = parent[attr];\n\t                if (this.isUndef(param)) {\n\t                    continue;\n\t                }\n\t                if (Tone.Signal && param instanceof Tone.Signal || Tone.Param && param instanceof Tone.Param) {\n\t                    if (param.value !== value) {\n\t                        if (this.isUndef(rampTime)) {\n\t                            param.value = value;\n\t                        } else {\n\t                            param.rampTo(value, rampTime);\n\t                        }\n\t                    }\n\t                } else if (param instanceof AudioParam) {\n\t                    if (param.value !== value) {\n\t                        param.value = value;\n\t                    }\n\t                } else if (param instanceof Tone) {\n\t                    param.set(value);\n\t                } else if (param !== value) {\n\t                    parent[attr] = value;\n\t                }\n\t            }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the object's attributes. Given no arguments get\n\t\t *  will return all available object properties and their corresponding\n\t\t *  values. Pass in a single attribute to retrieve or an array\n\t\t *  of attributes. The attribute strings can also include a \".\"\n\t\t *  to access deeper properties.\n\t\t *  @example\n\t\t * osc.get();\n\t\t * //returns {\"type\" : \"sine\", \"frequency\" : 440, ...etc}\n\t\t *  @example\n\t\t * osc.get(\"type\");\n\t\t * //returns { \"type\" : \"sine\"}\n\t\t * @example\n\t\t * //use dot notation to access deep properties\n\t\t * synth.get([\"envelope.attack\", \"envelope.release\"]);\n\t\t * //returns {\"envelope\" : {\"attack\" : 0.2, \"release\" : 0.4}}\n\t\t *  @param {Array=|string|undefined} params the parameters to get, otherwise will return \n\t\t *  \t\t\t\t\t                  all available.\n\t\t *  @returns {Object}\n\t\t */\n\t    Tone.prototype.get = function (params) {\n\t        if (this.isUndef(params)) {\n\t            params = this._collectDefaults(this.constructor);\n\t        } else if (this.isString(params)) {\n\t            params = [params];\n\t        }\n\t        var ret = {};\n\t        for (var i = 0; i < params.length; i++) {\n\t            var attr = params[i];\n\t            var parent = this;\n\t            var subRet = ret;\n\t            if (attr.indexOf('.') !== -1) {\n\t                var attrSplit = attr.split('.');\n\t                for (var j = 0; j < attrSplit.length - 1; j++) {\n\t                    var subAttr = attrSplit[j];\n\t                    subRet[subAttr] = subRet[subAttr] || {};\n\t                    subRet = subRet[subAttr];\n\t                    parent = parent[subAttr];\n\t                }\n\t                attr = attrSplit[attrSplit.length - 1];\n\t            }\n\t            var param = parent[attr];\n\t            if (this.isObject(params[attr])) {\n\t                subRet[attr] = param.get();\n\t            } else if (Tone.Signal && param instanceof Tone.Signal) {\n\t                subRet[attr] = param.value;\n\t            } else if (Tone.Param && param instanceof Tone.Param) {\n\t                subRet[attr] = param.value;\n\t            } else if (param instanceof AudioParam) {\n\t                subRet[attr] = param.value;\n\t            } else if (param instanceof Tone) {\n\t                subRet[attr] = param.get();\n\t            } else if (!this.isFunction(param) && !this.isUndef(param)) {\n\t                subRet[attr] = param;\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  collect all of the default attributes in one\n\t\t *  @private\n\t\t *  @param {function} constr the constructor to find the defaults from\n\t\t *  @return {Array} all of the attributes which belong to the class\n\t\t */\n\t    Tone.prototype._collectDefaults = function (constr) {\n\t        var ret = [];\n\t        if (!this.isUndef(constr.defaults)) {\n\t            ret = Object.keys(constr.defaults);\n\t        }\n\t        if (!this.isUndef(constr._super)) {\n\t            var superDefs = this._collectDefaults(constr._super);\n\t            //filter out repeats\n\t            for (var i = 0; i < superDefs.length; i++) {\n\t                if (ret.indexOf(superDefs[i]) === -1) {\n\t                    ret.push(superDefs[i]);\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  @returns {string} returns the name of the class as a string\n\t\t */\n\t    Tone.prototype.toString = function () {\n\t        for (var className in Tone) {\n\t            var isLetter = className[0].match(/^[A-Z]$/);\n\t            var sameConstructor = Tone[className] === this.constructor;\n\t            if (this.isFunction(Tone[className]) && isLetter && sameConstructor) {\n\t                return className;\n\t            }\n\t        }\n\t        return 'Tone';\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCLASS VARS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The number of inputs feeding into the AudioNode. \n\t\t *  For source nodes, this will be 0.\n\t\t *  @memberOf Tone#\n\t\t *  @name numberOfInputs\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'numberOfInputs', {\n\t        get: function () {\n\t            if (this.input) {\n\t                if (this.isArray(this.input)) {\n\t                    return this.input.length;\n\t                } else {\n\t                    return 1;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of outputs coming out of the AudioNode. \n\t\t *  For source nodes, this will be 0.\n\t\t *  @memberOf Tone#\n\t\t *  @name numberOfInputs\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'numberOfOutputs', {\n\t        get: function () {\n\t            if (this.output) {\n\t                if (this.isArray(this.output)) {\n\t                    return this.output.length;\n\t                } else {\n\t                    return 1;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCONNECTIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  disconnect and dispose\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.dispose = function () {\n\t        if (!this.isUndef(this.input)) {\n\t            if (this.input instanceof AudioNode) {\n\t                this.input.disconnect();\n\t            }\n\t            this.input = null;\n\t        }\n\t        if (!this.isUndef(this.output)) {\n\t            if (this.output instanceof AudioNode) {\n\t                this.output.disconnect();\n\t            }\n\t            this.output = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the output of a ToneNode to an AudioParam, AudioNode, or ToneNode\n\t\t *  @param  {Tone | AudioParam | AudioNode} unit \n\t\t *  @param {number} [outputNum=0] optionally which output to connect from\n\t\t *  @param {number} [inputNum=0] optionally which input to connect to\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.connect = function (unit, outputNum, inputNum) {\n\t        if (Array.isArray(this.output)) {\n\t            outputNum = this.defaultArg(outputNum, 0);\n\t            this.output[outputNum].connect(unit, 0, inputNum);\n\t        } else {\n\t            this.output.connect(unit, outputNum, inputNum);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  disconnect the output\n\t\t *  @param {Number|AudioNode} output Either the output index to disconnect\n\t\t *                                   if the output is an array, or the\n\t\t *                                   node to disconnect from.\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.disconnect = function (destination, outputNum, inputNum) {\n\t        if (this.isArray(this.output)) {\n\t            if (this.isNumber(destination)) {\n\t                this.output[destination].disconnect();\n\t            } else {\n\t                outputNum = this.defaultArg(outputNum, 0);\n\t                this.output[outputNum].disconnect(destination, 0, inputNum);\n\t            }\n\t        } else {\n\t            this.output.disconnect.apply(this.output, arguments);\n\t        }\n\t    };\n\t    /**\n\t\t *  connect together all of the arguments in series\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.connectSeries = function () {\n\t        if (arguments.length > 1) {\n\t            var currentUnit = arguments[0];\n\t            for (var i = 1; i < arguments.length; i++) {\n\t                var toUnit = arguments[i];\n\t                currentUnit.connect(toUnit);\n\t                currentUnit = toUnit;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Connect the output of this node to the rest of the nodes in series.\n\t\t *  @example\n\t\t *  //connect a node to an effect, panVol and then to the master output\n\t\t *  node.chain(effect, panVol, Tone.Master);\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.chain = function () {\n\t        if (arguments.length > 0) {\n\t            var currentUnit = this;\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                var toUnit = arguments[i];\n\t                currentUnit.connect(toUnit);\n\t                currentUnit = toUnit;\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the output of this node to the rest of the nodes in parallel.\n\t\t *  @param {...AudioParam|Tone|AudioNode} nodes\n\t\t *  @returns {Tone} this\n\t\t */\n\t    Tone.prototype.fan = function () {\n\t        if (arguments.length > 0) {\n\t            for (var i = 0; i < arguments.length; i++) {\n\t                this.connect(arguments[i]);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    //give native nodes chain and fan methods\n\t    AudioNode.prototype.chain = Tone.prototype.chain;\n\t    AudioNode.prototype.fan = Tone.prototype.fan;\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUTILITIES / HELPERS / MATHS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  If the `given` parameter is undefined, use the `fallback`. \n\t\t *  If both `given` and `fallback` are object literals, it will\n\t\t *  return a deep copy which includes all of the parameters from both \n\t\t *  objects. If a parameter is undefined in given, it will return\n\t\t *  the fallback property. \n\t\t *  <br><br>\n\t\t *  WARNING: if object is self referential, it will go into an an \n\t\t *  infinite recursive loop.\n\t\t *  \n\t\t *  @param  {*} given    \n\t\t *  @param  {*} fallback \n\t\t *  @return {*}          \n\t\t */\n\t    Tone.prototype.defaultArg = function (given, fallback) {\n\t        if (this.isObject(given) && this.isObject(fallback)) {\n\t            var ret = {};\n\t            //make a deep copy of the given object\n\t            for (var givenProp in given) {\n\t                ret[givenProp] = this.defaultArg(fallback[givenProp], given[givenProp]);\n\t            }\n\t            for (var fallbackProp in fallback) {\n\t                ret[fallbackProp] = this.defaultArg(given[fallbackProp], fallback[fallbackProp]);\n\t            }\n\t            return ret;\n\t        } else {\n\t            return this.isUndef(given) ? fallback : given;\n\t        }\n\t    };\n\t    /**\n\t\t *  returns the args as an options object with given arguments\n\t\t *  mapped to the names provided. \n\t\t *\n\t\t *  if the args given is an array containing only one object, it is assumed\n\t\t *  that that's already the options object and will just return it. \n\t\t *  \n\t\t *  @param  {Array} values  the 'arguments' object of the function\n\t\t *  @param  {Array} keys the names of the arguments as they\n\t\t *                                 should appear in the options object\n\t\t *  @param {Object=} defaults optional defaults to mixin to the returned \n\t\t *                            options object                              \n\t\t *  @return {Object}       the options object with the names mapped to the arguments\n\t\t */\n\t    Tone.prototype.optionsObject = function (values, keys, defaults) {\n\t        var options = {};\n\t        if (values.length === 1 && this.isObject(values[0])) {\n\t            options = values[0];\n\t        } else {\n\t            for (var i = 0; i < keys.length; i++) {\n\t                options[keys[i]] = values[i];\n\t            }\n\t        }\n\t        if (!this.isUndef(defaults)) {\n\t            return this.defaultArg(options, defaults);\n\t        } else {\n\t            return options;\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // TYPE CHECKING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  test if the arg is undefined\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is undefined\n\t\t *  @function\n\t\t */\n\t    Tone.prototype.isUndef = function (val) {\n\t        return typeof val === 'undefined';\n\t    };\n\t    /**\n\t\t *  test if the arg is a function\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a function\n\t\t *  @function\n\t\t */\n\t    Tone.prototype.isFunction = function (val) {\n\t        return typeof val === 'function';\n\t    };\n\t    /**\n\t\t *  Test if the argument is a number.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a number\n\t\t */\n\t    Tone.prototype.isNumber = function (arg) {\n\t        return typeof arg === 'number';\n\t    };\n\t    /**\n\t\t *  Test if the given argument is an object literal (i.e. `{}`);\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is an object literal.\n\t\t */\n\t    Tone.prototype.isObject = function (arg) {\n\t        return Object.prototype.toString.call(arg) === '[object Object]' && arg.constructor === Object;\n\t    };\n\t    /**\n\t\t *  Test if the argument is a boolean.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a boolean\n\t\t */\n\t    Tone.prototype.isBoolean = function (arg) {\n\t        return typeof arg === 'boolean';\n\t    };\n\t    /**\n\t\t *  Test if the argument is an Array\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is an array\n\t\t */\n\t    Tone.prototype.isArray = function (arg) {\n\t        return Array.isArray(arg);\n\t    };\n\t    /**\n\t\t *  Test if the argument is a string.\n\t\t *  @param {*} arg the argument to test\n\t\t *  @returns {boolean} true if the arg is a string\n\t\t */\n\t    Tone.prototype.isString = function (arg) {\n\t        return typeof arg === 'string';\n\t    };\n\t    /**\n\t\t *  An empty function.\n\t\t *  @static\n\t\t */\n\t    Tone.noOp = function () {\n\t    };\n\t    /**\n\t\t *  Make the property not writable. Internal use only. \n\t\t *  @private\n\t\t *  @param  {string}  property  the property to make not writable\n\t\t */\n\t    Tone.prototype._readOnly = function (property) {\n\t        if (Array.isArray(property)) {\n\t            for (var i = 0; i < property.length; i++) {\n\t                this._readOnly(property[i]);\n\t            }\n\t        } else {\n\t            Object.defineProperty(this, property, {\n\t                writable: false,\n\t                enumerable: true\n\t            });\n\t        }\n\t    };\n\t    /**\n\t\t *  Make an attribute writeable. Interal use only. \n\t\t *  @private\n\t\t *  @param  {string}  property  the property to make writable\n\t\t */\n\t    Tone.prototype._writable = function (property) {\n\t        if (Array.isArray(property)) {\n\t            for (var i = 0; i < property.length; i++) {\n\t                this._writable(property[i]);\n\t            }\n\t        } else {\n\t            Object.defineProperty(this, property, { writable: true });\n\t        }\n\t    };\n\t    /**\n\t\t * Possible play states. \n\t\t * @enum {string}\n\t\t */\n\t    Tone.State = {\n\t        Started: 'started',\n\t        Stopped: 'stopped',\n\t        Paused: 'paused'\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Equal power gain scale. Good for cross-fading.\n\t\t *  @param  {NormalRange} percent (0-1)\n\t\t *  @return {Number}         output gain (0-1)\n\t\t */\n\t    Tone.prototype.equalPowerScale = function (percent) {\n\t        var piFactor = 0.5 * Math.PI;\n\t        return Math.sin(percent * piFactor);\n\t    };\n\t    /**\n\t\t *  Convert decibels into gain.\n\t\t *  @param  {Decibels} db\n\t\t *  @return {Number}   \n\t\t */\n\t    Tone.prototype.dbToGain = function (db) {\n\t        return Math.pow(2, db / 6);\n\t    };\n\t    /**\n\t\t *  Convert gain to decibels.\n\t\t *  @param  {Number} gain (0-1)\n\t\t *  @return {Decibels}   \n\t\t */\n\t    Tone.prototype.gainToDb = function (gain) {\n\t        return 20 * (Math.log(gain) / Math.LN10);\n\t    };\n\t    /**\n\t\t *  Convert an interval (in semitones) to a frequency ratio.\n\t\t *  @param  {Interval} interval the number of semitones above the base note\n\t\t *  @return {number}          the frequency ratio\n\t\t *  @example\n\t\t * tone.intervalToFrequencyRatio(0); // 1\n\t\t * tone.intervalToFrequencyRatio(12); // 2\n\t\t * tone.intervalToFrequencyRatio(-12); // 0.5\n\t\t */\n\t    Tone.prototype.intervalToFrequencyRatio = function (interval) {\n\t        return Math.pow(2, interval / 12);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTIMING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Return the current time of the AudioContext clock.\n\t\t *  @return {Number} the currentTime from the AudioContext\n\t\t */\n\t    Tone.prototype.now = function () {\n\t        return Tone.context.now();\n\t    };\n\t    /**\n\t\t *  Return the current time of the AudioContext clock.\n\t\t *  @return {Number} the currentTime from the AudioContext\n\t\t *  @static\n\t\t */\n\t    Tone.now = function () {\n\t        return Tone.context.now();\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tINHERITANCE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  have a child inherit all of Tone's (or a parent's) prototype\n\t\t *  to inherit the parent's properties, make sure to call \n\t\t *  Parent.call(this) in the child's constructor\n\t\t *\n\t\t *  based on closure library's inherit function\n\t\t *\n\t\t *  @static\n\t\t *  @param  {function} \tchild  \n\t\t *  @param  {function=} parent (optional) parent to inherit from\n\t\t *                             if no parent is supplied, the child\n\t\t *                             will inherit from Tone\n\t\t */\n\t    Tone.extend = function (child, parent) {\n\t        if (Tone.prototype.isUndef(parent)) {\n\t            parent = Tone;\n\t        }\n\t        function TempConstructor() {\n\t        }\n\t        TempConstructor.prototype = parent.prototype;\n\t        child.prototype = new TempConstructor();\n\t        /** @override */\n\t        child.prototype.constructor = child;\n\t        child._super = parent;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tCONTEXT\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The private audio context shared by all Tone Nodes. \n\t\t *  @private\n\t\t *  @type {Tone.Context|undefined}\n\t\t */\n\t    var audioContext;\n\t    /**\n\t\t *  A static pointer to the audio context accessible as Tone.context. \n\t\t *  @type {Tone.Context}\n\t\t *  @name context\n\t\t *  @memberOf Tone\n\t\t */\n\t    Object.defineProperty(Tone, 'context', {\n\t        get: function () {\n\t            return audioContext;\n\t        },\n\t        set: function (context) {\n\t            if (Tone.Context && context instanceof Tone.Context) {\n\t                audioContext = context;\n\t            } else {\n\t                audioContext = new Tone.Context(context);\n\t            }\n\t            //initialize the new audio context\n\t            if (Tone.Context) {\n\t                Tone.Context.emit('init', audioContext);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The AudioContext\n\t\t *  @type {Tone.Context}\n\t\t *  @name context\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'context', {\n\t        get: function () {\n\t            return Tone.context;\n\t        }\n\t    });\n\t    /**\n\t\t *  Tone automatically creates a context on init, but if you are working\n\t\t *  with other libraries which also create an AudioContext, it can be\n\t\t *  useful to set your own. If you are going to set your own context, \n\t\t *  be sure to do it at the start of your code, before creating any objects.\n\t\t *  @static\n\t\t *  @param {AudioContext} ctx The new audio context to set\n\t\t */\n\t    Tone.setContext = function (ctx) {\n\t        Tone.context = ctx;\n\t    };\n\t    /**\n\t\t *  The number of seconds of 1 processing block (128 samples)\n\t\t *  @type {Number}\n\t\t *  @name blockTime\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'blockTime', {\n\t        get: function () {\n\t            return 128 / this.context.sampleRate;\n\t        }\n\t    });\n\t    /**\n\t\t *  The duration in seconds of one sample.\n\t\t *  @type {Number}\n\t\t *  @name sampleTime\n\t\t *  @memberOf Tone#\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.prototype, 'sampleTime', {\n\t        get: function () {\n\t            return 1 / this.context.sampleRate;\n\t        }\n\t    });\n\t    /**\n\t\t *  Whether or not all the technologies that Tone.js relies on are supported by the current browser. \n\t\t *  @type {Boolean}\n\t\t *  @name supported\n\t\t *  @memberOf Tone\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone, 'supported', {\n\t        get: function () {\n\t            var hasAudioContext = window.hasOwnProperty('AudioContext') || window.hasOwnProperty('webkitAudioContext');\n\t            var hasPromises = window.hasOwnProperty('Promise');\n\t            var hasWorkers = window.hasOwnProperty('Worker');\n\t            return hasAudioContext && hasPromises && hasWorkers;\n\t        }\n\t    });\n\t    Tone.version = 'r10';\n\t    // allow optional silencing of this log\n\t    if (!window.TONE_SILENCE_VERSION_LOGGING) {\n\t        console.log('%c * Tone.js ' + Tone.version + ' * ', 'background: #000; color: #fff');\n\t    }\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base class for all Signals. Used Internally. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.SignalBase = function () {\n\t    };\n\t    Tone.extend(Tone.SignalBase);\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t */\n\t    Tone.SignalBase.prototype.connect = function (node, outputNumber, inputNumber) {\n\t        //zero it out so that the signal can have full control\n\t        if (Tone.Signal && Tone.Signal === node.constructor || Tone.Param && Tone.Param === node.constructor || Tone.TimelineSignal && Tone.TimelineSignal === node.constructor) {\n\t            //cancel changes\n\t            node._param.cancelScheduledValues(0);\n\t            //reset the value\n\t            node._param.value = 0;\n\t            //mark the value as overridden\n\t            node.overridden = true;\n\t        } else if (node instanceof AudioParam) {\n\t            node.cancelScheduledValues(0);\n\t            node.value = 0;\n\t        }\n\t        Tone.prototype.connect.call(this, node, outputNumber, inputNumber);\n\t        return this;\n\t    };\n\t    return Tone.SignalBase;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Wraps the native Web Audio API \n\t\t *         [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {function|Array|Number} mapping The function used to define the values. \n\t\t *                                    The mapping function should take two arguments: \n\t\t *                                    the first is the value at the current position \n\t\t *                                    and the second is the array position. \n\t\t *                                    If the argument is an array, that array will be\n\t\t *                                    set as the wave shaping function. The input\n\t\t *                                    signal is an AudioRange [-1, 1] value and the output\n\t\t *                                    signal can take on any numerical values. \n\t\t *                                    \n\t\t *  @param {Number} [bufferLen=1024] The length of the WaveShaperNode buffer.\n\t\t *  @example\n\t\t * var timesTwo = new Tone.WaveShaper(function(val){\n\t\t * \treturn val * 2;\n\t\t * }, 2048);\n\t\t *  @example\n\t\t * //a waveshaper can also be constructed with an array of values\n\t\t * var invert = new Tone.WaveShaper([1, -1]);\n\t\t */\n\t    Tone.WaveShaper = function (mapping, bufferLen) {\n\t        /**\n\t\t\t *  the waveshaper\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = this.input = this.output = this.context.createWaveShaper();\n\t        /**\n\t\t\t *  the waveshapers curve\n\t\t\t *  @type {Float32Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._curve = null;\n\t        if (Array.isArray(mapping)) {\n\t            this.curve = mapping;\n\t        } else if (isFinite(mapping) || this.isUndef(mapping)) {\n\t            this._curve = new Float32Array(this.defaultArg(mapping, 1024));\n\t        } else if (this.isFunction(mapping)) {\n\t            this._curve = new Float32Array(this.defaultArg(bufferLen, 1024));\n\t            this.setMap(mapping);\n\t        }\n\t    };\n\t    Tone.extend(Tone.WaveShaper, Tone.SignalBase);\n\t    /**\n\t\t *  Uses a mapping function to set the value of the curve. \n\t\t *  @param {function} mapping The function used to define the values. \n\t\t *                            The mapping function take two arguments: \n\t\t *                            the first is the value at the current position \n\t\t *                            which goes from -1 to 1 over the number of elements\n\t\t *                            in the curve array. The second argument is the array position. \n\t\t *  @returns {Tone.WaveShaper} this\n\t\t *  @example\n\t\t * //map the input signal from [-1, 1] to [0, 10]\n\t\t * shaper.setMap(function(val, index){\n\t\t * \treturn (val + 1) * 5;\n\t\t * })\n\t\t */\n\t    Tone.WaveShaper.prototype.setMap = function (mapping) {\n\t        for (var i = 0, len = this._curve.length; i < len; i++) {\n\t            var normalized = i / (len - 1) * 2 - 1;\n\t            this._curve[i] = mapping(normalized, i);\n\t        }\n\t        this._shaper.curve = this._curve;\n\t        return this;\n\t    };\n\t    /**\n\t\t * The array to set as the waveshaper curve. For linear curves\n\t\t * array length does not make much difference, but for complex curves\n\t\t * longer arrays will provide smoother interpolation. \n\t\t * @memberOf Tone.WaveShaper#\n\t\t * @type {Array}\n\t\t * @name curve\n\t\t */\n\t    Object.defineProperty(Tone.WaveShaper.prototype, 'curve', {\n\t        get: function () {\n\t            return this._shaper.curve;\n\t        },\n\t        set: function (mapping) {\n\t            this._curve = new Float32Array(mapping);\n\t            this._shaper.curve = this._curve;\n\t        }\n\t    });\n\t    /**\n\t\t * Specifies what type of oversampling (if any) should be used when \n\t\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\". \n\t\t * @memberOf Tone.WaveShaper#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.WaveShaper.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            if ([\n\t                    'none',\n\t                    '2x',\n\t                    '4x'\n\t                ].indexOf(oversampling) !== -1) {\n\t                this._shaper.oversample = oversampling;\n\t            } else {\n\t                throw new RangeError('Tone.WaveShaper: oversampling must be either \\'none\\', \\'2x\\', or \\'4x\\'');\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.WaveShaper} this\n\t\t */\n\t    Tone.WaveShaper.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._shaper.disconnect();\n\t        this._shaper = null;\n\t        this._curve = null;\n\t        return this;\n\t    };\n\t    return Tone.WaveShaper;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.TimeBase is a flexible encoding of time\n\t\t *         which can be evaluated to and from a string.\n\t\t *         Parsing code modified from https://code.google.com/p/tapdigit/\n\t\t *         Copyright 2011 2012 Ariya Hidayat, New BSD License\n\t\t *  @extends {Tone}\n\t\t *  @param  {Time}  val    The time value as a number or string\n\t\t *  @param  {String=}  units  Unit values\n\t\t *  @example\n\t\t * Tone.TimeBase(4, \"n\")\n\t\t * Tone.TimeBase(2, \"t\")\n\t\t * Tone.TimeBase(\"2t\").add(\"1m\")\n\t\t * Tone.TimeBase(\"2t + 1m\");\n\t\t */\n\t    Tone.TimeBase = function (val, units) {\n\t        //allows it to be constructed with or without 'new'\n\t        if (this instanceof Tone.TimeBase) {\n\t            /**\n\t\t\t\t *  Any expressions parsed from the Time\n\t\t\t\t *  @type  {Array}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._expr = this._noOp;\n\t            if (val instanceof Tone.TimeBase) {\n\t                this.copy(val);\n\t            } else if (!this.isUndef(units) || this.isNumber(val)) {\n\t                //default units\n\t                units = this.defaultArg(units, this._defaultUnits);\n\t                var method = this._primaryExpressions[units].method;\n\t                this._expr = method.bind(this, val);\n\t            } else if (this.isString(val)) {\n\t                this.set(val);\n\t            } else if (this.isUndef(val)) {\n\t                //default expression\n\t                this._expr = this._defaultExpr();\n\t            }\n\t        } else {\n\t            return new Tone.TimeBase(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.TimeBase);\n\t    /**\n\t\t *  Repalce the current time value with the value\n\t\t *  given by the expression string.\n\t\t *  @param  {String}  exprString\n\t\t *  @return {Tone.TimeBase} this\n\t\t */\n\t    Tone.TimeBase.prototype.set = function (exprString) {\n\t        this._expr = this._parseExprString(exprString);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Return a clone of the TimeBase object.\n\t\t *  @return  {Tone.TimeBase} The new cloned Tone.TimeBase\n\t\t */\n\t    Tone.TimeBase.prototype.clone = function () {\n\t        var instance = new this.constructor();\n\t        instance.copy(this);\n\t        return instance;\n\t    };\n\t    /**\n\t\t *  Copies the value of time to this Time\n\t\t *  @param {Tone.TimeBase} time\n\t\t *  @return  {TimeBase}\n\t\t */\n\t    Tone.TimeBase.prototype.copy = function (time) {\n\t        var val = time._expr();\n\t        return this.set(val);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tABSTRACT SYNTAX TREE PARSER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  All the primary expressions.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._primaryExpressions = {\n\t        'n': {\n\t            regexp: /^(\\d+)n/i,\n\t            method: function (value) {\n\t                value = parseInt(value);\n\t                if (value === 1) {\n\t                    return this._beatsToUnits(this._timeSignature());\n\t                } else {\n\t                    return this._beatsToUnits(4 / value);\n\t                }\n\t            }\n\t        },\n\t        't': {\n\t            regexp: /^(\\d+)t/i,\n\t            method: function (value) {\n\t                value = parseInt(value);\n\t                return this._beatsToUnits(8 / (parseInt(value) * 3));\n\t            }\n\t        },\n\t        'm': {\n\t            regexp: /^(\\d+)m/i,\n\t            method: function (value) {\n\t                return this._beatsToUnits(parseInt(value) * this._timeSignature());\n\t            }\n\t        },\n\t        'i': {\n\t            regexp: /^(\\d+)i/i,\n\t            method: function (value) {\n\t                return this._ticksToUnits(parseInt(value));\n\t            }\n\t        },\n\t        'hz': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?)hz/i,\n\t            method: function (value) {\n\t                return this._frequencyToUnits(parseFloat(value));\n\t            }\n\t        },\n\t        'tr': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t            method: function (m, q, s) {\n\t                var total = 0;\n\t                if (m && m !== '0') {\n\t                    total += this._beatsToUnits(this._timeSignature() * parseFloat(m));\n\t                }\n\t                if (q && q !== '0') {\n\t                    total += this._beatsToUnits(parseFloat(q));\n\t                }\n\t                if (s && s !== '0') {\n\t                    total += this._beatsToUnits(parseFloat(s) / 4);\n\t                }\n\t                return total;\n\t            }\n\t        },\n\t        's': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?s)/,\n\t            method: function (value) {\n\t                return this._secondsToUnits(parseFloat(value));\n\t            }\n\t        },\n\t        'samples': {\n\t            regexp: /^(\\d+)samples/,\n\t            method: function (value) {\n\t                return parseInt(value) / this.context.sampleRate;\n\t            }\n\t        },\n\t        'default': {\n\t            regexp: /^(\\d+(?:\\.\\d+)?)/,\n\t            method: function (value) {\n\t                return this._primaryExpressions[this._defaultUnits].method.call(this, value);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  All the binary expressions that TimeBase can accept.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._binaryExpressions = {\n\t        '+': {\n\t            regexp: /^\\+/,\n\t            precedence: 2,\n\t            method: function (lh, rh) {\n\t                return lh() + rh();\n\t            }\n\t        },\n\t        '-': {\n\t            regexp: /^\\-/,\n\t            precedence: 2,\n\t            method: function (lh, rh) {\n\t                return lh() - rh();\n\t            }\n\t        },\n\t        '*': {\n\t            regexp: /^\\*/,\n\t            precedence: 1,\n\t            method: function (lh, rh) {\n\t                return lh() * rh();\n\t            }\n\t        },\n\t        '/': {\n\t            regexp: /^\\//,\n\t            precedence: 1,\n\t            method: function (lh, rh) {\n\t                return lh() / rh();\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  All the unary expressions.\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._unaryExpressions = {\n\t        'neg': {\n\t            regexp: /^\\-/,\n\t            method: function (lh) {\n\t                return -lh();\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Syntactic glue which holds expressions together\n\t\t *  @private\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.TimeBase.prototype._syntaxGlue = {\n\t        '(': { regexp: /^\\(/ },\n\t        ')': { regexp: /^\\)/ }\n\t    };\n\t    /**\n\t\t *  tokenize the expression based on the Expressions object\n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}      returns two methods on the tokenized list, next and peek\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._tokenize = function (expr) {\n\t        var position = -1;\n\t        var tokens = [];\n\t        while (expr.length > 0) {\n\t            expr = expr.trim();\n\t            var token = getNextToken(expr, this);\n\t            tokens.push(token);\n\t            expr = expr.substr(token.value.length);\n\t        }\n\t        function getNextToken(expr, context) {\n\t            var expressions = [\n\t                '_binaryExpressions',\n\t                '_unaryExpressions',\n\t                '_primaryExpressions',\n\t                '_syntaxGlue'\n\t            ];\n\t            for (var i = 0; i < expressions.length; i++) {\n\t                var group = context[expressions[i]];\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    var reg = op.regexp;\n\t                    var match = expr.match(reg);\n\t                    if (match !== null) {\n\t                        return {\n\t                            method: op.method,\n\t                            precedence: op.precedence,\n\t                            regexp: op.regexp,\n\t                            value: match[0]\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t            throw new SyntaxError('Tone.TimeBase: Unexpected token ' + expr);\n\t        }\n\t        return {\n\t            next: function () {\n\t                return tokens[++position];\n\t            },\n\t            peek: function () {\n\t                return tokens[position + 1];\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  Given a token, find the value within the groupName\n\t\t *  @param {Object} token\n\t\t *  @param {String} groupName\n\t\t *  @param {Number} precedence\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._matchGroup = function (token, group, prec) {\n\t        var ret = false;\n\t        if (!this.isUndef(token)) {\n\t            for (var opName in group) {\n\t                var op = group[opName];\n\t                if (op.regexp.test(token.value)) {\n\t                    if (!this.isUndef(prec)) {\n\t                        if (op.precedence === prec) {\n\t                            return op;\n\t                        }\n\t                    } else {\n\t                        return op;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return ret;\n\t    };\n\t    /**\n\t\t *  Match a binary expression given the token and the precedence\n\t\t *  @param {Lexer} lexer\n\t\t *  @param {Number} precedence\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseBinary = function (lexer, precedence) {\n\t        if (this.isUndef(precedence)) {\n\t            precedence = 2;\n\t        }\n\t        var expr;\n\t        if (precedence < 0) {\n\t            expr = this._parseUnary(lexer);\n\t        } else {\n\t            expr = this._parseBinary(lexer, precedence - 1);\n\t        }\n\t        var token = lexer.peek();\n\t        while (token && this._matchGroup(token, this._binaryExpressions, precedence)) {\n\t            token = lexer.next();\n\t            expr = token.method.bind(this, expr, this._parseBinary(lexer, precedence - 1));\n\t            token = lexer.peek();\n\t        }\n\t        return expr;\n\t    };\n\t    /**\n\t\t *  Match a unary expression.\n\t\t *  @param {Lexer} lexer\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseUnary = function (lexer) {\n\t        var token, expr;\n\t        token = lexer.peek();\n\t        var op = this._matchGroup(token, this._unaryExpressions);\n\t        if (op) {\n\t            token = lexer.next();\n\t            expr = this._parseUnary(lexer);\n\t            return op.method.bind(this, expr);\n\t        }\n\t        return this._parsePrimary(lexer);\n\t    };\n\t    /**\n\t\t *  Match a primary expression (a value).\n\t\t *  @param {Lexer} lexer\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parsePrimary = function (lexer) {\n\t        var token, expr;\n\t        token = lexer.peek();\n\t        if (this.isUndef(token)) {\n\t            throw new SyntaxError('Tone.TimeBase: Unexpected end of expression');\n\t        }\n\t        if (this._matchGroup(token, this._primaryExpressions)) {\n\t            token = lexer.next();\n\t            var matching = token.value.match(token.regexp);\n\t            return token.method.bind(this, matching[1], matching[2], matching[3]);\n\t        }\n\t        if (token && token.value === '(') {\n\t            lexer.next();\n\t            expr = this._parseBinary(lexer);\n\t            token = lexer.next();\n\t            if (!(token && token.value === ')')) {\n\t                throw new SyntaxError('Expected )');\n\t            }\n\t            return expr;\n\t        }\n\t        throw new SyntaxError('Tone.TimeBase: Cannot process token ' + token.value);\n\t    };\n\t    /**\n\t\t *  Recursively parse the string expression into a syntax tree.\n\t\t *  @param   {string} expr \n\t\t *  @return  {Function} the bound method to be evaluated later\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._parseExprString = function (exprString) {\n\t        if (!this.isString(exprString)) {\n\t            exprString = exprString.toString();\n\t        }\n\t        var lexer = this._tokenize(exprString);\n\t        var tree = this._parseBinary(lexer);\n\t        return tree;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tDEFAULTS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The initial expression value\n\t\t *  @return  {Number}  The initial value 0\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._noOp = function () {\n\t        return 0;\n\t    };\n\t    /**\n\t\t *  The default expression value if no arguments are given\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._defaultExpr = function () {\n\t        return this._noOp;\n\t    };\n\t    /**\n\t\t *  The default units if none are given.\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._defaultUnits = 's';\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value of a frequency in the current units\n\t\t *  @param {Frequency} freq\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._frequencyToUnits = function (freq) {\n\t        return 1 / freq;\n\t    };\n\t    /**\n\t\t *  Return the value of the beats in the current units\n\t\t *  @param {Number} beats\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._beatsToUnits = function (beats) {\n\t        return 60 / Tone.Transport.bpm.value * beats;\n\t    };\n\t    /**\n\t\t *  Returns the value of a second in the current units\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._secondsToUnits = function (seconds) {\n\t        return seconds;\n\t    };\n\t    /**\n\t\t *  Returns the value of a tick in the current time units\n\t\t *  @param {Ticks} ticks\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._ticksToUnits = function (ticks) {\n\t        return ticks * (this._beatsToUnits(1) / Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Return the time signature.\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._timeSignature = function () {\n\t        return Tone.Transport.timeSignature;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Push an expression onto the expression list\n\t\t *  @param  {Time}  val\n\t\t *  @param  {String}  type\n\t\t *  @param  {String}  units\n\t\t *  @return  {Tone.TimeBase} \n\t\t *  @private\n\t\t */\n\t    Tone.TimeBase.prototype._pushExpr = function (val, name, units) {\n\t        //create the expression\n\t        if (!(val instanceof Tone.TimeBase)) {\n\t            val = new this.constructor(val, units);\n\t        }\n\t        this._expr = this._binaryExpressions[name].method.bind(this, this._expr, val._expr);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add to the current value.\n\t\t *  @param  {Time}  val    The value to add\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").add(\"1m\"); //\"3m\"\n\t\t */\n\t    Tone.TimeBase.prototype.add = function (val, units) {\n\t        return this._pushExpr(val, '+', units);\n\t    };\n\t    /**\n\t\t *  Subtract the value from the current time.\n\t\t *  @param  {Time}  val    The value to subtract\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").sub(\"1m\"); //\"1m\"\n\t\t */\n\t    Tone.TimeBase.prototype.sub = function (val, units) {\n\t        return this._pushExpr(val, '-', units);\n\t    };\n\t    /**\n\t\t *  Multiply the current value by the given time.\n\t\t *  @param  {Time}  val    The value to multiply\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").mult(\"2\"); //\"4m\"\n\t\t */\n\t    Tone.TimeBase.prototype.mult = function (val, units) {\n\t        return this._pushExpr(val, '*', units);\n\t    };\n\t    /**\n\t\t *  Divide the current value by the given time.\n\t\t *  @param  {Time}  val    The value to divide by\n\t\t *  @param  {String=}  units  Optional units to use with the value.\n\t\t *  @return  {Tone.TimeBase}  this\n\t\t *  @example\n\t\t * Tone.TimeBase(\"2m\").div(2); //\"1m\"\n\t\t */\n\t    Tone.TimeBase.prototype.div = function (val, units) {\n\t        return this._pushExpr(val, '/', units);\n\t    };\n\t    /**\n\t\t *  Evaluate the time value. Returns the time\n\t\t *  in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.TimeBase.prototype.valueOf = function () {\n\t        return this._expr();\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return {Tone.TimeBase} this\n\t\t */\n\t    Tone.TimeBase.prototype.dispose = function () {\n\t        this._expr = null;\n\t    };\n\t    return Tone.TimeBase;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Time is a primitive type for encoding Time values. \n\t\t *         Eventually all time values are evaluated to seconds\n\t\t *         using the `eval` method. Tone.Time can be constructed\n\t\t *         with or without the `new` keyword. Tone.Time can be passed\n\t\t *         into the parameter of any method which takes time as an argument. \n\t\t *  @constructor\n\t\t *  @extends {Tone.TimeBase}\n\t\t *  @param  {String|Number}  val    The time value.\n\t\t *  @param  {String=}  units  The units of the value.\n\t\t *  @example\n\t\t * var t = Tone.Time(\"4n\");//encodes a quarter note\n\t\t * t.mult(4); // multiply that value by 4\n\t\t * t.toNotation(); //returns \"1m\"\n\t\t */\n\t    Tone.Time = function (val, units) {\n\t        if (this instanceof Tone.Time) {\n\t            /**\n\t\t\t\t *  If the current clock time should\n\t\t\t\t *  be added to the output\n\t\t\t\t *  @type  {Boolean}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._plusNow = false;\n\t            Tone.TimeBase.call(this, val, units);\n\t        } else {\n\t            return new Tone.Time(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Time, Tone.TimeBase);\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.Time.prototype._unaryExpressions = Object.create(Tone.TimeBase.prototype._unaryExpressions);\n\t    /*\n\t\t *  Adds an additional unary expression\n\t\t *  which quantizes values to the next subdivision\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._unaryExpressions.quantize = {\n\t        regexp: /^@/,\n\t        method: function (rh) {\n\t            return Tone.Transport.nextSubdivision(rh());\n\t        }\n\t    };\n\t    /*\n\t\t *  Adds an additional unary expression\n\t\t *  which adds the current clock time.\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._unaryExpressions.now = {\n\t        regexp: /^\\+/,\n\t        method: function (lh) {\n\t            this._plusNow = true;\n\t            return lh();\n\t        }\n\t    };\n\t    /**\n\t\t *  Quantize the time by the given subdivision. Optionally add a\n\t\t *  percentage which will move the time value towards the ideal\n\t\t *  quantized value by that percentage. \n\t\t *  @param  {Number|Time}  val    The subdivision to quantize to\n\t\t *  @param  {NormalRange}  [percent=1]  Move the time value\n\t\t *                                   towards the quantized value by\n\t\t *                                   a percentage.\n\t\t *  @return  {Tone.Time}  this\n\t\t *  @example\n\t\t * Tone.Time(21).quantize(2) //returns 22\n\t\t * Tone.Time(0.6).quantize(\"4n\", 0.5) //returns 0.55\n\t\t */\n\t    Tone.Time.prototype.quantize = function (subdiv, percent) {\n\t        percent = this.defaultArg(percent, 1);\n\t        this._expr = function (expr, subdivision, percent) {\n\t            expr = expr();\n\t            subdivision = subdivision.toSeconds();\n\t            var multiple = Math.round(expr / subdivision);\n\t            var ideal = multiple * subdivision;\n\t            var diff = ideal - expr;\n\t            return expr + diff * percent;\n\t        }.bind(this, this._expr, new this.constructor(subdiv), percent);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Adds the clock time to the time expression at the \n\t\t *  moment of evaluation. \n\t\t *  @return  {Tone.Time}  this\n\t\t */\n\t    Tone.Time.prototype.addNow = function () {\n\t        this._plusNow = true;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  @override\n\t\t *  Override the default value return when no arguments are passed in.\n\t\t *  The default value is 'now'\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._defaultExpr = function () {\n\t        this._plusNow = true;\n\t        return this._noOp;\n\t    };\n\t    /**\n\t\t *  Copies the value of time to this Time\n\t\t *  @param {Tone.Time} time\n\t\t *  @return  {Time}\n\t\t */\n\t    Tone.Time.prototype.copy = function (time) {\n\t        Tone.TimeBase.prototype.copy.call(this, time);\n\t        this._plusNow = time._plusNow;\n\t        return this;\n\t    };\n\t    //CONVERSIONS//////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Convert a Time to Notation. Values will be thresholded to the nearest 128th note. \n\t\t *  @return {Notation} \n\t\t *  @example\n\t\t * //if the Transport is at 120bpm:\n\t\t * Tone.Time(2).toNotation();//returns \"1m\"\n\t\t */\n\t    Tone.Time.prototype.toNotation = function () {\n\t        var time = this.toSeconds();\n\t        var testNotations = [\n\t            '1m',\n\t            '2n',\n\t            '4n',\n\t            '8n',\n\t            '16n',\n\t            '32n',\n\t            '64n',\n\t            '128n'\n\t        ];\n\t        var retNotation = this._toNotationHelper(time, testNotations);\n\t        //try the same thing but with tripelets\n\t        var testTripletNotations = [\n\t            '1m',\n\t            '2n',\n\t            '2t',\n\t            '4n',\n\t            '4t',\n\t            '8n',\n\t            '8t',\n\t            '16n',\n\t            '16t',\n\t            '32n',\n\t            '32t',\n\t            '64n',\n\t            '64t',\n\t            '128n'\n\t        ];\n\t        var retTripletNotation = this._toNotationHelper(time, testTripletNotations);\n\t        //choose the simpler expression of the two\n\t        if (retTripletNotation.split('+').length < retNotation.split('+').length) {\n\t            return retTripletNotation;\n\t        } else {\n\t            return retNotation;\n\t        }\n\t    };\n\t    /**\n\t\t *  Helper method for Tone.toNotation\n\t\t *  @param {Number} units \n\t\t *  @param {Array} testNotations\n\t\t *  @return {String}\n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._toNotationHelper = function (units, testNotations) {\n\t        //the threshold is the last value in the array\n\t        var threshold = this._notationToUnits(testNotations[testNotations.length - 1]);\n\t        var retNotation = '';\n\t        for (var i = 0; i < testNotations.length; i++) {\n\t            var notationTime = this._notationToUnits(testNotations[i]);\n\t            //account for floating point errors (i.e. round up if the value is 0.999999)\n\t            var multiple = units / notationTime;\n\t            var floatingPointError = 0.000001;\n\t            if (1 - multiple % 1 < floatingPointError) {\n\t                multiple += floatingPointError;\n\t            }\n\t            multiple = Math.floor(multiple);\n\t            if (multiple > 0) {\n\t                if (multiple === 1) {\n\t                    retNotation += testNotations[i];\n\t                } else {\n\t                    retNotation += multiple.toString() + '*' + testNotations[i];\n\t                }\n\t                units -= multiple * notationTime;\n\t                if (units < threshold) {\n\t                    break;\n\t                } else {\n\t                    retNotation += ' + ';\n\t                }\n\t            }\n\t        }\n\t        if (retNotation === '') {\n\t            retNotation = '0';\n\t        }\n\t        return retNotation;\n\t    };\n\t    /**\n\t\t *  Convert a notation value to the current units\n\t\t *  @param  {Notation}  notation \n\t\t *  @return  {Number} \n\t\t *  @private\n\t\t */\n\t    Tone.Time.prototype._notationToUnits = function (notation) {\n\t        var primaryExprs = this._primaryExpressions;\n\t        var notationExprs = [\n\t            primaryExprs.n,\n\t            primaryExprs.t,\n\t            primaryExprs.m\n\t        ];\n\t        for (var i = 0; i < notationExprs.length; i++) {\n\t            var expr = notationExprs[i];\n\t            var match = notation.match(expr.regexp);\n\t            if (match) {\n\t                return expr.method.call(this, match[1]);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Return the time encoded as Bars:Beats:Sixteenths.\n\t\t *  @return  {BarsBeatsSixteenths}\n\t\t */\n\t    Tone.Time.prototype.toBarsBeatsSixteenths = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.toSeconds() / quarterTime;\n\t        var measures = Math.floor(quarters / this._timeSignature());\n\t        var sixteenths = quarters % 1 * 4;\n\t        quarters = Math.floor(quarters) % this._timeSignature();\n\t        sixteenths = sixteenths.toString();\n\t        if (sixteenths.length > 3) {\n\t            sixteenths = parseFloat(sixteenths).toFixed(3);\n\t        }\n\t        var progress = [\n\t            measures,\n\t            quarters,\n\t            sixteenths\n\t        ];\n\t        return progress.join(':');\n\t    };\n\t    /**\n\t\t *  Return the time in ticks.\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.Time.prototype.toTicks = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.valueOf() / quarterTime;\n\t        return Math.floor(quarters * Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Return the time in samples\n\t\t *  @return  {Samples}  \n\t\t */\n\t    Tone.Time.prototype.toSamples = function () {\n\t        return this.toSeconds() * this.context.sampleRate;\n\t    };\n\t    /**\n\t\t *  Return the time as a frequency value\n\t\t *  @return  {Frequency} \n\t\t *  @example\n\t\t * Tone.Time(2).toFrequency(); //0.5\n\t\t */\n\t    Tone.Time.prototype.toFrequency = function () {\n\t        return 1 / this.toSeconds();\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.Time.prototype.toSeconds = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the time in milliseconds.\n\t\t *  @return  {Milliseconds} \n\t\t */\n\t    Tone.Time.prototype.toMilliseconds = function () {\n\t        return this.toSeconds() * 1000;\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds} \n\t\t */\n\t    Tone.Time.prototype.valueOf = function () {\n\t        var val = this._expr();\n\t        return val + (this._plusNow ? this.now() : 0);\n\t    };\n\t    return Tone.Time;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Frequency is a primitive type for encoding Frequency values. \n\t\t *         Eventually all time values are evaluated to hertz\n\t\t *         using the `eval` method. \n\t\t *  @constructor\n\t\t *  @extends {Tone.TimeBase}\n\t\t *  @param  {String|Number}  val    The time value.\n\t\t *  @param  {String=}  units  The units of the value.\n\t\t *  @example\n\t\t * Tone.Frequency(\"C3\") // 261\n\t\t * Tone.Frequency(38, \"midi\") //\n\t\t * Tone.Frequency(\"C3\").transpose(4);\n\t\t */\n\t    Tone.Frequency = function (val, units) {\n\t        if (this instanceof Tone.Frequency) {\n\t            Tone.TimeBase.call(this, val, units);\n\t        } else {\n\t            return new Tone.Frequency(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Frequency, Tone.TimeBase);\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUGMENT BASE EXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.Frequency.prototype._primaryExpressions = Object.create(Tone.TimeBase.prototype._primaryExpressions);\n\t    /*\n\t\t *  midi type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.midi = {\n\t        regexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t        method: function (value) {\n\t            return this.midiToFrequency(value);\n\t        }\n\t    };\n\t    /*\n\t\t *  note type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.note = {\n\t        regexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t        method: function (pitch, octave) {\n\t            var index = noteToScaleIndex[pitch.toLowerCase()];\n\t            var noteNumber = index + (parseInt(octave) + 1) * 12;\n\t            return this.midiToFrequency(noteNumber);\n\t        }\n\t    };\n\t    /*\n\t\t *  BeatsBarsSixteenths type primary expression\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._primaryExpressions.tr = {\n\t        regexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t        method: function (m, q, s) {\n\t            var total = 1;\n\t            if (m && m !== '0') {\n\t                total *= this._beatsToUnits(this._timeSignature() * parseFloat(m));\n\t            }\n\t            if (q && q !== '0') {\n\t                total *= this._beatsToUnits(parseFloat(q));\n\t            }\n\t            if (s && s !== '0') {\n\t                total *= this._beatsToUnits(parseFloat(s) / 4);\n\t            }\n\t            return total;\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEXPRESSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Transposes the frequency by the given number of semitones.\n\t\t *  @param  {Interval}  interval\n\t\t *  @return  {Tone.Frequency} this\n\t\t *  @example\n\t\t * Tone.Frequency(\"A4\").transpose(3); //\"C5\"\n\t\t */\n\t    Tone.Frequency.prototype.transpose = function (interval) {\n\t        this._expr = function (expr, interval) {\n\t            var val = expr();\n\t            return val * this.intervalToFrequencyRatio(interval);\n\t        }.bind(this, this._expr, interval);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Takes an array of semitone intervals and returns\n\t\t *  an array of frequencies transposed by those intervals.\n\t\t *  @param  {Array}  intervals\n\t\t *  @return  {Tone.Frequency} this\n\t\t *  @example\n\t\t * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); //[\"A4\", \"C5\", \"E5\"]\n\t\t */\n\t    Tone.Frequency.prototype.harmonize = function (intervals) {\n\t        this._expr = function (expr, intervals) {\n\t            var val = expr();\n\t            var ret = [];\n\t            for (var i = 0; i < intervals.length; i++) {\n\t                ret[i] = val * this.intervalToFrequencyRatio(intervals[i]);\n\t            }\n\t            return ret;\n\t        }.bind(this, this._expr, intervals);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Return the value of the frequency as a MIDI note\n\t\t *  @return  {MIDI}\n\t\t *  @example\n\t\t * Tone.Frequency(\"C4\").toMidi(); //60\n\t\t */\n\t    Tone.Frequency.prototype.toMidi = function () {\n\t        return this.frequencyToMidi(this.valueOf());\n\t    };\n\t    /**\n\t\t *  Return the value of the frequency in Scientific Pitch Notation\n\t\t *  @return  {Note}\n\t\t *  @example\n\t\t * Tone.Frequency(69, \"midi\").toNote(); //\"A4\"\n\t\t */\n\t    Tone.Frequency.prototype.toNote = function () {\n\t        var freq = this.valueOf();\n\t        var log = Math.log(freq / Tone.Frequency.A4) / Math.LN2;\n\t        var noteNumber = Math.round(12 * log) + 57;\n\t        var octave = Math.floor(noteNumber / 12);\n\t        if (octave < 0) {\n\t            noteNumber += -12 * octave;\n\t        }\n\t        var noteName = scaleIndexToNote[noteNumber % 12];\n\t        return noteName + octave.toString();\n\t    };\n\t    /**\n\t\t *  Return the duration of one cycle in seconds.\n\t\t *  @return  {Seconds}\n\t\t */\n\t    Tone.Frequency.prototype.toSeconds = function () {\n\t        return 1 / this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the value in Hertz\n\t\t *  @return  {Frequency}\n\t\t */\n\t    Tone.Frequency.prototype.toFrequency = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the duration of one cycle in ticks\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.Frequency.prototype.toTicks = function () {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = this.valueOf() / quarterTime;\n\t        return Math.floor(quarters * Tone.Transport.PPQ);\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tUNIT CONVERSIONS HELPERS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value of a frequency in the current units\n\t\t *  @param {Frequency} freq\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._frequencyToUnits = function (freq) {\n\t        return freq;\n\t    };\n\t    /**\n\t\t *  Returns the value of a tick in the current time units\n\t\t *  @param {Ticks} ticks\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._ticksToUnits = function (ticks) {\n\t        return 1 / (ticks * 60 / (Tone.Transport.bpm.value * Tone.Transport.PPQ));\n\t    };\n\t    /**\n\t\t *  Return the value of the beats in the current units\n\t\t *  @param {Number} beats\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._beatsToUnits = function (beats) {\n\t        return 1 / Tone.TimeBase.prototype._beatsToUnits.call(this, beats);\n\t    };\n\t    /**\n\t\t *  Returns the value of a second in the current units\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._secondsToUnits = function (seconds) {\n\t        return 1 / seconds;\n\t    };\n\t    /**\n\t\t *  The default units if none are given.\n\t\t *  @private\n\t\t */\n\t    Tone.Frequency.prototype._defaultUnits = 'hz';\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tFREQUENCY CONVERSIONS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Note to scale index\n\t\t *  @type  {Object}\n\t\t */\n\t    var noteToScaleIndex = {\n\t        'cbb': -2,\n\t        'cb': -1,\n\t        'c': 0,\n\t        'c#': 1,\n\t        'cx': 2,\n\t        'dbb': 0,\n\t        'db': 1,\n\t        'd': 2,\n\t        'd#': 3,\n\t        'dx': 4,\n\t        'ebb': 2,\n\t        'eb': 3,\n\t        'e': 4,\n\t        'e#': 5,\n\t        'ex': 6,\n\t        'fbb': 3,\n\t        'fb': 4,\n\t        'f': 5,\n\t        'f#': 6,\n\t        'fx': 7,\n\t        'gbb': 5,\n\t        'gb': 6,\n\t        'g': 7,\n\t        'g#': 8,\n\t        'gx': 9,\n\t        'abb': 7,\n\t        'ab': 8,\n\t        'a': 9,\n\t        'a#': 10,\n\t        'ax': 11,\n\t        'bbb': 9,\n\t        'bb': 10,\n\t        'b': 11,\n\t        'b#': 12,\n\t        'bx': 13\n\t    };\n\t    /**\n\t\t *  scale index to note (sharps)\n\t\t *  @type  {Array}\n\t\t */\n\t    var scaleIndexToNote = [\n\t        'C',\n\t        'C#',\n\t        'D',\n\t        'D#',\n\t        'E',\n\t        'F',\n\t        'F#',\n\t        'G',\n\t        'G#',\n\t        'A',\n\t        'A#',\n\t        'B'\n\t    ];\n\t    /**\n\t\t *  The [concert pitch](https://en.wikipedia.org/wiki/Concert_pitch)\n\t\t *  A4's values in Hertz. \n\t\t *  @type {Frequency}\n\t\t *  @static\n\t\t */\n\t    Tone.Frequency.A4 = 440;\n\t    /**\n\t\t *  Convert a MIDI note to frequency value. \n\t\t *  @param  {MIDI} midi The midi number to convert.\n\t\t *  @return {Frequency} the corresponding frequency value\n\t\t *  @example\n\t\t * tone.midiToFrequency(69); // returns 440\n\t\t */\n\t    Tone.Frequency.prototype.midiToFrequency = function (midi) {\n\t        return Tone.Frequency.A4 * Math.pow(2, (midi - 69) / 12);\n\t    };\n\t    /**\n\t\t *  Convert a frequency value to a MIDI note.\n\t\t *  @param {Frequency} frequency The value to frequency value to convert.\n\t\t *  @returns  {MIDI}\n\t\t *  @example\n\t\t * tone.midiToFrequency(440); // returns 69\n\t\t */\n\t    Tone.Frequency.prototype.frequencyToMidi = function (frequency) {\n\t        return 69 + 12 * Math.log(frequency / Tone.Frequency.A4) / Math.LN2;\n\t    };\n\t    return Tone.Frequency;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.TransportTime is a the time along the Transport's\n\t\t *         timeline. It is similar to Tone.Time, but instead of evaluating\n\t\t *         against the AudioContext's clock, it is evaluated against\n\t\t *         the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n\t\t *  @constructor\n\t\t *  @param  {Time}  val    The time value as a number or string\n\t\t *  @param  {String=}  units  Unit values\n\t\t *  @extends {Tone.Time}\n\t\t */\n\t    Tone.TransportTime = function (val, units) {\n\t        if (this instanceof Tone.TransportTime) {\n\t            Tone.Time.call(this, val, units);\n\t        } else {\n\t            return new Tone.TransportTime(val, units);\n\t        }\n\t    };\n\t    Tone.extend(Tone.TransportTime, Tone.Time);\n\t    //clone the expressions so that \n\t    //we can add more without modifying the original\n\t    Tone.TransportTime.prototype._unaryExpressions = Object.create(Tone.Time.prototype._unaryExpressions);\n\t    /**\n\t\t *  Adds an additional unary expression\n\t\t *  which quantizes values to the next subdivision\n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.TransportTime.prototype._unaryExpressions.quantize = {\n\t        regexp: /^@/,\n\t        method: function (rh) {\n\t            var subdivision = this._secondsToTicks(rh());\n\t            var multiple = Math.ceil(Tone.Transport.ticks / subdivision);\n\t            return this._ticksToUnits(multiple * subdivision);\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert seconds into ticks\n\t\t *  @param {Seconds} seconds\n\t\t *  @return  {Ticks}\n\t\t *  @private\n\t\t */\n\t    Tone.TransportTime.prototype._secondsToTicks = function (seconds) {\n\t        var quarterTime = this._beatsToUnits(1);\n\t        var quarters = seconds / quarterTime;\n\t        return Math.round(quarters * Tone.Transport.PPQ);\n\t    };\n\t    /**\n\t\t *  Evaluate the time expression. Returns values in ticks\n\t\t *  @return {Ticks}\n\t\t */\n\t    Tone.TransportTime.prototype.valueOf = function () {\n\t        var val = this._secondsToTicks(this._expr());\n\t        return val + (this._plusNow ? Tone.Transport.ticks : 0);\n\t    };\n\t    /**\n\t\t *  Return the time in ticks.\n\t\t *  @return  {Ticks}\n\t\t */\n\t    Tone.TransportTime.prototype.toTicks = function () {\n\t        return this.valueOf();\n\t    };\n\t    /**\n\t\t *  Return the time in seconds.\n\t\t *  @return  {Seconds}\n\t\t */\n\t    Tone.TransportTime.prototype.toSeconds = function () {\n\t        var val = this._expr();\n\t        return val + (this._plusNow ? Tone.Transport.seconds : 0);\n\t    };\n\t    /**\n\t\t *  Return the time as a frequency value\n\t\t *  @return  {Frequency} \n\t\t */\n\t    Tone.TransportTime.prototype.toFrequency = function () {\n\t        return 1 / this.toSeconds();\n\t    };\n\t    return Tone.TransportTime;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Emitter gives classes which extend it\n\t\t *         the ability to listen for and emit events. \n\t\t *         Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n\t\t *         MIT (c) 2011 Jerome Etienne.\n\t\t *         \n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Emitter = function () {\n\t        /**\n\t\t\t *  Contains all of the events.\n\t\t\t *  @private\n\t\t\t *  @type  {Object}\n\t\t\t */\n\t        this._events = {};\n\t    };\n\t    Tone.extend(Tone.Emitter);\n\t    /**\n\t\t *  Bind a callback to a specific event.\n\t\t *  @param  {String}    event     The name of the event to listen for.\n\t\t *  @param  {Function}  callback  The callback to invoke when the\n\t\t *                                event is emitted\n\t\t *  @return  {Tone.Emitter}    this\n\t\t */\n\t    Tone.Emitter.prototype.on = function (event, callback) {\n\t        //split the event\n\t        var events = event.split(/\\W+/);\n\t        for (var i = 0; i < events.length; i++) {\n\t            var eventName = events[i];\n\t            if (!this._events.hasOwnProperty(eventName)) {\n\t                this._events[eventName] = [];\n\t            }\n\t            this._events[eventName].push(callback);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove the event listener.\n\t\t *  @param  {String}    event     The event to stop listening to.\n\t\t *  @param  {Function=}  callback  The callback which was bound to \n\t\t *                                the event with Tone.Emitter.on.\n\t\t *                                If no callback is given, all callbacks\n\t\t *                                events are removed.\n\t\t *  @return  {Tone.Emitter}    this\n\t\t */\n\t    Tone.Emitter.prototype.off = function (event, callback) {\n\t        var events = event.split(/\\W+/);\n\t        for (var ev = 0; ev < events.length; ev++) {\n\t            event = events[ev];\n\t            if (this._events.hasOwnProperty(event)) {\n\t                if (Tone.prototype.isUndef(callback)) {\n\t                    this._events[event] = [];\n\t                } else {\n\t                    var eventList = this._events[event];\n\t                    for (var i = 0; i < eventList.length; i++) {\n\t                        if (eventList[i] === callback) {\n\t                            eventList.splice(i, 1);\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Invoke all of the callbacks bound to the event\n\t\t *  with any arguments passed in. \n\t\t *  @param  {String}  event  The name of the event.\n\t\t *  @param {*...} args The arguments to pass to the functions listening.\n\t\t *  @return  {Tone.Emitter}  this\n\t\t */\n\t    Tone.Emitter.prototype.emit = function (event) {\n\t        if (this._events) {\n\t            var args = Array.apply(null, arguments).slice(1);\n\t            if (this._events.hasOwnProperty(event)) {\n\t                var eventList = this._events[event];\n\t                for (var i = 0, len = eventList.length; i < len; i++) {\n\t                    eventList[i].apply(this, args);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add Emitter functions (on/off/emit) to the object\n\t\t *  @param  {Object|Function}  object  The object or class to extend.\n\t\t */\n\t    Tone.Emitter.mixin = function (object) {\n\t        var functions = [\n\t            'on',\n\t            'off',\n\t            'emit'\n\t        ];\n\t        object._events = {};\n\t        for (var i = 0; i < functions.length; i++) {\n\t            var func = functions[i];\n\t            var emitterFunc = Tone.Emitter.prototype[func];\n\t            object[func] = emitterFunc;\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Emitter}  this\n\t\t */\n\t    Tone.Emitter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._events = null;\n\t        return this;\n\t    };\n\t    return Tone.Emitter;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  shim\n\t\t *  @private\n\t\t */\n\t    if (!window.hasOwnProperty('AudioContext') && window.hasOwnProperty('webkitAudioContext')) {\n\t        window.AudioContext = window.webkitAudioContext;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the native AudioContext.\n\t\t *  @extends {Tone.Emitter}\n\t\t *  @param {AudioContext=} context optionally pass in a context\n\t\t */\n\t    Tone.Context = function (context) {\n\t        Tone.Emitter.call(this);\n\t        if (!context) {\n\t            context = new window.AudioContext();\n\t        }\n\t        this._context = context;\n\t        // extend all of the methods\n\t        for (var prop in this._context) {\n\t            this._defineProperty(this._context, prop);\n\t        }\n\t        ///////////////////////////////////////////////////////////////////////\n\t        // WORKER\n\t        ///////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  The default latency hint\n\t\t\t *  @type  {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._latencyHint = 'interactive';\n\t        /**\n\t\t\t *  The amount of time events are scheduled\n\t\t\t *  into the future\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lookAhead = 0.1;\n\t        /**\n\t\t\t *  How often the update look runs\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._updateInterval = this._lookAhead / 3;\n\t        /**\n\t\t\t *  A reference to the actual computed update interval\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._computedUpdateInterval = 0;\n\t        /**\n\t\t\t *  The web worker which is used to update Tone.Clock\n\t\t\t *  @private\n\t\t\t *  @type  {WebWorker}\n\t\t\t */\n\t        this._worker = this._createWorker();\n\t        /**\n\t\t\t *  An object containing all of the constants AudioBufferSourceNodes\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._constants = {};\n\t    };\n\t    Tone.extend(Tone.Context, Tone.Emitter);\n\t    Tone.Emitter.mixin(Tone.Context);\n\t    /**\n\t\t *  Define a property on this Tone.Context. \n\t\t *  This is used to extend the native AudioContext\n\t\t *  @param  {AudioContext}  context\n\t\t *  @param  {String}  prop \n\t\t *  @private\n\t\t */\n\t    Tone.Context.prototype._defineProperty = function (context, prop) {\n\t        if (this.isUndef(this[prop])) {\n\t            Object.defineProperty(this, prop, {\n\t                get: function () {\n\t                    if (typeof context[prop] === 'function') {\n\t                        return context[prop].bind(context);\n\t                    } else {\n\t                        return context[prop];\n\t                    }\n\t                },\n\t                set: function (val) {\n\t                    context[prop] = val;\n\t                }\n\t            });\n\t        }\n\t    };\n\t    /**\n\t\t *  The current audio context time\n\t\t *  @return  {Number}\n\t\t */\n\t    Tone.Context.prototype.now = function () {\n\t        return this._context.currentTime;\n\t    };\n\t    /**\n\t\t *  Generate a web worker\n\t\t *  @return  {WebWorker}\n\t\t *  @private\n\t\t */\n\t    Tone.Context.prototype._createWorker = function () {\n\t        //URL Shim\n\t        window.URL = window.URL || window.webkitURL;\n\t        var blob = new Blob([//the initial timeout time\n\t            'var timeoutTime = ' + (this._updateInterval * 1000).toFixed(1) + ';' + //onmessage callback\n\t            'self.onmessage = function(msg){' + '\\ttimeoutTime = parseInt(msg.data);' + '};' + //the tick function which posts a message\n\t            //and schedules a new tick\n\t            'function tick(){' + '\\tsetTimeout(tick, timeoutTime);' + '\\tself.postMessage(\\'tick\\');' + '}' + //call tick initially\n\t            'tick();']);\n\t        var blobUrl = URL.createObjectURL(blob);\n\t        var worker = new Worker(blobUrl);\n\t        worker.addEventListener('message', function () {\n\t            // tick the clock\n\t            this.emit('tick');\n\t        }.bind(this));\n\t        //lag compensation\n\t        worker.addEventListener('message', function () {\n\t            var now = this.now();\n\t            if (this.isNumber(this._lastUpdate)) {\n\t                var diff = now - this._lastUpdate;\n\t                this._computedUpdateInterval = Math.max(diff, this._computedUpdateInterval * 0.97);\n\t            }\n\t            this._lastUpdate = now;\n\t        }.bind(this));\n\t        return worker;\n\t    };\n\t    /**\n\t\t *  Generate a looped buffer at some constant value.\n\t\t *  @param  {Number}  val\n\t\t *  @return  {BufferSourceNode}\n\t\t */\n\t    Tone.Context.prototype.getConstant = function (val) {\n\t        if (this._constants[val]) {\n\t            return this._constants[val];\n\t        } else {\n\t            var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\t            var arr = buffer.getChannelData(0);\n\t            for (var i = 0; i < arr.length; i++) {\n\t                arr[i] = val;\n\t            }\n\t            var constant = this._context.createBufferSource();\n\t            constant.channelCount = 1;\n\t            constant.channelCountMode = 'explicit';\n\t            constant.buffer = buffer;\n\t            constant.loop = true;\n\t            constant.start(0);\n\t            this._constants[val] = constant;\n\t            return constant;\n\t        }\n\t    };\n\t    /**\n\t\t *  This is the time that the clock is falling behind\n\t\t *  the scheduled update interval. The Context automatically\n\t\t *  adjusts for the lag and schedules further in advance.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name lag\n\t\t *  @static\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'lag', {\n\t        get: function () {\n\t            var diff = this._computedUpdateInterval - this._updateInterval;\n\t            diff = Math.max(diff, 0);\n\t            return diff;\n\t        }\n\t    });\n\t    /**\n\t\t *  The amount of time in advance that events are scheduled.\n\t\t *  The lookAhead will adjust slightly in response to the \n\t\t *  measured update time to try to avoid clicks.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name lookAhead\n\t\t *  @static\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'lookAhead', {\n\t        get: function () {\n\t            return this._lookAhead;\n\t        },\n\t        set: function (lA) {\n\t            this._lookAhead = lA;\n\t        }\n\t    });\n\t    /**\n\t\t *  How often the Web Worker callback is invoked.\n\t\t *  This number corresponds to how responsive the scheduling\n\t\t *  can be. Context.updateInterval + Context.lookAhead gives you the\n\t\t *  total latency between scheduling an event and hearing it.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Context\n\t\t *  @name updateInterval\n\t\t *  @static\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'updateInterval', {\n\t        get: function () {\n\t            return this._updateInterval;\n\t        },\n\t        set: function (interval) {\n\t            this._updateInterval = Math.max(interval, Tone.prototype.blockTime);\n\t            this._worker.postMessage(Math.max(interval * 1000, 1));\n\t        }\n\t    });\n\t    /**\n\t\t *  The type of playback, which affects tradeoffs between audio \n\t\t *  output latency and responsiveness. \n\t\t *  \n\t\t *  In addition to setting the value in seconds, the latencyHint also\n\t\t *  accepts the strings \"interactive\" (prioritizes low latency), \n\t\t *  \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t\t *  latency and performance), and \"fastest\" (lowest latency, might glitch more often). \n\t\t *  @type {String|Seconds}\n\t\t *  @memberOf Tone.Context#\n\t\t *  @name latencyHint\n\t\t *  @static\n\t\t *  @example\n\t\t * //set the lookAhead to 0.3 seconds\n\t\t * Tone.context.latencyHint = 0.3;\n\t\t */\n\t    Object.defineProperty(Tone.Context.prototype, 'latencyHint', {\n\t        get: function () {\n\t            return this._latencyHint;\n\t        },\n\t        set: function (hint) {\n\t            var lookAhead = hint;\n\t            this._latencyHint = hint;\n\t            if (this.isString(hint)) {\n\t                switch (hint) {\n\t                case 'interactive':\n\t                    lookAhead = 0.1;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'playback':\n\t                    lookAhead = 0.8;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'balanced':\n\t                    lookAhead = 0.25;\n\t                    this._context.latencyHint = hint;\n\t                    break;\n\t                case 'fastest':\n\t                    lookAhead = 0.01;\n\t                    break;\n\t                }\n\t            }\n\t            this.lookAhead = lookAhead;\n\t            this.updateInterval = lookAhead / 3;\n\t        }\n\t    });\n\t    /**\n\t\t *  Shim all connect/disconnect and some deprecated methods which are still in\n\t\t *  some older implementations.\n\t\t *  @private\n\t\t */\n\t    function shimConnect() {\n\t        var nativeConnect = AudioNode.prototype.connect;\n\t        var nativeDisconnect = AudioNode.prototype.disconnect;\n\t        //replace the old connect method\n\t        function toneConnect(B, outNum, inNum) {\n\t            if (B.input) {\n\t                if (Array.isArray(B.input)) {\n\t                    if (Tone.prototype.isUndef(inNum)) {\n\t                        inNum = 0;\n\t                    }\n\t                    this.connect(B.input[inNum]);\n\t                } else {\n\t                    this.connect(B.input, outNum, inNum);\n\t                }\n\t            } else {\n\t                try {\n\t                    if (B instanceof AudioNode) {\n\t                        nativeConnect.call(this, B, outNum, inNum);\n\t                    } else {\n\t                        nativeConnect.call(this, B, outNum);\n\t                    }\n\t                } catch (e) {\n\t                    throw new Error('error connecting to node: ' + B + '\\n' + e);\n\t                }\n\t            }\n\t        }\n\t        //replace the old disconnect method\n\t        function toneDisconnect(B, outNum, inNum) {\n\t            if (B && B.input && Array.isArray(B.input)) {\n\t                if (Tone.prototype.isUndef(inNum)) {\n\t                    inNum = 0;\n\t                }\n\t                this.disconnect(B.input[inNum], outNum, inNum);\n\t            } else if (B && B.input) {\n\t                this.disconnect(B.input, outNum, inNum);\n\t            } else {\n\t                try {\n\t                    nativeDisconnect.apply(this, arguments);\n\t                } catch (e) {\n\t                    throw new Error('error disconnecting node: ' + B + '\\n' + e);\n\t                }\n\t            }\n\t        }\n\t        if (AudioNode.prototype.connect !== toneConnect) {\n\t            AudioNode.prototype.connect = toneConnect;\n\t            AudioNode.prototype.disconnect = toneDisconnect;\n\t        }\n\t    }\n\t    // set the audio context initially\n\t    if (Tone.supported) {\n\t        shimConnect();\n\t        Tone.context = new Tone.Context();\n\t    } else {\n\t        console.warn('This browser does not support Tone.js');\n\t    }\n\t    return Tone.Context;\n\t});\n\tModule(function (Tone) {\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tTYPES\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t * Units which a value can take on.\n\t\t * @enum {String}\n\t\t */\n\t    Tone.Type = {\n\t        /** \n\t\t\t *  Default units\n\t\t\t *  @typedef {Default}\n\t\t\t */\n\t        Default: 'number',\n\t        /**\n\t\t\t *  Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).\n\t\t\t *\n\t\t\t *  <ul>\n\t\t\t *  <li>Numbers, which will be taken literally as the time (in seconds).</li>\n\t\t\t *  <li>Notation, (\"4n\", \"8t\") describes time in BPM and time signature relative values.</li>\n\t\t\t *  <li>TransportTime, (\"4:3:2\") will also provide tempo and time signature relative times \n\t\t\t *  in the form BARS:QUARTERS:SIXTEENTHS.</li>\n\t\t\t *  <li>Frequency, (\"8hz\") is converted to the length of the cycle in seconds.</li>\n\t\t\t *  <li>Now-Relative, (\"+1\") prefix any of the above with \"+\" and it will be interpreted as \n\t\t\t *  \"the current time plus whatever expression follows\".</li>\n\t\t\t *  <li>Expressions, (\"3:0 + 2 - (1m / 7)\") any of the above can also be combined \n\t\t\t *  into a mathematical expression which will be evaluated to compute the desired time.</li>\n\t\t\t *  <li>No Argument, for methods which accept time, no argument will be interpreted as \n\t\t\t *  \"now\" (i.e. the currentTime).</li>\n\t\t\t *  </ul>\n\t\t\t *  \n\t\t\t *  @typedef {Time}\n\t\t\t */\n\t        Time: 'time',\n\t        /**\n\t\t\t *  Frequency can be described similar to time, except ultimately the\n\t\t\t *  values are converted to frequency instead of seconds. A number\n\t\t\t *  is taken literally as the value in hertz. Additionally any of the \n\t\t\t *  Time encodings can be used. Note names in the form\n\t\t\t *  of NOTE OCTAVE (i.e. C4) are also accepted and converted to their\n\t\t\t *  frequency value. \n\t\t\t *  @typedef {Frequency}\n\t\t\t */\n\t        Frequency: 'frequency',\n\t        /**\n\t\t\t *  TransportTime describes a position along the Transport's timeline. It is\n\t\t\t *  similar to Time in that it uses all the same encodings, but TransportTime specifically\n\t\t\t *  pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable. \n\t\t\t *  [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)\n\t\t\t *  @typedef {TransportTime}\n\t\t\t */\n\t        TransportTime: 'transportTime',\n\t        /** \n\t\t\t *  Ticks are the basic subunit of the Transport. They are\n\t\t\t *  the smallest unit of time that the Transport supports.\n\t\t\t *  @typedef {Ticks}\n\t\t\t */\n\t        Ticks: 'ticks',\n\t        /** \n\t\t\t *  Normal values are within the range [0, 1].\n\t\t\t *  @typedef {NormalRange}\n\t\t\t */\n\t        NormalRange: 'normalRange',\n\t        /** \n\t\t\t *  AudioRange values are between [-1, 1].\n\t\t\t *  @typedef {AudioRange}\n\t\t\t */\n\t        AudioRange: 'audioRange',\n\t        /** \n\t\t\t *  Decibels are a logarithmic unit of measurement which is useful for volume\n\t\t\t *  because of the logarithmic way that we perceive loudness. 0 decibels \n\t\t\t *  means no change in volume. -10db is approximately half as loud and 10db \n\t\t\t *  is twice is loud. \n\t\t\t *  @typedef {Decibels}\n\t\t\t */\n\t        Decibels: 'db',\n\t        /** \n\t\t\t *  Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.\n\t\t\t *  @typedef {Interval}\n\t\t\t */\n\t        Interval: 'interval',\n\t        /** \n\t\t\t *  Beats per minute. \n\t\t\t *  @typedef {BPM}\n\t\t\t */\n\t        BPM: 'bpm',\n\t        /** \n\t\t\t *  The value must be greater than or equal to 0.\n\t\t\t *  @typedef {Positive}\n\t\t\t */\n\t        Positive: 'positive',\n\t        /** \n\t\t\t *  A cent is a hundredth of a semitone. \n\t\t\t *  @typedef {Cents}\n\t\t\t */\n\t        Cents: 'cents',\n\t        /** \n\t\t\t *  Angle between 0 and 360. \n\t\t\t *  @typedef {Degrees}\n\t\t\t */\n\t        Degrees: 'degrees',\n\t        /** \n\t\t\t *  A number representing a midi note.\n\t\t\t *  @typedef {MIDI}\n\t\t\t */\n\t        MIDI: 'midi',\n\t        /** \n\t\t\t *  A colon-separated representation of time in the form of\n\t\t\t *  Bars:Beats:Sixteenths. \n\t\t\t *  @typedef {BarsBeatsSixteenths}\n\t\t\t */\n\t        BarsBeatsSixteenths: 'barsBeatsSixteenths',\n\t        /** \n\t\t\t *  Sampling is the reduction of a continuous signal to a discrete signal.\n\t\t\t *  Audio is typically sampled 44100 times per second. \n\t\t\t *  @typedef {Samples}\n\t\t\t */\n\t        Samples: 'samples',\n\t        /** \n\t\t\t *  Hertz are a frequency representation defined as one cycle per second.\n\t\t\t *  @typedef {Hertz}\n\t\t\t */\n\t        Hertz: 'hertz',\n\t        /** \n\t\t\t *  A frequency represented by a letter name, \n\t\t\t *  accidental and octave. This system is known as\n\t\t\t *  [Scientific Pitch Notation](https://en.wikipedia.org/wiki/Scientific_pitch_notation).\n\t\t\t *  @typedef {Note}\n\t\t\t */\n\t        Note: 'note',\n\t        /** \n\t\t\t *  One millisecond is a thousandth of a second. \n\t\t\t *  @typedef {Milliseconds}\n\t\t\t */\n\t        Milliseconds: 'milliseconds',\n\t        /** \n\t\t\t *  Seconds are the time unit of the AudioContext. In the end, \n\t\t\t *  all values need to be evaluated to seconds. \n\t\t\t *  @typedef {Seconds}\n\t\t\t */\n\t        Seconds: 'seconds',\n\t        /** \n\t\t\t *  A string representing a duration relative to a measure. \n\t\t\t *  <ul>\n\t\t\t *  \t<li>\"4n\" = quarter note</li>\n\t\t\t *   \t<li>\"2m\" = two measures</li>\n\t\t\t *    \t<li>\"8t\" = eighth-note triplet</li>\n\t\t\t *  </ul>\n\t\t\t *  @typedef {Notation}\n\t\t\t */\n\t        Notation: 'notation'\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // AUGMENT TONE's PROTOTYPE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Convert Time into seconds.\n\t\t *  \n\t\t *  Unlike the method which it overrides, this takes into account \n\t\t *  transporttime and musical notation.\n\t\t *\n\t\t *  Time : 1.40\n\t\t *  Notation: 4n|1m|2t\n\t\t *  Now Relative: +3n\n\t\t *  Math: 3n+16n or even complicated expressions ((3n*2)/6 + 1)\n\t\t *\n\t\t *  @param  {Time} time \n\t\t *  @return {Seconds} \n\t\t */\n\t    Tone.prototype.toSeconds = function (time) {\n\t        if (this.isNumber(time)) {\n\t            return time;\n\t        } else if (this.isUndef(time)) {\n\t            return this.now();\n\t        } else if (this.isString(time)) {\n\t            return new Tone.Time(time).toSeconds();\n\t        } else if (time instanceof Tone.TimeBase) {\n\t            return time.toSeconds();\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert a frequency representation into a number.\n\t\t *  @param  {Frequency} freq \n\t\t *  @return {Hertz}      the frequency in hertz\n\t\t */\n\t    Tone.prototype.toFrequency = function (freq) {\n\t        if (this.isNumber(freq)) {\n\t            return freq;\n\t        } else if (this.isString(freq) || this.isUndef(freq)) {\n\t            return new Tone.Frequency(freq).valueOf();\n\t        } else if (freq instanceof Tone.TimeBase) {\n\t            return freq.toFrequency();\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert a time representation into ticks.\n\t\t *  @param  {Time} time\n\t\t *  @return {Ticks}  the time in ticks\n\t\t */\n\t    Tone.prototype.toTicks = function (time) {\n\t        if (this.isNumber(time) || this.isString(time)) {\n\t            return new Tone.TransportTime(time).toTicks();\n\t        } else if (this.isUndef(time)) {\n\t            return Tone.Transport.ticks;\n\t        } else if (time instanceof Tone.TimeBase) {\n\t            return time.toTicks();\n\t        }\n\t    };\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Param wraps the native Web Audio's AudioParam to provide\n\t\t *         additional unit conversion functionality. It also\n\t\t *         serves as a base-class for classes which have a single,\n\t\t *         automatable parameter. \n\t\t *  @extends {Tone}\n\t\t *  @param  {AudioParam}  param  The parameter to wrap.\n\t\t *  @param  {Tone.Type} units The units of the audio param.\n\t\t *  @param  {Boolean} convert If the param should be converted.\n\t\t */\n\t    Tone.Param = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'param',\n\t            'units',\n\t            'convert'\n\t        ], Tone.Param.defaults);\n\t        /**\n\t\t\t *  The native parameter to control\n\t\t\t *  @type  {AudioParam}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input = options.param;\n\t        /**\n\t\t\t *  The units of the parameter\n\t\t\t *  @type {Tone.Type}\n\t\t\t */\n\t        this.units = options.units;\n\t        /**\n\t\t\t *  If the value should be converted or not\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.convert = options.convert;\n\t        /**\n\t\t\t *  True if the signal value is being overridden by \n\t\t\t *  a connected signal.\n\t\t\t *  @readOnly\n\t\t\t *  @type  {boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this.overridden = false;\n\t        /**\n\t\t\t *  If there is an LFO, this is where it is held.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = null;\n\t        if (this.isObject(options.lfo)) {\n\t            this.value = options.lfo;\n\t        } else if (!this.isUndef(options.value)) {\n\t            this.value = options.value;\n\t        }\n\t    };\n\t    Tone.extend(Tone.Param);\n\t    /**\n\t\t *  Defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Param.defaults = {\n\t        'units': Tone.Type.Default,\n\t        'convert': true,\n\t        'param': undefined\n\t    };\n\t    /**\n\t\t * The current value of the parameter. \n\t\t * @memberOf Tone.Param#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Param.prototype, 'value', {\n\t        get: function () {\n\t            return this._toUnits(this._param.value);\n\t        },\n\t        set: function (value) {\n\t            if (this.isObject(value)) {\n\t                //throw an error if the LFO needs to be included\n\t                if (this.isUndef(Tone.LFO)) {\n\t                    throw new Error('Include \\'Tone.LFO\\' to use an LFO as a Param value.');\n\t                }\n\t                //remove the old one\n\t                if (this._lfo) {\n\t                    this._lfo.dispose();\n\t                }\n\t                this._lfo = new Tone.LFO(value).start();\n\t                this._lfo.connect(this.input);\n\t            } else {\n\t                var convertedVal = this._fromUnits(value);\n\t                this._param.cancelScheduledValues(0);\n\t                this._param.value = convertedVal;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Convert the given value from the type specified by Tone.Param.units\n\t\t *  into the destination value (such as Gain or Frequency).\n\t\t *  @private\n\t\t *  @param  {*} val the value to convert\n\t\t *  @return {number}     the number which the value should be set to\n\t\t */\n\t    Tone.Param.prototype._fromUnits = function (val) {\n\t        if (this.convert || this.isUndef(this.convert)) {\n\t            switch (this.units) {\n\t            case Tone.Type.Time:\n\t                return this.toSeconds(val);\n\t            case Tone.Type.Frequency:\n\t                return this.toFrequency(val);\n\t            case Tone.Type.Decibels:\n\t                return this.dbToGain(val);\n\t            case Tone.Type.NormalRange:\n\t                return Math.min(Math.max(val, 0), 1);\n\t            case Tone.Type.AudioRange:\n\t                return Math.min(Math.max(val, -1), 1);\n\t            case Tone.Type.Positive:\n\t                return Math.max(val, 0);\n\t            default:\n\t                return val;\n\t            }\n\t        } else {\n\t            return val;\n\t        }\n\t    };\n\t    /**\n\t\t * Convert the parameters value into the units specified by Tone.Param.units.\n\t\t * @private\n\t\t * @param  {number} val the value to convert\n\t\t * @return {number}\n\t\t */\n\t    Tone.Param.prototype._toUnits = function (val) {\n\t        if (this.convert || this.isUndef(this.convert)) {\n\t            switch (this.units) {\n\t            case Tone.Type.Decibels:\n\t                return this.gainToDb(val);\n\t            default:\n\t                return val;\n\t            }\n\t        } else {\n\t            return val;\n\t        }\n\t    };\n\t    /**\n\t\t *  the minimum output value\n\t\t *  @type {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Param.prototype._minOutput = 0.00001;\n\t    /**\n\t\t *  Schedules a parameter value change at the given time.\n\t\t *  @param {*}\tvalue The value to set the signal.\n\t\t *  @param {Time}  time The time when the change should occur.\n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //set the frequency to \"G4\" in exactly 1 second from now. \n\t\t * freq.setValueAtTime(\"G4\", \"+1\");\n\t\t */\n\t    Tone.Param.prototype.setValueAtTime = function (value, time) {\n\t        value = this._fromUnits(value);\n\t        time = this.toSeconds(time);\n\t        if (time <= this.now() + this.blockTime) {\n\t            this._param.value = value;\n\t        } else {\n\t            this._param.setValueAtTime(value, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Creates a schedule point with the current value at the current time.\n\t\t *  This is useful for creating an automation anchor point in order to \n\t\t *  schedule changes from the current value. \n\t\t *\n\t\t *  @param {number=} now (Optionally) pass the now value in. \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.setRampPoint = function (now) {\n\t        now = this.defaultArg(now, this.now());\n\t        var currentVal = this._param.value;\n\t        // exponentialRampToValueAt cannot ever ramp from or to 0\n\t        // More info: https://bugzilla.mozilla.org/show_bug.cgi?id=1125600#c2\n\t        if (currentVal === 0) {\n\t            currentVal = this._minOutput;\n\t        }\n\t        this._param.setValueAtTime(currentVal, now);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules a linear continuous change in parameter value from the \n\t\t *  previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.linearRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        this._param.linearRampToValueAtTime(value, this.toSeconds(endTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        value = Math.max(this._minOutput, value);\n\t        this._param.exponentialRampToValueAtTime(value, this.toSeconds(endTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the current time and current value to the given value over the \n\t\t *  duration of the rampTime.\n\t\t *  \n\t\t *  @param  {number} value   The value to ramp to.\n\t\t *  @param  {Time} rampTime the time that it takes the \n\t\t *                               value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //exponentially ramp to the value 2 over 4 seconds. \n\t\t * signal.exponentialRampToValue(2, 4);\n\t\t */\n\t    Tone.Param.prototype.exponentialRampToValue = function (value, rampTime, startTime) {\n\t        startTime = this.toSeconds(startTime);\n\t        this.setRampPoint(startTime);\n\t        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an linear continuous change in parameter value from \n\t\t *  the current time and current value to the given value over the \n\t\t *  duration of the rampTime.\n\t\t *  \n\t\t *  @param  {number} value   The value to ramp to.\n\t\t *  @param  {Time} rampTime the time that it takes the \n\t\t *                               value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //linearly ramp to the value 4 over 3 seconds. \n\t\t * signal.linearRampToValue(4, 3);\n\t\t */\n\t    Tone.Param.prototype.linearRampToValue = function (value, rampTime, startTime) {\n\t        startTime = this.toSeconds(startTime);\n\t        this.setRampPoint(startTime);\n\t        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start exponentially approaching the target value at the given time with\n\t\t *  a rate having the given time constant.\n\t\t *  @param {number} value        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {number} timeConstant \n\t\t *  @returns {Tone.Param} this \n\t\t */\n\t    Tone.Param.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n\t        value = this._fromUnits(value);\n\t        // The value will never be able to approach without timeConstant > 0.\n\t        // http://www.w3.org/TR/webaudio/#dfn-setTargetAtTime, where the equation\n\t        // is described. 0 results in a division by 0.\n\t        value = Math.max(this._minOutput, value);\n\t        timeConstant = Math.max(this._minOutput, timeConstant);\n\t        this._param.setTargetAtTime(value, this.toSeconds(startTime), timeConstant);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets an array of arbitrary parameter values starting at the given time\n\t\t *  for the given duration.\n\t\t *  \t\n\t\t *  @param {Array} values    \n\t\t *  @param {Time} startTime \n\t\t *  @param {Time} duration  \n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.setValueCurveAtTime = function (values, startTime, duration) {\n\t        for (var i = 0; i < values.length; i++) {\n\t            values[i] = this._fromUnits(values[i]);\n\t        }\n\t        this._param.setValueCurveAtTime(values, this.toSeconds(startTime), this.toSeconds(duration));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled parameter changes with times greater than or \n\t\t *  equal to startTime.\n\t\t *  \n\t\t *  @param  {Time} startTime\n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.cancelScheduledValues = function (startTime) {\n\t        this._param.cancelScheduledValues(this.toSeconds(startTime));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Ramps to the given value over the duration of the rampTime. \n\t\t *  Automatically selects the best ramp type (exponential or linear)\n\t\t *  depending on the `units` of the signal\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} rampTime \tThe time that it takes the \n\t\t *                              value to ramp from it's current value\n\t\t *  @param {Time}\t[startTime=now] \tWhen the ramp should start. \n\t\t *  @returns {Tone.Param} this\n\t\t *  @example\n\t\t * //ramp to the value either linearly or exponentially \n\t\t * //depending on the \"units\" value of the signal\n\t\t * signal.rampTo(0, 10);\n\t\t *  @example\n\t\t * //schedule it to ramp starting at a specific time\n\t\t * signal.rampTo(0, 10, 5)\n\t\t */\n\t    Tone.Param.prototype.rampTo = function (value, rampTime, startTime) {\n\t        rampTime = this.defaultArg(rampTime, 0);\n\t        if (this.units === Tone.Type.Frequency || this.units === Tone.Type.BPM || this.units === Tone.Type.Decibels) {\n\t            this.exponentialRampToValue(value, rampTime, startTime);\n\t        } else {\n\t            this.linearRampToValue(value, rampTime, startTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The LFO created by the signal instance. If none\n\t\t *  was created, this is null.\n\t\t *  @type {Tone.LFO}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Param#\n\t\t *  @name lfo\n\t\t */\n\t    Object.defineProperty(Tone.Param.prototype, 'lfo', {\n\t        get: function () {\n\t            return this._lfo;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.Param} this\n\t\t */\n\t    Tone.Param.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._param = null;\n\t        if (this._lfo) {\n\t            this._lfo.dispose();\n\t            this._lfo = null;\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Param;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  createGain shim\n\t\t *  @private\n\t\t */\n\t    if (window.GainNode && !AudioContext.prototype.createGain) {\n\t        AudioContext.prototype.createGain = AudioContext.prototype.createGainNode;\n\t    }\n\t    /**\n\t\t *  @class A thin wrapper around the Native Web Audio GainNode.\n\t\t *         The GainNode is a basic building block of the Web Audio\n\t\t *         API and is useful for routing audio and adjusting gains. \n\t\t *  @extends {Tone}\n\t\t *  @param  {Number=}  gain  The initial gain of the GainNode\n\t\t *  @param {Tone.Type=} units The units of the gain parameter. \n\t\t */\n\t    Tone.Gain = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'gain',\n\t            'units'\n\t        ], Tone.Gain.defaults);\n\t        /**\n\t\t\t *  The GainNode\n\t\t\t *  @type  {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = this.output = this._gainNode = this.context.createGain();\n\t        /**\n\t\t\t *  The gain parameter of the gain node.\n\t\t\t *  @type {Tone.Param}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.gain = new Tone.Param({\n\t            'param': this._gainNode.gain,\n\t            'units': options.units,\n\t            'value': options.gain,\n\t            'convert': options.convert\n\t        });\n\t        this._readOnly('gain');\n\t    };\n\t    Tone.extend(Tone.Gain);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Gain.defaults = {\n\t        'gain': 1,\n\t        'convert': true\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Gain}  this\n\t\t */\n\t    Tone.Gain.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._gainNode.disconnect();\n\t        this._gainNode = null;\n\t        this._writable('gain');\n\t        this.gain.dispose();\n\t        this.gain = null;\n\t    };\n\t    //STATIC///////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Create input and outputs for this object.\n\t\t *  @param  {Number}  input   The number of inputs\n\t\t *  @param  {Number=}  outputs  The number of outputs\n\t\t *  @return  {Tone}  this\n\t\t *  @internal\n\t\t */\n\t    Tone.prototype.createInsOuts = function (inputs, outputs) {\n\t        if (inputs === 1) {\n\t            this.input = new Tone.Gain();\n\t        } else if (inputs > 1) {\n\t            this.input = new Array(inputs);\n\t        }\n\t        if (outputs === 1) {\n\t            this.output = new Tone.Gain();\n\t        } else if (outputs > 1) {\n\t            this.output = new Array(inputs);\n\t        }\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    return Tone.Gain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A signal is an audio-rate value. Tone.Signal is a core component of the library.\n\t\t *          Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n\t\t *          has all of the methods available to native Web Audio \n\t\t *          [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n\t\t *          as well as additional conveniences. Read more about working with signals \n\t\t *          [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Param}\n\t\t *  @param {Number|AudioParam} [value] Initial value of the signal. If an AudioParam\n\t\t *                                     is passed in, that parameter will be wrapped\n\t\t *                                     and controlled by the Signal. \n\t\t *  @param {string} [units=Number] unit The units the signal is in. \n\t\t *  @example\n\t\t * var signal = new Tone.Signal(10);\n\t\t */\n\t    Tone.Signal = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'value',\n\t            'units'\n\t        ], Tone.Signal.defaults);\n\t        /**\n\t\t\t * The node where the constant signal value is scaled.\n\t\t\t * @type {GainNode}\n\t\t\t * @private\n\t\t\t */\n\t        this.output = this._gain = this.context.createGain();\n\t        options.param = this._gain.gain;\n\t        Tone.Param.call(this, options);\n\t        /**\n\t\t\t * The node where the value is set.\n\t\t\t * @type {Tone.Param}\n\t\t\t * @private\n\t\t\t */\n\t        this.input = this._param = this._gain.gain;\n\t        //connect the const output to the node output\n\t        this.context.getConstant(1).chain(this._gain);\n\t    };\n\t    Tone.extend(Tone.Signal, Tone.Param);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Signal.defaults = {\n\t        'value': 0,\n\t        'units': Tone.Type.Default,\n\t        'convert': true\n\t    };\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t *  @method\n\t\t */\n\t    Tone.Signal.prototype.connect = Tone.SignalBase.prototype.connect;\n\t    /**\n\t\t *  dispose and disconnect\n\t\t *  @returns {Tone.Signal} this\n\t\t */\n\t    Tone.Signal.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._param = null;\n\t        this._gain.disconnect();\n\t        this._gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Signal;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A Timeline class for scheduling and maintaining state\n\t\t *         along a timeline. All events must have a \"time\" property. \n\t\t *         Internally, events are stored in time order for fast \n\t\t *         retrieval.\n\t\t *  @extends {Tone}\n\t\t *  @param {Positive} [memory=Infinity] The number of previous events that are retained.\n\t\t */\n\t    Tone.Timeline = function () {\n\t        var options = this.optionsObject(arguments, ['memory'], Tone.Timeline.defaults);\n\t        /**\n\t\t\t *  The array of scheduled timeline events\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeline = [];\n\t        /**\n\t\t\t *  An array of items to remove from the list. \n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._toRemove = [];\n\t        /**\n\t\t\t *  Flag if the tieline is mid iteration\n\t\t\t *  @private\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this._iterating = false;\n\t        /**\n\t\t\t *  The memory of the timeline, i.e.\n\t\t\t *  how many events in the past it will retain\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this.memory = options.memory;\n\t    };\n\t    Tone.extend(Tone.Timeline);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Timeline.defaults = { 'memory': Infinity };\n\t    /**\n\t\t *  The number of items in the timeline.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Timeline#\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Timeline.prototype, 'length', {\n\t        get: function () {\n\t            return this._timeline.length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t\t *  @param  {Object}  event  The event object to insert into the \n\t\t *                           timeline. \n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.add = function (event) {\n\t        //the event needs to have a time attribute\n\t        if (this.isUndef(event.time)) {\n\t            throw new Error('Tone.Timeline: events must have a time attribute');\n\t        }\n\t        if (this._timeline.length) {\n\t            var index = this._search(event.time);\n\t            this._timeline.splice(index + 1, 0, event);\n\t        } else {\n\t            this._timeline.push(event);\n\t        }\n\t        //if the length is more than the memory, remove the previous ones\n\t        if (this.length > this.memory) {\n\t            var diff = this.length - this.memory;\n\t            this._timeline.splice(0, diff);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove an event from the timeline.\n\t\t *  @param  {Object}  event  The event object to remove from the list.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.remove = function (event) {\n\t        if (this._iterating) {\n\t            this._toRemove.push(event);\n\t        } else {\n\t            var index = this._timeline.indexOf(event);\n\t            if (index !== -1) {\n\t                this._timeline.splice(index, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the nearest event whose time is less than or equal to the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object set after that time.\n\t\t */\n\t    Tone.Timeline.prototype.get = function (time) {\n\t        var index = this._search(time);\n\t        if (index !== -1) {\n\t            return this._timeline[index];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Return the first event in the timeline without removing it\n\t\t *  @returns {Object} The first event object\n\t\t */\n\t    Tone.Timeline.prototype.peek = function () {\n\t        return this._timeline[0];\n\t    };\n\t    /**\n\t\t *  Return the first event in the timeline and remove it\n\t\t *  @returns {Object} The first event object\n\t\t */\n\t    Tone.Timeline.prototype.shift = function () {\n\t        return this._timeline.shift();\n\t    };\n\t    /**\n\t\t *  Get the event which is scheduled after the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object after the given time\n\t\t */\n\t    Tone.Timeline.prototype.getAfter = function (time) {\n\t        var index = this._search(time);\n\t        if (index + 1 < this._timeline.length) {\n\t            return this._timeline[index + 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Get the event before the event at the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Object} The event object before the given time\n\t\t */\n\t    Tone.Timeline.prototype.getBefore = function (time) {\n\t        var len = this._timeline.length;\n\t        //if it's after the last item, return the last item\n\t        if (len > 0 && this._timeline[len - 1].time < time) {\n\t            return this._timeline[len - 1];\n\t        }\n\t        var index = this._search(time);\n\t        if (index - 1 >= 0) {\n\t            return this._timeline[index - 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Cancel events after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.cancel = function (after) {\n\t        if (this._timeline.length > 1) {\n\t            var index = this._search(after);\n\t            if (index >= 0) {\n\t                if (this._timeline[index].time === after) {\n\t                    //get the first item with that time\n\t                    for (var i = index; i >= 0; i--) {\n\t                        if (this._timeline[i].time === after) {\n\t                            index = i;\n\t                        } else {\n\t                            break;\n\t                        }\n\t                    }\n\t                    this._timeline = this._timeline.slice(0, index);\n\t                } else {\n\t                    this._timeline = this._timeline.slice(0, index + 1);\n\t                }\n\t            } else {\n\t                this._timeline = [];\n\t            }\n\t        } else if (this._timeline.length === 1) {\n\t            //the first item's time\n\t            if (this._timeline[0].time >= after) {\n\t                this._timeline = [];\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel events before or equal to the given time.\n\t\t *  @param  {Number}  time  The time to cancel before.\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.cancelBefore = function (time) {\n\t        if (this._timeline.length) {\n\t            var index = this._search(time);\n\t            if (index >= 0) {\n\t                this._timeline = this._timeline.slice(index + 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Does a binary serach on the timeline array and returns the \n\t\t *  nearest event index whose time is after or equal to the given time.\n\t\t *  If a time is searched before the first index in the timeline, -1 is returned.\n\t\t *  If the time is after the end, the index of the last item is returned.\n\t\t *  @param  {Number}  time  \n\t\t *  @return  {Number} the index in the timeline array \n\t\t *  @private\n\t\t */\n\t    Tone.Timeline.prototype._search = function (time) {\n\t        var beginning = 0;\n\t        var len = this._timeline.length;\n\t        var end = len;\n\t        if (len > 0 && this._timeline[len - 1].time <= time) {\n\t            return len - 1;\n\t        }\n\t        while (beginning < end) {\n\t            // calculate the midpoint for roughly equal partition\n\t            var midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t            var event = this._timeline[midPoint];\n\t            var nextEvent = this._timeline[midPoint + 1];\n\t            if (event.time === time) {\n\t                //choose the last one that has the same time\n\t                for (var i = midPoint; i < this._timeline.length; i++) {\n\t                    var testEvent = this._timeline[i];\n\t                    if (testEvent.time === time) {\n\t                        midPoint = i;\n\t                    }\n\t                }\n\t                return midPoint;\n\t            } else if (event.time < time && nextEvent.time > time) {\n\t                return midPoint;\n\t            } else if (event.time > time) {\n\t                //search lower\n\t                end = midPoint;\n\t            } else if (event.time < time) {\n\t                //search upper\n\t                beginning = midPoint + 1;\n\t            }\n\t        }\n\t        return -1;\n\t    };\n\t    /**\n\t\t *  Internal iterator. Applies extra safety checks for \n\t\t *  removing items from the array. \n\t\t *  @param  {Function}  callback \n\t\t *  @param  {Number=}    lowerBound     \n\t\t *  @param  {Number=}    upperBound    \n\t\t *  @private\n\t\t */\n\t    Tone.Timeline.prototype._iterate = function (callback, lowerBound, upperBound) {\n\t        this._iterating = true;\n\t        lowerBound = this.defaultArg(lowerBound, 0);\n\t        upperBound = this.defaultArg(upperBound, this._timeline.length - 1);\n\t        for (var i = lowerBound; i <= upperBound; i++) {\n\t            callback(this._timeline[i]);\n\t        }\n\t        this._iterating = false;\n\t        if (this._toRemove.length > 0) {\n\t            for (var j = 0; j < this._toRemove.length; j++) {\n\t                var index = this._timeline.indexOf(this._toRemove[j]);\n\t                if (index !== -1) {\n\t                    this._timeline.splice(index, 1);\n\t                }\n\t            }\n\t            this._toRemove = [];\n\t        }\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEach = function (callback) {\n\t        this._iterate(callback);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at or before the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachBefore = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var upperBound = this._search(time);\n\t        if (upperBound !== -1) {\n\t            this._iterate(callback, 0, upperBound);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array after the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachAfter = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var lowerBound = this._search(time);\n\t        this._iterate(callback, lowerBound + 1);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at or after the given time. Similar to \n\t\t *  forEachAfter, but includes the item(s) at the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachFrom = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var lowerBound = this._search(time);\n\t        //work backwards until the event time is less than time\n\t        while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t            lowerBound--;\n\t        }\n\t        this._iterate(callback, lowerBound + 1);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array at the given time\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.Timeline} this\n\t\t */\n\t    Tone.Timeline.prototype.forEachAtTime = function (time, callback) {\n\t        //iterate over the items in reverse so that removing an item doesn't break things\n\t        var upperBound = this._search(time);\n\t        if (upperBound !== -1) {\n\t            this._iterate(function (event) {\n\t                if (event.time === time) {\n\t                    callback(event);\n\t                }\n\t            }, 0, upperBound);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Timeline}  this\n\t\t */\n\t    Tone.Timeline.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._timeline = null;\n\t        this._toRemove = null;\n\t    };\n\t    return Tone.Timeline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A signal which adds the method getValueAtTime. \n\t\t *         Code and inspiration from https://github.com/jsantell/web-audio-automation-timeline\n\t\t *  @extends {Tone.Param}\n\t\t *  @param {Number=} value The initial value of the signal\n\t\t *  @param {String=} units The conversion units of the signal.\n\t\t */\n\t    Tone.TimelineSignal = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'value',\n\t            'units'\n\t        ], Tone.Signal.defaults);\n\t        /**\n\t\t\t *  The scheduled events\n\t\t\t *  @type {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = new Tone.Timeline(10);\n\t        //constructors\n\t        Tone.Signal.apply(this, options);\n\t        options.param = this._param;\n\t        Tone.Param.call(this, options);\n\t        /**\n\t\t\t *  The initial scheduled value\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._initial = this._fromUnits(this._param.value);\n\t    };\n\t    Tone.extend(Tone.TimelineSignal, Tone.Param);\n\t    /**\n\t\t *  The event types of a schedulable signal.\n\t\t *  @enum {String}\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.Type = {\n\t        Linear: 'linear',\n\t        Exponential: 'exponential',\n\t        Target: 'target',\n\t        Curve: 'curve',\n\t        Set: 'set'\n\t    };\n\t    /**\n\t\t * The current value of the signal. \n\t\t * @memberOf Tone.TimelineSignal#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.TimelineSignal.prototype, 'value', {\n\t        get: function () {\n\t            var now = this.now();\n\t            var val = this.getValueAtTime(now);\n\t            return this._toUnits(val);\n\t        },\n\t        set: function (value) {\n\t            var convertedVal = this._fromUnits(value);\n\t            this._initial = convertedVal;\n\t            this.cancelScheduledValues();\n\t            this._param.value = convertedVal;\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tSCHEDULING\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Schedules a parameter value change at the given time.\n\t\t *  @param {*}\tvalue The value to set the signal.\n\t\t *  @param {Time}  time The time when the change should occur.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t *  @example\n\t\t * //set the frequency to \"G4\" in exactly 1 second from now. \n\t\t * freq.setValueAtTime(\"G4\", \"+1\");\n\t\t */\n\t    Tone.TimelineSignal.prototype.setValueAtTime = function (value, startTime) {\n\t        value = this._fromUnits(value);\n\t        startTime = this.toSeconds(startTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Set,\n\t            'value': value,\n\t            'time': startTime\n\t        });\n\t        //invoke the original event\n\t        this._param.setValueAtTime(value, startTime);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules a linear continuous change in parameter value from the \n\t\t *  previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.linearRampToValueAtTime = function (value, endTime) {\n\t        value = this._fromUnits(value);\n\t        endTime = this.toSeconds(endTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Linear,\n\t            'value': value,\n\t            'time': endTime\n\t        });\n\t        this._param.linearRampToValueAtTime(value, endTime);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Schedules an exponential continuous change in parameter value from \n\t\t *  the previous scheduled parameter value to the given value.\n\t\t *  \n\t\t *  @param  {number} value   \n\t\t *  @param  {Time} endTime \n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.exponentialRampToValueAtTime = function (value, endTime) {\n\t        //get the previous event and make sure it's not starting from 0\n\t        endTime = this.toSeconds(endTime);\n\t        var beforeEvent = this._searchBefore(endTime);\n\t        if (beforeEvent && beforeEvent.value === 0) {\n\t            //reschedule that event\n\t            this.setValueAtTime(this._minOutput, beforeEvent.time);\n\t        }\n\t        value = this._fromUnits(value);\n\t        var setValue = Math.max(value, this._minOutput);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Exponential,\n\t            'value': setValue,\n\t            'time': endTime\n\t        });\n\t        //if the ramped to value is 0, make it go to the min output, and then set to 0.\n\t        if (value < this._minOutput) {\n\t            this._param.exponentialRampToValueAtTime(this._minOutput, endTime - this.sampleTime);\n\t            this.setValueAtTime(0, endTime);\n\t        } else {\n\t            this._param.exponentialRampToValueAtTime(value, endTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start exponentially approaching the target value at the given time with\n\t\t *  a rate having the given time constant.\n\t\t *  @param {number} value        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {number} timeConstant \n\t\t *  @returns {Tone.TimelineSignal} this \n\t\t */\n\t    Tone.TimelineSignal.prototype.setTargetAtTime = function (value, startTime, timeConstant) {\n\t        value = this._fromUnits(value);\n\t        value = Math.max(this._minOutput, value);\n\t        timeConstant = Math.max(this._minOutput, timeConstant);\n\t        startTime = this.toSeconds(startTime);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Target,\n\t            'value': value,\n\t            'time': startTime,\n\t            'constant': timeConstant\n\t        });\n\t        this._param.setTargetAtTime(value, startTime, timeConstant);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set an array of arbitrary values starting at the given time for the given duration.\n\t\t *  @param {Float32Array} values        \n\t\t *  @param {Time} startTime    \n\t\t *  @param {Time} duration\n\t\t *  @param {NormalRange} [scaling=1] If the values in the curve should be scaled by some value\n\t\t *  @returns {Tone.TimelineSignal} this \n\t\t */\n\t    Tone.TimelineSignal.prototype.setValueCurveAtTime = function (values, startTime, duration, scaling) {\n\t        scaling = this.defaultArg(scaling, 1);\n\t        //copy the array\n\t        var floats = new Array(values.length);\n\t        for (var i = 0; i < floats.length; i++) {\n\t            floats[i] = this._fromUnits(values[i]) * scaling;\n\t        }\n\t        startTime = this.toSeconds(startTime);\n\t        duration = this.toSeconds(duration);\n\t        this._events.add({\n\t            'type': Tone.TimelineSignal.Type.Curve,\n\t            'value': floats,\n\t            'time': startTime,\n\t            'duration': duration\n\t        });\n\t        //set the first value\n\t        this._param.setValueAtTime(floats[0], startTime);\n\t        //schedule a lienar ramp for each of the segments\n\t        for (var j = 1; j < floats.length; j++) {\n\t            var segmentTime = startTime + j / (floats.length - 1) * duration;\n\t            this._param.linearRampToValueAtTime(floats[j], segmentTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled parameter changes with times greater than or \n\t\t *  equal to startTime.\n\t\t *  \n\t\t *  @param  {Time} startTime\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.cancelScheduledValues = function (after) {\n\t        after = this.toSeconds(after);\n\t        this._events.cancel(after);\n\t        this._param.cancelScheduledValues(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the computed value at the given time. This provides\n\t\t *  a point from which a linear or exponential curve\n\t\t *  can be scheduled after. Will cancel events after \n\t\t *  the given time and shorten the currently scheduled\n\t\t *  linear or exponential ramp so that it ends at `time` .\n\t\t *  This is to avoid discontinuities and clicks in envelopes. \n\t\t *  @param {Time} time When to set the ramp point\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.setRampPoint = function (time) {\n\t        time = this.toSeconds(time);\n\t        //get the value at the given time\n\t        var val = this._toUnits(this.getValueAtTime(time));\n\t        //if there is an event at the given time\n\t        //and that even is not a \"set\"\n\t        var before = this._searchBefore(time);\n\t        if (before && before.time === time) {\n\t            //remove everything after\n\t            this.cancelScheduledValues(time + this.sampleTime);\n\t        } else if (before && before.type === Tone.TimelineSignal.Type.Curve && before.time + before.duration > time) {\n\t            //if the curve is still playing\n\t            //cancel the curve\n\t            this.cancelScheduledValues(time);\n\t            this.linearRampToValueAtTime(val, time);\n\t        } else {\n\t            //reschedule the next event to end at the given time\n\t            var after = this._searchAfter(time);\n\t            if (after) {\n\t                //cancel the next event(s)\n\t                this.cancelScheduledValues(time);\n\t                if (after.type === Tone.TimelineSignal.Type.Linear) {\n\t                    this.linearRampToValueAtTime(val, time);\n\t                } else if (after.type === Tone.TimelineSignal.Type.Exponential) {\n\t                    this.exponentialRampToValueAtTime(val, time);\n\t                }\n\t            }\n\t            this.setValueAtTime(val, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Do a linear ramp to the given value between the start and finish times.\n\t\t *  @param {Number} value The value to ramp to.\n\t\t *  @param {Time} start The beginning anchor point to do the linear ramp\n\t\t *  @param {Time} finish The ending anchor point by which the value of\n\t\t *                       the signal will equal the given value.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.linearRampToValueBetween = function (value, start, finish) {\n\t        this.setRampPoint(start);\n\t        this.linearRampToValueAtTime(value, finish);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Do a exponential ramp to the given value between the start and finish times.\n\t\t *  @param {Number} value The value to ramp to.\n\t\t *  @param {Time} start The beginning anchor point to do the exponential ramp\n\t\t *  @param {Time} finish The ending anchor point by which the value of\n\t\t *                       the signal will equal the given value.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.exponentialRampToValueBetween = function (value, start, finish) {\n\t        this.setRampPoint(start);\n\t        this.exponentialRampToValueAtTime(value, finish);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tGETTING SCHEDULED VALUES\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the value before or equal to the given time\n\t\t *  @param  {Number}  time  The time to query\n\t\t *  @return  {Object}  The event at or before the given time.\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._searchBefore = function (time) {\n\t        return this._events.get(time);\n\t    };\n\t    /**\n\t\t *  The event after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @return  {Object}  The next event after the given time\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._searchAfter = function (time) {\n\t        return this._events.getAfter(time);\n\t    };\n\t    /**\n\t\t *  Get the scheduled value at the given time. This will\n\t\t *  return the unconverted (raw) value.\n\t\t *  @param  {Number}  time  The time in seconds.\n\t\t *  @return  {Number}  The scheduled value at the given time.\n\t\t */\n\t    Tone.TimelineSignal.prototype.getValueAtTime = function (time) {\n\t        time = this.toSeconds(time);\n\t        var after = this._searchAfter(time);\n\t        var before = this._searchBefore(time);\n\t        var value = this._initial;\n\t        //if it was set by\n\t        if (before === null) {\n\t            value = this._initial;\n\t        } else if (before.type === Tone.TimelineSignal.Type.Target) {\n\t            var previous = this._events.getBefore(before.time);\n\t            var previouVal;\n\t            if (previous === null) {\n\t                previouVal = this._initial;\n\t            } else {\n\t                previouVal = previous.value;\n\t            }\n\t            value = this._exponentialApproach(before.time, previouVal, before.value, before.constant, time);\n\t        } else if (before.type === Tone.TimelineSignal.Type.Curve) {\n\t            value = this._curveInterpolate(before.time, before.value, before.duration, time);\n\t        } else if (after === null) {\n\t            value = before.value;\n\t        } else if (after.type === Tone.TimelineSignal.Type.Linear) {\n\t            value = this._linearInterpolate(before.time, before.value, after.time, after.value, time);\n\t        } else if (after.type === Tone.TimelineSignal.Type.Exponential) {\n\t            value = this._exponentialInterpolate(before.time, before.value, after.time, after.value, time);\n\t        } else {\n\t            value = before.value;\n\t        }\n\t        return value;\n\t    };\n\t    /**\n\t\t *  When signals connect to other signals or AudioParams, \n\t\t *  they take over the output value of that signal or AudioParam. \n\t\t *  For all other nodes, the behavior is the same as a default <code>connect</code>. \n\t\t *\n\t\t *  @override\n\t\t *  @param {AudioParam|AudioNode|Tone.Signal|Tone} node \n\t\t *  @param {number} [outputNumber=0] The output number to connect from.\n\t\t *  @param {number} [inputNumber=0] The input number to connect to.\n\t\t *  @returns {Tone.TimelineSignal} this\n\t\t *  @method\n\t\t */\n\t    Tone.TimelineSignal.prototype.connect = Tone.SignalBase.prototype.connect;\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUTOMATION CURVE CALCULATIONS\n\t    //\tMIT License, copyright (c) 2014 Jordan Santell\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Calculates the the value along the curve produced by setTargetAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._exponentialApproach = function (t0, v0, v1, timeConstant, t) {\n\t        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by linearRampToValueAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._linearInterpolate = function (t0, v0, t1, v1, t) {\n\t        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._exponentialInterpolate = function (t0, v0, t1, v1, t) {\n\t        v0 = Math.max(this._minOutput, v0);\n\t        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t    };\n\t    /**\n\t\t *  Calculates the the value along the curve produced by setValueCurveAtTime\n\t\t *  @private\n\t\t */\n\t    Tone.TimelineSignal.prototype._curveInterpolate = function (start, curve, duration, time) {\n\t        var len = curve.length;\n\t        // If time is after duration, return the last curve value\n\t        if (time >= start + duration) {\n\t            return curve[len - 1];\n\t        } else if (time <= start) {\n\t            return curve[0];\n\t        } else {\n\t            var progress = (time - start) / duration;\n\t            var lowerIndex = Math.floor((len - 1) * progress);\n\t            var upperIndex = Math.ceil((len - 1) * progress);\n\t            var lowerVal = curve[lowerIndex];\n\t            var upperVal = curve[upperIndex];\n\t            if (upperIndex === lowerIndex) {\n\t                return lowerVal;\n\t            } else {\n\t                return this._linearInterpolate(lowerIndex, lowerVal, upperIndex, upperVal, progress * (len - 1));\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.TimelineSignal} this\n\t\t */\n\t    Tone.TimelineSignal.prototype.dispose = function () {\n\t        Tone.Signal.prototype.dispose.call(this);\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._events.dispose();\n\t        this._events = null;\n\t    };\n\t    return Tone.TimelineSignal;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Pow applies an exponent to the incoming signal. The incoming signal\n\t\t *         must be AudioRange.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {Positive} exp The exponent to apply to the incoming signal, must be at least 2. \n\t\t *  @example\n\t\t * var pow = new Tone.Pow(2);\n\t\t * var sig = new Tone.Signal(0.5).connect(pow);\n\t\t * //output of pow is 0.25. \n\t\t */\n\t    Tone.Pow = function (exp) {\n\t        /**\n\t\t\t * the exponent\n\t\t\t * @private\n\t\t\t * @type {number}\n\t\t\t */\n\t        this._exp = this.defaultArg(exp, 1);\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._expScaler = this.input = this.output = new Tone.WaveShaper(this._expFunc(this._exp), 8192);\n\t    };\n\t    Tone.extend(Tone.Pow, Tone.SignalBase);\n\t    /**\n\t\t * The value of the exponent.\n\t\t * @memberOf Tone.Pow#\n\t\t * @type {number}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Pow.prototype, 'value', {\n\t        get: function () {\n\t            return this._exp;\n\t        },\n\t        set: function (exp) {\n\t            this._exp = exp;\n\t            this._expScaler.setMap(this._expFunc(this._exp));\n\t        }\n\t    });\n\t    /**\n\t\t *  the function which maps the waveshaper\n\t\t *  @param   {number} exp\n\t\t *  @return {function}\n\t\t *  @private\n\t\t */\n\t    Tone.Pow.prototype._expFunc = function (exp) {\n\t        return function (val) {\n\t            return Math.pow(Math.abs(val), exp);\n\t        };\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Pow} this\n\t\t */\n\t    Tone.Pow.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._expScaler.dispose();\n\t        this._expScaler = null;\n\t        return this;\n\t    };\n\t    return Tone.Pow;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n\t\t *          envelope generator. Tone.Envelope outputs a signal which \n\t\t *          can be connected to an AudioParam or Tone.Signal. \n\t\t *          <img src=\"https://upload.wikimedia.org/wikipedia/commons/e/ea/ADSR_parameter.svg\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Time} [attack] The amount of time it takes for the envelope to go from \n\t\t *                         0 to it's maximum value. \n\t\t *  @param {Time} [decay]\tThe period of time after the attack that it takes for the envelope\n\t\t *                       \tto fall to the sustain value. \n\t\t *  @param {NormalRange} [sustain]\tThe percent of the maximum value that the envelope rests at until\n\t\t *                                \tthe release is triggered. \n\t\t *  @param {Time} [release]\tThe amount of time after the release is triggered it takes to reach 0. \n\t\t *  @example\n\t\t * //an amplitude envelope\n\t\t * var gainNode = Tone.context.createGain();\n\t\t * var env = new Tone.Envelope({\n\t\t * \t\"attack\" : 0.1,\n\t\t * \t\"decay\" : 0.2,\n\t\t * \t\"sustain\" : 1,\n\t\t * \t\"release\" : 0.8,\n\t\t * });\n\t\t * env.connect(gainNode.gain);\n\t\t */\n\t    Tone.Envelope = function () {\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        /** \n\t\t\t *  When triggerAttack is called, the attack time is the amount of\n\t\t\t *  time it takes for the envelope to reach it's maximum value. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.attack = options.attack;\n\t        /**\n\t\t\t *  After the attack portion of the envelope, the value will fall\n\t\t\t *  over the duration of the decay time to it's sustain value. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.decay = options.decay;\n\t        /**\n\t\t\t * \tThe sustain value is the value \n\t\t\t * \twhich the envelope rests at after triggerAttack is\n\t\t\t * \tcalled, but before triggerRelease is invoked. \n\t\t\t *  @type {NormalRange}\n\t\t\t */\n\t        this.sustain = options.sustain;\n\t        /**\n\t\t\t *  After triggerRelease is called, the envelope's\n\t\t\t *  value will fall to it's miminum value over the\n\t\t\t *  duration of the release time. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.release = options.release;\n\t        /**\n\t\t\t *  the next time the envelope is at standby\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._attackCurve = 'linear';\n\t        /**\n\t\t\t *  the next time the envelope is at standby\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._releaseCurve = 'exponential';\n\t        /**\n\t\t\t *  the signal\n\t\t\t *  @type {Tone.TimelineSignal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sig = this.output = new Tone.TimelineSignal();\n\t        this._sig.setValueAtTime(0, 0);\n\t        //set the attackCurve initially\n\t        this.attackCurve = options.attackCurve;\n\t        this.releaseCurve = options.releaseCurve;\n\t    };\n\t    Tone.extend(Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Envelope.defaults = {\n\t        'attack': 0.01,\n\t        'decay': 0.1,\n\t        'sustain': 0.5,\n\t        'release': 1,\n\t        'attackCurve': 'linear',\n\t        'releaseCurve': 'exponential'\n\t    };\n\t    /**\n\t\t * Read the current value of the envelope. Useful for \n\t\t * syncronizing visual output to the envelope. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'value', {\n\t        get: function () {\n\t            return this.getValueAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t * The shape of the attack. \n\t\t * Can be any of these strings:\n\t\t * <ul>\n\t\t *   <li>linear</li>\n\t\t *   <li>exponential</li>\n\t\t *   <li>sine</li>\n\t\t *   <li>cosine</li>\n\t\t *   <li>bounce</li>\n\t\t *   <li>ripple</li>\n\t\t *   <li>step</li>\n\t\t * </ul>\n\t\t * Can also be an array which describes the curve. Values\n\t\t * in the array are evenly subdivided and linearly\n\t\t * interpolated over the duration of the attack. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {String|Array}\n\t\t * @name attackCurve\n\t\t * @example\n\t\t * env.attackCurve = \"linear\";\n\t\t * @example\n\t\t * //can also be an array\n\t\t * env.attackCurve = [0, 0.2, 0.3, 0.4, 1]\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'attackCurve', {\n\t        get: function () {\n\t            if (this.isString(this._attackCurve)) {\n\t                return this._attackCurve;\n\t            } else if (this.isArray(this._attackCurve)) {\n\t                //look up the name in the curves array\n\t                for (var type in Tone.Envelope.Type) {\n\t                    if (Tone.Envelope.Type[type].In === this._attackCurve) {\n\t                        return type;\n\t                    }\n\t                }\n\t                //otherwise just return the array\n\t                return this._attackCurve;\n\t            }\n\t        },\n\t        set: function (curve) {\n\t            //check if it's a valid type\n\t            if (Tone.Envelope.Type.hasOwnProperty(curve)) {\n\t                var curveDef = Tone.Envelope.Type[curve];\n\t                if (this.isObject(curveDef)) {\n\t                    this._attackCurve = curveDef.In;\n\t                } else {\n\t                    this._attackCurve = curveDef;\n\t                }\n\t            } else if (this.isArray(curve)) {\n\t                this._attackCurve = curve;\n\t            } else {\n\t                throw new Error('Tone.Envelope: invalid curve: ' + curve);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The shape of the release. See the attack curve types. \n\t\t * @memberOf Tone.Envelope#\n\t\t * @type {String|Array}\n\t\t * @name releaseCurve\n\t\t * @example\n\t\t * env.releaseCurve = \"linear\";\n\t\t */\n\t    Object.defineProperty(Tone.Envelope.prototype, 'releaseCurve', {\n\t        get: function () {\n\t            if (this.isString(this._releaseCurve)) {\n\t                return this._releaseCurve;\n\t            } else if (this.isArray(this._releaseCurve)) {\n\t                //look up the name in the curves array\n\t                for (var type in Tone.Envelope.Type) {\n\t                    if (Tone.Envelope.Type[type].Out === this._releaseCurve) {\n\t                        return type;\n\t                    }\n\t                }\n\t                //otherwise just return the array\n\t                return this._releaseCurve;\n\t            }\n\t        },\n\t        set: function (curve) {\n\t            //check if it's a valid type\n\t            if (Tone.Envelope.Type.hasOwnProperty(curve)) {\n\t                var curveDef = Tone.Envelope.Type[curve];\n\t                if (this.isObject(curveDef)) {\n\t                    this._releaseCurve = curveDef.Out;\n\t                } else {\n\t                    this._releaseCurve = curveDef;\n\t                }\n\t            } else if (this.isArray(curve)) {\n\t                this._releaseCurve = curve;\n\t            } else {\n\t                throw new Error('Tone.Envelope: invalid curve: ' + curve);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Trigger the attack/decay portion of the ADSR envelope. \n\t\t *  @param  {Time} [time=now] When the attack should start.\n\t\t *  @param {NormalRange} [velocity=1] The velocity of the envelope scales the vales.\n\t\t *                               number between 0-1\n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t *  //trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t\t *  env.triggerAttack(\"+0.5\", 0.2);\n\t\t */\n\t    Tone.Envelope.prototype.triggerAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        var originalAttack = this.toSeconds(this.attack);\n\t        var attack = originalAttack;\n\t        var decay = this.toSeconds(this.decay);\n\t        velocity = this.defaultArg(velocity, 1);\n\t        //check if it's not a complete attack\n\t        var currentValue = this.getValueAtTime(time);\n\t        if (currentValue > 0) {\n\t            //subtract the current value from the attack time\n\t            var attackRate = 1 / attack;\n\t            var remainingDistance = 1 - currentValue;\n\t            //the attack is now the remaining time\n\t            attack = remainingDistance / attackRate;\n\t        }\n\t        //attack\n\t        if (this._attackCurve === 'linear') {\n\t            this._sig.linearRampToValue(velocity, attack, time);\n\t        } else if (this._attackCurve === 'exponential') {\n\t            this._sig.exponentialRampToValue(velocity, attack, time);\n\t        } else if (attack > 0) {\n\t            this._sig.setRampPoint(time);\n\t            var curve = this._attackCurve;\n\t            //take only a portion of the curve\n\t            if (attack < originalAttack) {\n\t                var percentComplete = 1 - attack / originalAttack;\n\t                var sliceIndex = Math.floor(percentComplete * this._attackCurve.length);\n\t                curve = this._attackCurve.slice(sliceIndex);\n\t                //the first index is the current value\n\t                curve[0] = currentValue;\n\t            }\n\t            this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t        }\n\t        //decay\n\t        this._sig.exponentialRampToValue(velocity * this.sustain, decay, attack + time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Triggers the release of the envelope.\n\t\t *  @param  {Time} [time=now] When the release portion of the envelope should start. \n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t *  //trigger release immediately\n\t\t *  env.triggerRelease();\n\t\t */\n\t    Tone.Envelope.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        var currentValue = this.getValueAtTime(time);\n\t        if (currentValue > 0) {\n\t            var release = this.toSeconds(this.release);\n\t            if (this._releaseCurve === 'linear') {\n\t                this._sig.linearRampToValue(0, release, time);\n\t            } else if (this._releaseCurve === 'exponential') {\n\t                this._sig.exponentialRampToValue(0, release, time);\n\t            } else {\n\t                var curve = this._releaseCurve;\n\t                if (this.isArray(curve)) {\n\t                    this._sig.setRampPoint(time);\n\t                    this._sig.setValueCurveAtTime(curve, time, release, currentValue);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the scheduled value at the given time. This will\n\t\t *  return the unconverted (raw) value.\n\t\t *  @param  {Number}  time  The time in seconds.\n\t\t *  @return  {Number}  The scheduled value at the given time.\n\t\t */\n\t    Tone.Envelope.prototype.getValueAtTime = function (time) {\n\t        return this._sig.getValueAtTime(time);\n\t    };\n\t    /**\n\t\t *  triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t\t *  some duration, then triggerRelease. \n\t\t *  @param {Time} duration The duration of the sustain.\n\t\t *  @param {Time} [time=now] When the attack should be triggered.\n\t\t *  @param {number} [velocity=1] The velocity of the envelope. \n\t\t *  @returns {Tone.Envelope} this\n\t\t *  @example\n\t\t * //trigger the attack and then the release after 0.6 seconds.\n\t\t * env.triggerAttackRelease(0.6);\n\t\t */\n\t    Tone.Envelope.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + this.toSeconds(duration));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancels all scheduled envelope changes after the given time.\n\t\t *  @param  {Time} after\n\t\t *  @returns {Tone.Envelope} this\n\t\t */\n\t    Tone.Envelope.prototype.cancel = function (after) {\n\t        this._sig.cancelScheduledValues(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Borrows the connect method from Tone.Signal. \n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.Envelope.prototype.connect = Tone.Signal.prototype.connect;\n\t    /**\n\t \t *  Generate some complex envelope curves. \n\t \t */\n\t    (function _createCurves() {\n\t        var curveLen = 128;\n\t        var i, k;\n\t        //cosine curve\n\t        var cosineCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n\t        }\n\t        //ripple curve\n\t        var rippleCurve = [];\n\t        var rippleCurveFreq = 6.4;\n\t        for (i = 0; i < curveLen - 1; i++) {\n\t            k = i / (curveLen - 1);\n\t            var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t            rippleCurve[i] = sineWave / 10 + k * 0.83;\n\t        }\n\t        rippleCurve[curveLen - 1] = 1;\n\t        //stairs curve\n\t        var stairsCurve = [];\n\t        var steps = 5;\n\t        for (i = 0; i < curveLen; i++) {\n\t            stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n\t        }\n\t        //in-out easing curve\n\t        var sineCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            k = i / (curveLen - 1);\n\t            sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t        }\n\t        //a bounce curve\n\t        var bounceCurve = [];\n\t        for (i = 0; i < curveLen; i++) {\n\t            k = i / (curveLen - 1);\n\t            var freq = Math.pow(k, 3) * 4 + 0.2;\n\t            var val = Math.cos(freq * Math.PI * 2 * k);\n\t            bounceCurve[i] = Math.abs(val * (1 - k));\n\t        }\n\t        /**\n\t\t\t *  Invert a value curve to make it work for the release\n\t\t\t *  @private\n\t\t\t */\n\t        function invertCurve(curve) {\n\t            var out = new Array(curve.length);\n\t            for (var j = 0; j < curve.length; j++) {\n\t                out[j] = 1 - curve[j];\n\t            }\n\t            return out;\n\t        }\n\t        /**\n\t\t\t *  reverse the curve\n\t\t\t *  @private\n\t\t\t */\n\t        function reverseCurve(curve) {\n\t            return curve.slice(0).reverse();\n\t        }\n\t        /**\n\t\t\t *  attack and release curve arrays\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        Tone.Envelope.Type = {\n\t            'linear': 'linear',\n\t            'exponential': 'exponential',\n\t            'bounce': {\n\t                In: invertCurve(bounceCurve),\n\t                Out: bounceCurve\n\t            },\n\t            'cosine': {\n\t                In: cosineCurve,\n\t                Out: reverseCurve(cosineCurve)\n\t            },\n\t            'step': {\n\t                In: stairsCurve,\n\t                Out: invertCurve(stairsCurve)\n\t            },\n\t            'ripple': {\n\t                In: rippleCurve,\n\t                Out: invertCurve(rippleCurve)\n\t            },\n\t            'sine': {\n\t                In: sineCurve,\n\t                Out: invertCurve(sineCurve)\n\t            }\n\t        };\n\t    }());\n\t    /**\n\t\t *  Disconnect and dispose.\n\t\t *  @returns {Tone.Envelope} this\n\t\t */\n\t    Tone.Envelope.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sig.dispose();\n\t        this._sig = null;\n\t        this._attackCurve = null;\n\t        this._releaseCurve = null;\n\t        return this;\n\t    };\n\t    return Tone.Envelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.AmplitudeEnvelope is a Tone.Envelope connected to a gain node. \n\t\t *          Unlike Tone.Envelope, which outputs the envelope's value, Tone.AmplitudeEnvelope accepts\n\t\t *          an audio signal as the input and will apply the envelope to the amplitude\n\t\t *          of the signal. Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @param {Time|Object} [attack] The amount of time it takes for the envelope to go from \n\t\t *                               0 to it's maximum value. \n\t\t *  @param {Time} [decay]\tThe period of time after the attack that it takes for the envelope\n\t\t *                       \tto fall to the sustain value. \n\t\t *  @param {NormalRange} [sustain]\tThe percent of the maximum value that the envelope rests at until\n\t\t *                                \tthe release is triggered. \n\t\t *  @param {Time} [release]\tThe amount of time after the release is triggered it takes to reach 0. \n\t\t *  @example\n\t\t * var ampEnv = new Tone.AmplitudeEnvelope({\n\t\t * \t\"attack\": 0.1,\n\t\t * \t\"decay\": 0.2,\n\t\t * \t\"sustain\": 1.0,\n\t\t * \t\"release\": 0.8\n\t\t * }).toMaster();\n\t\t * //create an oscillator and connect it\n\t\t * var osc = new Tone.Oscillator().connect(ampEnv).start();\n\t\t * //trigger the envelopes attack and release \"8t\" apart\n\t\t * ampEnv.triggerAttackRelease(\"8t\");\n\t\t */\n\t    Tone.AmplitudeEnvelope = function () {\n\t        Tone.Envelope.apply(this, arguments);\n\t        /**\n\t\t\t *  the input node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = this.output = new Tone.Gain();\n\t        this._sig.connect(this.output.gain);\n\t    };\n\t    Tone.extend(Tone.AmplitudeEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.AmplitudeEnvelope}  this\n\t\t */\n\t    Tone.AmplitudeEnvelope.prototype.dispose = function () {\n\t        this.input.dispose();\n\t        this.input = null;\n\t        Tone.Envelope.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.AmplitudeEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  AnalyserNode.getFloatTimeDomainData polyfill\n\t\t *  @private\n\t\t */\n\t    if (window.AnalyserNode && !AnalyserNode.prototype.getFloatTimeDomainData) {\n\t        //referenced https://github.com/mohayonao/get-float-time-domain-data \n\t        AnalyserNode.prototype.getFloatTimeDomainData = function (array) {\n\t            var uint8 = new Uint8Array(array.length);\n\t            this.getByteTimeDomainData(uint8);\n\t            for (var i = 0; i < uint8.length; i++) {\n\t                array[i] = (uint8[i] - 128) / 128;\n\t            }\n\t        };\n\t    }\n\t    /**\n\t\t *  @class  Wrapper around the native Web Audio's \n\t\t *          [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n\t\t *          Extracts FFT or Waveform data from the incoming signal.\n\t\t *  @extends {Tone}\n\t\t *  @param {String=} type The return type of the analysis, either \"fft\", or \"waveform\". \n\t\t *  @param {Number=} size The size of the FFT. Value must be a power of \n\t\t *                       two in the range 32 to 32768.\n\t\t */\n\t    Tone.Analyser = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'type',\n\t            'size'\n\t        ], Tone.Analyser.defaults);\n\t        /**\n\t\t\t *  The analyser node.\n\t\t\t *  @private\n\t\t\t *  @type {AnalyserNode}\n\t\t\t */\n\t        this._analyser = this.input = this.output = this.context.createAnalyser();\n\t        /**\n\t\t\t *  The analysis type\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The return type of the analysis\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._returnType = options.returnType;\n\t        /**\n\t\t\t *  The buffer that the FFT data is written to\n\t\t\t *  @type {TypedArray}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = null;\n\t        //set the values initially\n\t        this.size = options.size;\n\t        this.type = options.type;\n\t        this.returnType = options.returnType;\n\t        this.minDecibels = options.minDecibels;\n\t        this.maxDecibels = options.maxDecibels;\n\t    };\n\t    Tone.extend(Tone.Analyser);\n\t    /**\n\t\t *  The default values.\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Analyser.defaults = {\n\t        'size': 1024,\n\t        'returnType': 'byte',\n\t        'type': 'fft',\n\t        'smoothing': 0.8,\n\t        'maxDecibels': -30,\n\t        'minDecibels': -100\n\t    };\n\t    /**\n\t\t *  Possible return types of Tone.Analyser.analyse()\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Analyser.Type = {\n\t        Waveform: 'waveform',\n\t        FFT: 'fft'\n\t    };\n\t    /**\n\t\t *  Possible return types of Tone.Analyser.analyse(). \n\t\t *  byte values are between [0,255]. float values are between \n\t\t *  [-1, 1] when the type is set to \"waveform\" and between \n\t\t *  [minDecibels,maxDecibels] when the type is \"fft\".\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Analyser.ReturnType = {\n\t        Byte: 'byte',\n\t        Float: 'float'\n\t    };\n\t    /**\n\t\t *  Run the analysis given the current settings and return the \n\t\t *  result as a TypedArray. \n\t\t *  @returns {TypedArray}\n\t\t */\n\t    Tone.Analyser.prototype.analyse = function () {\n\t        if (this._type === Tone.Analyser.Type.FFT) {\n\t            if (this._returnType === Tone.Analyser.ReturnType.Byte) {\n\t                this._analyser.getByteFrequencyData(this._buffer);\n\t            } else {\n\t                this._analyser.getFloatFrequencyData(this._buffer);\n\t            }\n\t        } else if (this._type === Tone.Analyser.Type.Waveform) {\n\t            if (this._returnType === Tone.Analyser.ReturnType.Byte) {\n\t                this._analyser.getByteTimeDomainData(this._buffer);\n\t            } else {\n\t                this._analyser.getFloatTimeDomainData(this._buffer);\n\t            }\n\t        }\n\t        return this._buffer;\n\t    };\n\t    /**\n\t\t *  The size of analysis. This must be a power of two in the range 32 to 32768.\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Number}\n\t\t *  @name size\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'size', {\n\t        get: function () {\n\t            return this._analyser.frequencyBinCount;\n\t        },\n\t        set: function (size) {\n\t            this._analyser.fftSize = size * 2;\n\t            this.type = this._type;\n\t        }\n\t    });\n\t    /**\n\t\t *  The return type of Tone.Analyser.analyse(), either \"byte\" or \"float\". \n\t\t *  When the type is set to \"byte\" the range of values returned in the array\n\t\t *  are between 0-255. \"float\" values are between \n\t\t *  [-1, 1] when the type is set to \"waveform\" and between \n\t\t *  [minDecibels,maxDecibels] when the type is \"fft\".\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {String}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'returnType', {\n\t        get: function () {\n\t            return this._returnType;\n\t        },\n\t        set: function (type) {\n\t            if (type === Tone.Analyser.ReturnType.Byte) {\n\t                this._buffer = new Uint8Array(this._analyser.frequencyBinCount);\n\t            } else if (type === Tone.Analyser.ReturnType.Float) {\n\t                this._buffer = new Float32Array(this._analyser.frequencyBinCount);\n\t            } else {\n\t                throw new TypeError('Tone.Analayser: invalid return type: ' + type);\n\t            }\n\t            this._returnType = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  The analysis function returned by Tone.Analyser.analyse(), either \"fft\" or \"waveform\". \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {String}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            if (type !== Tone.Analyser.Type.Waveform && type !== Tone.Analyser.Type.FFT) {\n\t                throw new TypeError('Tone.Analyser: invalid type: ' + type);\n\t            }\n\t            this._type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  0 represents no time averaging with the last analysis frame.\n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {NormalRange}\n\t\t *  @name smoothing\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'smoothing', {\n\t        get: function () {\n\t            return this._analyser.smoothingTimeConstant;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.smoothingTimeConstant = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The smallest decibel value which is analysed by the FFT. \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Decibels}\n\t\t *  @name minDecibels\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'minDecibels', {\n\t        get: function () {\n\t            return this._analyser.minDecibels;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.minDecibels = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The largest decibel value which is analysed by the FFT. \n\t\t *  @memberOf Tone.Analyser#\n\t\t *  @type {Decibels}\n\t\t *  @name maxDecibels\n\t\t */\n\t    Object.defineProperty(Tone.Analyser.prototype, 'maxDecibels', {\n\t        get: function () {\n\t            return this._analyser.maxDecibels;\n\t        },\n\t        set: function (val) {\n\t            this._analyser.maxDecibels = val;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Analyser}  this\n\t\t */\n\t    Tone.Analyser.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._analyser.disconnect();\n\t        this._analyser = null;\n\t        this._buffer = null;\n\t    };\n\t    return Tone.Analyser;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Compressor is a thin wrapper around the Web Audio \n\t\t *         [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n\t\t *         Compression reduces the volume of loud sounds or amplifies quiet sounds \n\t\t *         by narrowing or \"compressing\" an audio signal's dynamic range. \n\t\t *         Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Decibels|Object} [threshold] The value above which the compression starts to be applied.\n\t\t *  @param {Positive} [ratio] The gain reduction ratio.\n\t\t *  @example\n\t\t * var comp = new Tone.Compressor(-30, 3);\n\t\t */\n\t    Tone.Compressor = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'threshold',\n\t            'ratio'\n\t        ], Tone.Compressor.defaults);\n\t        /**\n\t\t\t *  the compressor node\n\t\t\t *  @type {DynamicsCompressorNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._compressor = this.input = this.output = this.context.createDynamicsCompressor();\n\t        /**\n\t\t\t *  the threshold vaue\n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.threshold = new Tone.Param({\n\t            'param': this._compressor.threshold,\n\t            'units': Tone.Type.Decibels,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The attack parameter\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.attack = new Tone.Param(this._compressor.attack, Tone.Type.Time);\n\t        /**\n\t\t\t *  The release parameter\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.release = new Tone.Param(this._compressor.release, Tone.Type.Time);\n\t        /**\n\t\t\t *  The knee parameter\n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.knee = new Tone.Param({\n\t            'param': this._compressor.knee,\n\t            'units': Tone.Type.Decibels,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The ratio value\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.ratio = new Tone.Param({\n\t            'param': this._compressor.ratio,\n\t            'convert': false\n\t        });\n\t        //set the defaults\n\t        this._readOnly([\n\t            'knee',\n\t            'release',\n\t            'attack',\n\t            'ratio',\n\t            'threshold'\n\t        ]);\n\t        this.set(options);\n\t    };\n\t    Tone.extend(Tone.Compressor);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Compressor.defaults = {\n\t        'ratio': 12,\n\t        'threshold': -24,\n\t        'release': 0.25,\n\t        'attack': 0.003,\n\t        'knee': 30\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Compressor} this\n\t\t */\n\t    Tone.Compressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'knee',\n\t            'release',\n\t            'attack',\n\t            'ratio',\n\t            'threshold'\n\t        ]);\n\t        this._compressor.disconnect();\n\t        this._compressor = null;\n\t        this.attack.dispose();\n\t        this.attack = null;\n\t        this.release.dispose();\n\t        this.release = null;\n\t        this.threshold.dispose();\n\t        this.threshold = null;\n\t        this.ratio.dispose();\n\t        this.ratio = null;\n\t        this.knee.dispose();\n\t        this.knee = null;\n\t        return this;\n\t    };\n\t    return Tone.Compressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Add a signal and a number or two signals. When no value is\n\t\t *         passed into the constructor, Tone.Add will sum <code>input[0]</code>\n\t\t *         and <code>input[1]</code>. If a value is passed into the constructor, \n\t\t *         the it will be added to the input.\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number=} value If no value is provided, Tone.Add will sum the first\n\t\t *                         and second inputs. \n\t\t *  @example\n\t\t * var signal = new Tone.Signal(2);\n\t\t * var add = new Tone.Add(2);\n\t\t * signal.connect(add);\n\t\t * //the output of add equals 4\n\t\t *  @example\n\t\t * //if constructed with no arguments\n\t\t * //it will add the first and second inputs\n\t\t * var add = new Tone.Add();\n\t\t * var sig0 = new Tone.Signal(3).connect(add, 0, 0);\n\t\t * var sig1 = new Tone.Signal(4).connect(add, 0, 1);\n\t\t * //the output of add equals 7. \n\t\t */\n\t    Tone.Add = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the summing node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sum = this.input[0] = this.input[1] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Signal}\n\t\t\t */\n\t        this._param = this.input[1] = new Tone.Signal(value);\n\t        this._param.connect(this._sum);\n\t    };\n\t    Tone.extend(Tone.Add, Tone.Signal);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Add} this\n\t\t */\n\t    Tone.Add.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sum.dispose();\n\t        this._sum = null;\n\t        this._param.dispose();\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Add;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Multiply two incoming signals. Or, if a number is given in the constructor, \n\t\t *          multiplies the incoming signal by that value. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number=} value Constant value to multiple. If no value is provided,\n\t\t *                         it will return the product of the first and second inputs\n\t\t *  @example\n\t\t * var mult = new Tone.Multiply();\n\t\t * var sigA = new Tone.Signal(3);\n\t\t * var sigB = new Tone.Signal(4);\n\t\t * sigA.connect(mult, 0, 0);\n\t\t * sigB.connect(mult, 0, 1);\n\t\t * //output of mult is 12.\n\t\t *  @example\n\t\t * var mult = new Tone.Multiply(10);\n\t\t * var sig = new Tone.Signal(2).connect(mult);\n\t\t * //the output of mult is 20. \n\t\t */\n\t    Tone.Multiply = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the input node is the same as the output node\n\t\t\t *  it is also the GainNode which handles the scaling of incoming signal\n\t\t\t *  \n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mult = this.input[0] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  the scaling parameter\n\t\t\t *  @type {AudioParam}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input[1] = this.output.gain;\n\t        this._param.value = this.defaultArg(value, 0);\n\t    };\n\t    Tone.extend(Tone.Multiply, Tone.Signal);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Multiply} this\n\t\t */\n\t    Tone.Multiply.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._mult.dispose();\n\t        this._mult = null;\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Multiply;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Negate the incoming signal. i.e. an input signal of 10 will output -10\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var neg = new Tone.Negate();\n\t\t * var sig = new Tone.Signal(-2).connect(neg);\n\t\t * //output of neg is positive 2. \n\t\t */\n\t    Tone.Negate = function () {\n\t        /**\n\t\t\t *  negation is done by multiplying by -1\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multiply = this.input = this.output = new Tone.Multiply(-1);\n\t    };\n\t    Tone.extend(Tone.Negate, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Negate} this\n\t\t */\n\t    Tone.Negate.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._multiply.dispose();\n\t        this._multiply = null;\n\t        return this;\n\t    };\n\t    return Tone.Negate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Subtract the signal connected to <code>input[1]</code> from the signal connected \n\t\t *         to <code>input[0]</code>. If an argument is provided in the constructor, the \n\t\t *         signals <code>.value</code> will be subtracted from the incoming signal.\n\t\t *\n\t\t *  @extends {Tone.Signal}\n\t\t *  @constructor\n\t\t *  @param {number=} value The value to subtract from the incoming signal. If the value\n\t\t *                         is omitted, it will subtract the second signal from the first.\n\t\t *  @example\n\t\t * var sub = new Tone.Subtract(1);\n\t\t * var sig = new Tone.Signal(4).connect(sub);\n\t\t * //the output of sub is 3. \n\t\t *  @example\n\t\t * var sub = new Tone.Subtract();\n\t\t * var sigA = new Tone.Signal(10);\n\t\t * var sigB = new Tone.Signal(2.5);\n\t\t * sigA.connect(sub, 0, 0);\n\t\t * sigB.connect(sub, 0, 1);\n\t\t * //output of sub is 7.5\n\t\t */\n\t    Tone.Subtract = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  the summing node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sum = this.input[0] = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  negate the input of the second input before connecting it\n\t\t\t *  to the summing node.\n\t\t\t *  @type {Tone.Negate}\n\t\t\t *  @private\n\t\t\t */\n\t        this._neg = new Tone.Negate();\n\t        /**\n\t\t\t *  the node where the value is set\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Signal}\n\t\t\t */\n\t        this._param = this.input[1] = new Tone.Signal(value);\n\t        this._param.chain(this._neg, this._sum);\n\t    };\n\t    Tone.extend(Tone.Subtract, Tone.Signal);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.SignalBase} this\n\t\t */\n\t    Tone.Subtract.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._neg.dispose();\n\t        this._neg = null;\n\t        this._sum.disconnect();\n\t        this._sum = null;\n\t        this._param.dispose();\n\t        this._param = null;\n\t        return this;\n\t    };\n\t    return Tone.Subtract;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  GreaterThanZero outputs 1 when the input is strictly greater than zero\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var gt0 = new Tone.GreaterThanZero();\n\t\t * var sig = new Tone.Signal(0.01).connect(gt0);\n\t\t * //the output of gt0 is 1. \n\t\t * sig.value = 0;\n\t\t * //the output of gt0 is 0. \n\t\t */\n\t    Tone.GreaterThanZero = function () {\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._thresh = this.output = new Tone.WaveShaper(function (val) {\n\t            if (val <= 0) {\n\t                return 0;\n\t            } else {\n\t                return 1;\n\t            }\n\t        }, 127);\n\t        /**\n\t\t\t *  scale the first thresholded signal by a large value.\n\t\t\t *  this will help with values which are very close to 0\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.input = new Tone.Multiply(10000);\n\t        //connections\n\t        this._scale.connect(this._thresh);\n\t    };\n\t    Tone.extend(Tone.GreaterThanZero, Tone.SignalBase);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.GreaterThanZero} this\n\t\t */\n\t    Tone.GreaterThanZero.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._thresh.dispose();\n\t        this._thresh = null;\n\t        return this;\n\t    };\n\t    return Tone.GreaterThanZero;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Output 1 if the signal is greater than the value, otherwise outputs 0.\n\t\t *          can compare two signals or a signal and a number. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Signal}\n\t\t *  @param {number} [value=0] the value to compare to the incoming signal\n\t\t *  @example\n\t\t * var gt = new Tone.GreaterThan(2);\n\t\t * var sig = new Tone.Signal(4).connect(gt);\n\t\t * //output of gt is equal 1. \n\t\t */\n\t    Tone.GreaterThan = function (value) {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  subtract the amount from the incoming signal\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._param = this.input[0] = new Tone.Subtract(value);\n\t        this.input[1] = this._param.input[1];\n\t        /**\n\t\t\t *  compare that amount to zero\n\t\t\t *  @type {Tone.GreaterThanZero}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gtz = this.output = new Tone.GreaterThanZero();\n\t        //connect\n\t        this._param.connect(this._gtz);\n\t    };\n\t    Tone.extend(Tone.GreaterThan, Tone.Signal);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.GreaterThan} this\n\t\t */\n\t    Tone.GreaterThan.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._param.dispose();\n\t        this._param = null;\n\t        this._gtz.dispose();\n\t        this._gtz = null;\n\t        return this;\n\t    };\n\t    return Tone.GreaterThan;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Return the absolute value of an incoming signal. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @example\n\t\t * var signal = new Tone.Signal(-1);\n\t\t * var abs = new Tone.Abs();\n\t\t * signal.connect(abs);\n\t\t * //the output of abs is 1. \n\t\t */\n\t    Tone.Abs = function () {\n\t        /**\n\t\t\t *  @type {Tone.LessThan}\n\t\t\t *  @private\n\t\t\t */\n\t        this._abs = this.input = this.output = new Tone.WaveShaper(function (val) {\n\t            if (val === 0) {\n\t                return 0;\n\t            } else {\n\t                return Math.abs(val);\n\t            }\n\t        }, 127);\n\t    };\n\t    Tone.extend(Tone.Abs, Tone.SignalBase);\n\t    /**\n\t\t *  dispose method\n\t\t *  @returns {Tone.Abs} this\n\t\t */\n\t    Tone.Abs.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._abs.dispose();\n\t        this._abs = null;\n\t        return this;\n\t    };\n\t    return Tone.Abs;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Signal-rate modulo operator. Only works in AudioRange [-1, 1] and for modulus\n\t\t *         values in the NormalRange. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {NormalRange} modulus The modulus to apply.\n\t\t *  @example\n\t\t * var mod = new Tone.Modulo(0.2)\n\t\t * var sig = new Tone.Signal(0.5).connect(mod);\n\t\t * //mod outputs 0.1\n\t\t */\n\t    Tone.Modulo = function (modulus) {\n\t        this.createInsOuts(1, 0);\n\t        /**\n\t\t\t *  A waveshaper gets the integer multiple of \n\t\t\t *  the input signal and the modulus.\n\t\t\t *  @private\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(Math.pow(2, 16));\n\t        /**\n\t\t\t *  the integer multiple is multiplied by the modulus\n\t\t\t *  @type  {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multiply = new Tone.Multiply();\n\t        /**\n\t\t\t *  and subtracted from the input signal\n\t\t\t *  @type  {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subtract = this.output = new Tone.Subtract();\n\t        /**\n\t\t\t *  the modulus signal\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modSignal = new Tone.Signal(modulus);\n\t        //connections\n\t        this.input.fan(this._shaper, this._subtract);\n\t        this._modSignal.connect(this._multiply, 0, 0);\n\t        this._shaper.connect(this._multiply, 0, 1);\n\t        this._multiply.connect(this._subtract, 0, 1);\n\t        this._setWaveShaper(modulus);\n\t    };\n\t    Tone.extend(Tone.Modulo, Tone.SignalBase);\n\t    /**\n\t\t *  @param  {number}  mod  the modulus to apply\n\t\t *  @private\n\t\t */\n\t    Tone.Modulo.prototype._setWaveShaper = function (mod) {\n\t        this._shaper.setMap(function (val) {\n\t            var multiple = Math.floor((val + 0.0001) / mod);\n\t            return multiple;\n\t        });\n\t    };\n\t    /**\n\t\t * The modulus value.\n\t\t * @memberOf Tone.Modulo#\n\t\t * @type {NormalRange}\n\t\t * @name value\n\t\t */\n\t    Object.defineProperty(Tone.Modulo.prototype, 'value', {\n\t        get: function () {\n\t            return this._modSignal.value;\n\t        },\n\t        set: function (mod) {\n\t            this._modSignal.value = mod;\n\t            this._setWaveShaper(mod);\n\t        }\n\t    });\n\t    /**\n\t\t * clean up\n\t\t *  @returns {Tone.Modulo} this\n\t\t */\n\t    Tone.Modulo.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        this._multiply.dispose();\n\t        this._multiply = null;\n\t        this._subtract.dispose();\n\t        this._subtract = null;\n\t        this._modSignal.dispose();\n\t        this._modSignal = null;\n\t        return this;\n\t    };\n\t    return Tone.Modulo;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1]. \n\t\t *         See Tone.GainToAudio.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t *  var a2g = new Tone.AudioToGain();\n\t\t */\n\t    Tone.AudioToGain = function () {\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {\n\t            return (x + 1) / 2;\n\t        });\n\t    };\n\t    Tone.extend(Tone.AudioToGain, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AudioToGain} this\n\t\t */\n\t    Tone.AudioToGain.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._norm.dispose();\n\t        this._norm = null;\n\t        return this;\n\t    };\n\t    return Tone.AudioToGain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Evaluate an expression at audio rate. <br><br>\n\t\t *         Parsing code modified from https://code.google.com/p/tapdigit/\n\t\t *         Copyright 2011 2012 Ariya Hidayat, New BSD License\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {string} expr the expression to generate\n\t\t *  @example\n\t\t * //adds the signals from input[0] and input[1].\n\t\t * var expr = new Tone.Expr(\"$0 + $1\");\n\t\t */\n\t    Tone.Expr = function () {\n\t        var expr = this._replacements(Array.prototype.slice.call(arguments));\n\t        var inputCount = this._parseInputs(expr);\n\t        /**\n\t\t\t *  hold onto all of the nodes for disposal\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._nodes = [];\n\t        /**\n\t\t\t *  The inputs. The length is determined by the expression. \n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.input = new Array(inputCount);\n\t        //create a gain for each input\n\t        for (var i = 0; i < inputCount; i++) {\n\t            this.input[i] = this.context.createGain();\n\t        }\n\t        //parse the syntax tree\n\t        var tree = this._parseTree(expr);\n\t        //evaluate the results\n\t        var result;\n\t        try {\n\t            result = this._eval(tree);\n\t        } catch (e) {\n\t            this._disposeNodes();\n\t            throw new Error('Tone.Expr: Could evaluate expression: ' + expr);\n\t        }\n\t        /**\n\t\t\t *  The output node is the result of the expression\n\t\t\t *  @type {Tone}\n\t\t\t */\n\t        this.output = result;\n\t    };\n\t    Tone.extend(Tone.Expr, Tone.SignalBase);\n\t    //some helpers to cut down the amount of code\n\t    function applyBinary(Constructor, args, self) {\n\t        var op = new Constructor();\n\t        self._eval(args[0]).connect(op, 0, 0);\n\t        self._eval(args[1]).connect(op, 0, 1);\n\t        return op;\n\t    }\n\t    function applyUnary(Constructor, args, self) {\n\t        var op = new Constructor();\n\t        self._eval(args[0]).connect(op, 0, 0);\n\t        return op;\n\t    }\n\t    function getNumber(arg) {\n\t        return arg ? parseFloat(arg) : undefined;\n\t    }\n\t    function literalNumber(arg) {\n\t        return arg && arg.args ? parseFloat(arg.args) : undefined;\n\t    }\n\t    /*\n\t\t *  the Expressions that Tone.Expr can parse.\n\t\t *\n\t\t *  each expression belongs to a group and contains a regexp \n\t\t *  for selecting the operator as well as that operators method\n\t\t *  \n\t\t *  @type {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Expr._Expressions = {\n\t        //values\n\t        'value': {\n\t            'signal': {\n\t                regexp: /^\\d+\\.\\d+|^\\d+/,\n\t                method: function (arg) {\n\t                    var sig = new Tone.Signal(getNumber(arg));\n\t                    return sig;\n\t                }\n\t            },\n\t            'input': {\n\t                regexp: /^\\$\\d/,\n\t                method: function (arg, self) {\n\t                    return self.input[getNumber(arg.substr(1))];\n\t                }\n\t            }\n\t        },\n\t        //syntactic glue\n\t        'glue': {\n\t            '(': { regexp: /^\\(/ },\n\t            ')': { regexp: /^\\)/ },\n\t            ',': { regexp: /^,/ }\n\t        },\n\t        //functions\n\t        'func': {\n\t            'abs': {\n\t                regexp: /^abs/,\n\t                method: applyUnary.bind(this, Tone.Abs)\n\t            },\n\t            'mod': {\n\t                regexp: /^mod/,\n\t                method: function (args, self) {\n\t                    var modulus = literalNumber(args[1]);\n\t                    var op = new Tone.Modulo(modulus);\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            },\n\t            'pow': {\n\t                regexp: /^pow/,\n\t                method: function (args, self) {\n\t                    var exp = literalNumber(args[1]);\n\t                    var op = new Tone.Pow(exp);\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            },\n\t            'a2g': {\n\t                regexp: /^a2g/,\n\t                method: function (args, self) {\n\t                    var op = new Tone.AudioToGain();\n\t                    self._eval(args[0]).connect(op);\n\t                    return op;\n\t                }\n\t            }\n\t        },\n\t        //binary expressions\n\t        'binary': {\n\t            '+': {\n\t                regexp: /^\\+/,\n\t                precedence: 1,\n\t                method: applyBinary.bind(this, Tone.Add)\n\t            },\n\t            '-': {\n\t                regexp: /^\\-/,\n\t                precedence: 1,\n\t                method: function (args, self) {\n\t                    //both unary and binary op\n\t                    if (args.length === 1) {\n\t                        return applyUnary(Tone.Negate, args, self);\n\t                    } else {\n\t                        return applyBinary(Tone.Subtract, args, self);\n\t                    }\n\t                }\n\t            },\n\t            '*': {\n\t                regexp: /^\\*/,\n\t                precedence: 0,\n\t                method: applyBinary.bind(this, Tone.Multiply)\n\t            }\n\t        },\n\t        //unary expressions\n\t        'unary': {\n\t            '-': {\n\t                regexp: /^\\-/,\n\t                method: applyUnary.bind(this, Tone.Negate)\n\t            },\n\t            '!': {\n\t                regexp: /^\\!/,\n\t                method: applyUnary.bind(this, Tone.NOT)\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  @param   {string} expr the expression string\n\t\t *  @return  {number}      the input count\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._parseInputs = function (expr) {\n\t        var inputArray = expr.match(/\\$\\d/g);\n\t        var inputMax = 0;\n\t        if (inputArray !== null) {\n\t            for (var i = 0; i < inputArray.length; i++) {\n\t                var inputNum = parseInt(inputArray[i].substr(1)) + 1;\n\t                inputMax = Math.max(inputMax, inputNum);\n\t            }\n\t        }\n\t        return inputMax;\n\t    };\n\t    /**\n\t\t *  @param   {Array} args \tan array of arguments\n\t\t *  @return  {string} the results of the replacements being replaced\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._replacements = function (args) {\n\t        var expr = args.shift();\n\t        for (var i = 0; i < args.length; i++) {\n\t            expr = expr.replace(/\\%/i, args[i]);\n\t        }\n\t        return expr;\n\t    };\n\t    /**\n\t\t *  tokenize the expression based on the Expressions object\n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}      returns two methods on the tokenized list, next and peek\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._tokenize = function (expr) {\n\t        var position = -1;\n\t        var tokens = [];\n\t        while (expr.length > 0) {\n\t            expr = expr.trim();\n\t            var token = getNextToken(expr);\n\t            tokens.push(token);\n\t            expr = expr.substr(token.value.length);\n\t        }\n\t        function getNextToken(expr) {\n\t            for (var type in Tone.Expr._Expressions) {\n\t                var group = Tone.Expr._Expressions[type];\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    var reg = op.regexp;\n\t                    var match = expr.match(reg);\n\t                    if (match !== null) {\n\t                        return {\n\t                            type: type,\n\t                            value: match[0],\n\t                            method: op.method\n\t                        };\n\t                    }\n\t                }\n\t            }\n\t            throw new SyntaxError('Tone.Expr: Unexpected token ' + expr);\n\t        }\n\t        return {\n\t            next: function () {\n\t                return tokens[++position];\n\t            },\n\t            peek: function () {\n\t                return tokens[position + 1];\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  recursively parse the string expression into a syntax tree\n\t\t *  \n\t\t *  @param   {string} expr \n\t\t *  @return  {Object}\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._parseTree = function (expr) {\n\t        var lexer = this._tokenize(expr);\n\t        var isUndef = this.isUndef.bind(this);\n\t        function matchSyntax(token, syn) {\n\t            return !isUndef(token) && token.type === 'glue' && token.value === syn;\n\t        }\n\t        function matchGroup(token, groupName, prec) {\n\t            var ret = false;\n\t            var group = Tone.Expr._Expressions[groupName];\n\t            if (!isUndef(token)) {\n\t                for (var opName in group) {\n\t                    var op = group[opName];\n\t                    if (op.regexp.test(token.value)) {\n\t                        if (!isUndef(prec)) {\n\t                            if (op.precedence === prec) {\n\t                                return true;\n\t                            }\n\t                        } else {\n\t                            return true;\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t            return ret;\n\t        }\n\t        function parseExpression(precedence) {\n\t            if (isUndef(precedence)) {\n\t                precedence = 5;\n\t            }\n\t            var expr;\n\t            if (precedence < 0) {\n\t                expr = parseUnary();\n\t            } else {\n\t                expr = parseExpression(precedence - 1);\n\t            }\n\t            var token = lexer.peek();\n\t            while (matchGroup(token, 'binary', precedence)) {\n\t                token = lexer.next();\n\t                expr = {\n\t                    operator: token.value,\n\t                    method: token.method,\n\t                    args: [\n\t                        expr,\n\t                        parseExpression(precedence - 1)\n\t                    ]\n\t                };\n\t                token = lexer.peek();\n\t            }\n\t            return expr;\n\t        }\n\t        function parseUnary() {\n\t            var token, expr;\n\t            token = lexer.peek();\n\t            if (matchGroup(token, 'unary')) {\n\t                token = lexer.next();\n\t                expr = parseUnary();\n\t                return {\n\t                    operator: token.value,\n\t                    method: token.method,\n\t                    args: [expr]\n\t                };\n\t            }\n\t            return parsePrimary();\n\t        }\n\t        function parsePrimary() {\n\t            var token, expr;\n\t            token = lexer.peek();\n\t            if (isUndef(token)) {\n\t                throw new SyntaxError('Tone.Expr: Unexpected termination of expression');\n\t            }\n\t            if (token.type === 'func') {\n\t                token = lexer.next();\n\t                return parseFunctionCall(token);\n\t            }\n\t            if (token.type === 'value') {\n\t                token = lexer.next();\n\t                return {\n\t                    method: token.method,\n\t                    args: token.value\n\t                };\n\t            }\n\t            if (matchSyntax(token, '(')) {\n\t                lexer.next();\n\t                expr = parseExpression();\n\t                token = lexer.next();\n\t                if (!matchSyntax(token, ')')) {\n\t                    throw new SyntaxError('Expected )');\n\t                }\n\t                return expr;\n\t            }\n\t            throw new SyntaxError('Tone.Expr: Parse error, cannot process token ' + token.value);\n\t        }\n\t        function parseFunctionCall(func) {\n\t            var token, args = [];\n\t            token = lexer.next();\n\t            if (!matchSyntax(token, '(')) {\n\t                throw new SyntaxError('Tone.Expr: Expected ( in a function call \"' + func.value + '\"');\n\t            }\n\t            token = lexer.peek();\n\t            if (!matchSyntax(token, ')')) {\n\t                args = parseArgumentList();\n\t            }\n\t            token = lexer.next();\n\t            if (!matchSyntax(token, ')')) {\n\t                throw new SyntaxError('Tone.Expr: Expected ) in a function call \"' + func.value + '\"');\n\t            }\n\t            return {\n\t                method: func.method,\n\t                args: args,\n\t                name: name\n\t            };\n\t        }\n\t        function parseArgumentList() {\n\t            var token, expr, args = [];\n\t            while (true) {\n\t                expr = parseExpression();\n\t                if (isUndef(expr)) {\n\t                    // TODO maybe throw exception?\n\t                    break;\n\t                }\n\t                args.push(expr);\n\t                token = lexer.peek();\n\t                if (!matchSyntax(token, ',')) {\n\t                    break;\n\t                }\n\t                lexer.next();\n\t            }\n\t            return args;\n\t        }\n\t        return parseExpression();\n\t    };\n\t    /**\n\t\t *  recursively evaluate the expression tree\n\t\t *  @param   {Object} tree \n\t\t *  @return  {AudioNode}      the resulting audio node from the expression\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._eval = function (tree) {\n\t        if (!this.isUndef(tree)) {\n\t            var node = tree.method(tree.args, this);\n\t            this._nodes.push(node);\n\t            return node;\n\t        }\n\t    };\n\t    /**\n\t\t *  dispose all the nodes\n\t\t *  @private\n\t\t */\n\t    Tone.Expr.prototype._disposeNodes = function () {\n\t        for (var i = 0; i < this._nodes.length; i++) {\n\t            var node = this._nodes[i];\n\t            if (this.isFunction(node.dispose)) {\n\t                node.dispose();\n\t            } else if (this.isFunction(node.disconnect)) {\n\t                node.disconnect();\n\t            }\n\t            node = null;\n\t            this._nodes[i] = null;\n\t        }\n\t        this._nodes = null;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t */\n\t    Tone.Expr.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._disposeNodes();\n\t    };\n\t    return Tone.Expr;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Convert an incoming signal between 0, 1 to an equal power gain scale.\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t * var eqPowGain = new Tone.EqualPowerGain();\n\t\t */\n\t    Tone.EqualPowerGain = function () {\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._eqPower = this.input = this.output = new Tone.WaveShaper(function (val) {\n\t            if (Math.abs(val) < 0.001) {\n\t                //should output 0 when input is 0\n\t                return 0;\n\t            } else {\n\t                return this.equalPowerScale(val);\n\t            }\n\t        }.bind(this), 4096);\n\t    };\n\t    Tone.extend(Tone.EqualPowerGain, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.EqualPowerGain} this\n\t\t */\n\t    Tone.EqualPowerGain.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._eqPower.dispose();\n\t        this._eqPower = null;\n\t        return this;\n\t    };\n\t    return Tone.EqualPowerGain;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * @class  Tone.Crossfade provides equal power fading between two inputs. \n\t\t *         More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n\t\t *\n\t\t * @constructor\n\t\t * @extends {Tone}\n\t\t * @param {NormalRange} [initialFade=0.5]\n\t\t * @example\n\t\t * var crossFade = new Tone.CrossFade(0.5);\n\t\t * //connect effect A to crossfade from\n\t\t * //effect output 0 to crossfade input 0\n\t\t * effectA.connect(crossFade, 0, 0);\n\t\t * //connect effect B to crossfade from\n\t\t * //effect output 0 to crossfade input 1\n\t\t * effectB.connect(crossFade, 0, 1);\n\t\t * crossFade.fade.value = 0;\n\t\t * // ^ only effectA is output\n\t\t * crossFade.fade.value = 1;\n\t\t * // ^ only effectB is output\n\t\t * crossFade.fade.value = 0.5;\n\t\t * // ^ the two signals are mixed equally. \n\t\t */\n\t    Tone.CrossFade = function (initialFade) {\n\t        this.createInsOuts(2, 1);\n\t        /**\n\t\t\t *  Alias for <code>input[0]</code>. \n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.a = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  Alias for <code>input[1]</code>. \n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.b = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t * \tThe mix between the two inputs. A fade value of 0\n\t\t\t * \twill output 100% <code>input[0]</code> and \n\t\t\t * \ta value of 1 will output 100% <code>input[1]</code>. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.fade = new Tone.Signal(this.defaultArg(initialFade, 0.5), Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  equal power gain cross fade\n\t\t\t *  @private\n\t\t\t *  @type {Tone.EqualPowerGain}\n\t\t\t */\n\t        this._equalPowerA = new Tone.EqualPowerGain();\n\t        /**\n\t\t\t *  equal power gain cross fade\n\t\t\t *  @private\n\t\t\t *  @type {Tone.EqualPowerGain}\n\t\t\t */\n\t        this._equalPowerB = new Tone.EqualPowerGain();\n\t        /**\n\t\t\t *  invert the incoming signal\n\t\t\t *  @private\n\t\t\t *  @type {Tone}\n\t\t\t */\n\t        this._invert = new Tone.Expr('1 - $0');\n\t        //connections\n\t        this.a.connect(this.output);\n\t        this.b.connect(this.output);\n\t        this.fade.chain(this._equalPowerB, this.b.gain);\n\t        this.fade.chain(this._invert, this._equalPowerA, this.a.gain);\n\t        this._readOnly('fade');\n\t    };\n\t    Tone.extend(Tone.CrossFade);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.CrossFade} this\n\t\t */\n\t    Tone.CrossFade.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('fade');\n\t        this._equalPowerA.dispose();\n\t        this._equalPowerA = null;\n\t        this._equalPowerB.dispose();\n\t        this._equalPowerB = null;\n\t        this.fade.dispose();\n\t        this.fade = null;\n\t        this._invert.dispose();\n\t        this._invert = null;\n\t        this.a.dispose();\n\t        this.a = null;\n\t        this.b.dispose();\n\t        this.b = null;\n\t        return this;\n\t    };\n\t    return Tone.CrossFade;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Filter is a filter which allows for all of the same native methods\n\t\t *          as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface). \n\t\t *          Tone.Filter has the added ability to set the filter rolloff at -12 \n\t\t *          (default), -24 and -48. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Frequency|Object} [frequency] The cutoff frequency of the filter.\n\t\t *  @param {string=} type The type of filter.\n\t\t *  @param {number=} rolloff The drop in decibels per octave after the cutoff frequency.\n\t\t *                            3 choices: -12, -24, and -48\n\t\t *  @example\n\t\t *  var filter = new Tone.Filter(200, \"highpass\");\n\t\t */\n\t    Tone.Filter = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'rolloff'\n\t        ], Tone.Filter.defaults);\n\t        /**\n\t\t\t *  the filter(s)\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filters = [];\n\t        /**\n\t\t\t *  The cutoff frequency of the filter. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune parameter\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(0, Tone.Type.Cents);\n\t        /**\n\t\t\t *  The gain of the filter, only used in certain filter types\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.gain = new Tone.Signal({\n\t            'value': options.gain,\n\t            'convert': false\n\t        });\n\t        /**\n\t\t\t *  The Q or Quality of the filter\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q);\n\t        /**\n\t\t\t *  the type of the filter\n\t\t\t *  @type {string}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  the rolloff value of the filter\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rolloff = options.rolloff;\n\t        //set the rolloff;\n\t        this.rolloff = options.rolloff;\n\t        this._readOnly([\n\t            'detune',\n\t            'frequency',\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Filter);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Filter.defaults = {\n\t        'type': 'lowpass',\n\t        'frequency': 350,\n\t        'rolloff': -12,\n\t        'Q': 1,\n\t        'gain': 0\n\t    };\n\t    /**\n\t\t * The type of the filter. Types: \"lowpass\", \"highpass\", \n\t\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\". \n\t\t * @memberOf Tone.Filter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Filter.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            var types = [\n\t                'lowpass',\n\t                'highpass',\n\t                'bandpass',\n\t                'lowshelf',\n\t                'highshelf',\n\t                'notch',\n\t                'allpass',\n\t                'peaking'\n\t            ];\n\t            if (types.indexOf(type) === -1) {\n\t                throw new TypeError('Tone.Filter: invalid type ' + type);\n\t            }\n\t            this._type = type;\n\t            for (var i = 0; i < this._filters.length; i++) {\n\t                this._filters[i].type = type;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The rolloff of the filter which is the drop in db\n\t\t * per octave. Implemented internally by cascading filters.\n\t\t * Only accepts the values -12, -24, -48 and -96.\n\t\t * @memberOf Tone.Filter#\n\t\t * @type {number}\n\t\t * @name rolloff\n\t\t */\n\t    Object.defineProperty(Tone.Filter.prototype, 'rolloff', {\n\t        get: function () {\n\t            return this._rolloff;\n\t        },\n\t        set: function (rolloff) {\n\t            rolloff = parseInt(rolloff, 10);\n\t            var possibilities = [\n\t                -12,\n\t                -24,\n\t                -48,\n\t                -96\n\t            ];\n\t            var cascadingCount = possibilities.indexOf(rolloff);\n\t            //check the rolloff is valid\n\t            if (cascadingCount === -1) {\n\t                throw new RangeError('Tone.Filter: rolloff can only be -12, -24, -48 or -96');\n\t            }\n\t            cascadingCount += 1;\n\t            this._rolloff = rolloff;\n\t            //first disconnect the filters and throw them away\n\t            this.input.disconnect();\n\t            for (var i = 0; i < this._filters.length; i++) {\n\t                this._filters[i].disconnect();\n\t                this._filters[i] = null;\n\t            }\n\t            this._filters = new Array(cascadingCount);\n\t            for (var count = 0; count < cascadingCount; count++) {\n\t                var filter = this.context.createBiquadFilter();\n\t                filter.type = this._type;\n\t                this.frequency.connect(filter.frequency);\n\t                this.detune.connect(filter.detune);\n\t                this.Q.connect(filter.Q);\n\t                this.gain.connect(filter.gain);\n\t                this._filters[count] = filter;\n\t            }\n\t            //connect them up\n\t            var connectionChain = [this.input].concat(this._filters).concat([this.output]);\n\t            this.connectSeries.apply(this, connectionChain);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @return {Tone.Filter} this\n\t\t */\n\t    Tone.Filter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        for (var i = 0; i < this._filters.length; i++) {\n\t            this._filters[i].disconnect();\n\t            this._filters[i] = null;\n\t        }\n\t        this._filters = null;\n\t        this._writable([\n\t            'detune',\n\t            'frequency',\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.Q.dispose();\n\t        this.frequency = null;\n\t        this.Q = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.gain.dispose();\n\t        this.gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Filter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Split the incoming signal into three bands (low, mid, high)\n\t\t *         with two crossover frequency controls. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Frequency|Object} [lowFrequency] the low/mid crossover frequency\n\t\t *  @param {Frequency} [highFrequency] the mid/high crossover frequency\n\t\t */\n\t    Tone.MultibandSplit = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ], Tone.MultibandSplit.defaults);\n\t        /**\n\t\t\t *  the input\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.input = new Tone.Gain();\n\t        /**\n\t\t\t *  the outputs\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Array(3);\n\t        /**\n\t\t\t *  The low band. Alias for <code>output[0]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.low = this.output[0] = new Tone.Filter(0, 'lowpass');\n\t        /**\n\t\t\t *  the lower filter of the mid band\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowMidFilter = new Tone.Filter(0, 'highpass');\n\t        /**\n\t\t\t *  The mid band output. Alias for <code>output[1]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.mid = this.output[1] = new Tone.Filter(0, 'lowpass');\n\t        /**\n\t\t\t *  The high band output. Alias for <code>output[2]</code>\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.high = this.output[2] = new Tone.Filter(0, 'highpass');\n\t        /**\n\t\t\t *  The low/mid crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = new Tone.Signal(options.lowFrequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The mid/high crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = new Tone.Signal(options.highFrequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The quality of all the filters\n\t\t\t *  @type {Number}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q);\n\t        this.input.fan(this.low, this.high);\n\t        this.input.chain(this._lowMidFilter, this.mid);\n\t        //the frequency control signal\n\t        this.lowFrequency.connect(this.low.frequency);\n\t        this.lowFrequency.connect(this._lowMidFilter.frequency);\n\t        this.highFrequency.connect(this.mid.frequency);\n\t        this.highFrequency.connect(this.high.frequency);\n\t        //the Q value\n\t        this.Q.connect(this.low.Q);\n\t        this.Q.connect(this._lowMidFilter.Q);\n\t        this.Q.connect(this.mid.Q);\n\t        this.Q.connect(this.high.Q);\n\t        this._readOnly([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MultibandSplit);\n\t    /**\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MultibandSplit.defaults = {\n\t        'lowFrequency': 400,\n\t        'highFrequency': 2500,\n\t        'Q': 1\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MultibandSplit} this\n\t\t */\n\t    Tone.MultibandSplit.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t        this.low.dispose();\n\t        this.low = null;\n\t        this._lowMidFilter.dispose();\n\t        this._lowMidFilter = null;\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.high.dispose();\n\t        this.high = null;\n\t        this.lowFrequency.dispose();\n\t        this.lowFrequency = null;\n\t        this.highFrequency.dispose();\n\t        this.highFrequency = null;\n\t        this.Q.dispose();\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.MultibandSplit;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.EQ3 is a three band EQ with control over low, mid, and high gain as\n\t\t *         well as the low and high crossover frequencies.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  \n\t\t *  @param {Decibels|Object} [lowLevel] The gain applied to the lows.\n\t\t *  @param {Decibels} [midLevel] The gain applied to the mid.\n\t\t *  @param {Decibels} [highLevel] The gain applied to the high.\n\t\t *  @example\n\t\t * var eq = new Tone.EQ3(-10, 3, -20);\n\t\t */\n\t    Tone.EQ3 = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'low',\n\t            'mid',\n\t            'high'\n\t        ], Tone.EQ3.defaults);\n\t        /**\n\t\t\t *  the output node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  the multiband split\n\t\t\t *  @type {Tone.MultibandSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._multibandSplit = this.input = new Tone.MultibandSplit({\n\t            'lowFrequency': options.lowFrequency,\n\t            'highFrequency': options.highFrequency\n\t        });\n\t        /**\n\t\t\t *  The gain for the lower signals\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowGain = new Tone.Gain(options.low, Tone.Type.Decibels);\n\t        /**\n\t\t\t *  The gain for the mid signals\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midGain = new Tone.Gain(options.mid, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The gain in decibels of the high part\n\t\t\t * @type {Tone.Gain}\n\t\t\t * @private\n\t\t\t */\n\t        this._highGain = new Tone.Gain(options.high, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The gain in decibels of the low part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.low = this._lowGain.gain;\n\t        /**\n\t\t\t * The gain in decibels of the mid part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.mid = this._midGain.gain;\n\t        /**\n\t\t\t * The gain in decibels of the high part\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.high = this._highGain.gain;\n\t        /**\n\t\t\t *  The Q value for all of the filters. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = this._multibandSplit.Q;\n\t        /**\n\t\t\t *  The low/mid crossover frequency. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = this._multibandSplit.lowFrequency;\n\t        /**\n\t\t\t *  The mid/high crossover frequency. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = this._multibandSplit.highFrequency;\n\t        //the frequency bands\n\t        this._multibandSplit.low.chain(this._lowGain, this.output);\n\t        this._multibandSplit.mid.chain(this._midGain, this.output);\n\t        this._multibandSplit.high.chain(this._highGain, this.output);\n\t        this._readOnly([\n\t            'low',\n\t            'mid',\n\t            'high',\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.EQ3);\n\t    /**\n\t\t *  the default values\n\t\t */\n\t    Tone.EQ3.defaults = {\n\t        'low': 0,\n\t        'mid': 0,\n\t        'high': 0,\n\t        'lowFrequency': 400,\n\t        'highFrequency': 2500\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.EQ3} this\n\t\t */\n\t    Tone.EQ3.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'low',\n\t            'mid',\n\t            'high',\n\t            'lowFrequency',\n\t            'highFrequency'\n\t        ]);\n\t        this._multibandSplit.dispose();\n\t        this._multibandSplit = null;\n\t        this.lowFrequency = null;\n\t        this.highFrequency = null;\n\t        this._lowGain.dispose();\n\t        this._lowGain = null;\n\t        this._midGain.dispose();\n\t        this._midGain = null;\n\t        this._highGain.dispose();\n\t        this._highGain = null;\n\t        this.low = null;\n\t        this.mid = null;\n\t        this.high = null;\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.EQ3;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Performs a linear scaling on an input signal.\n\t\t *          Scales a NormalRange input to between\n\t\t *          outputMin and outputMax.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {number} [outputMin=0] The output value when the input is 0. \n\t\t *  @param {number} [outputMax=1]\tThe output value when the input is 1. \n\t\t *  @example\n\t\t * var scale = new Tone.Scale(50, 100);\n\t\t * var signal = new Tone.Signal(0.5).connect(scale);\n\t\t * //the output of scale equals 75\n\t\t */\n\t    Tone.Scale = function (outputMin, outputMax) {\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._outputMin = this.defaultArg(outputMin, 0);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._outputMax = this.defaultArg(outputMax, 1);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.input = new Tone.Multiply(1);\n\t        /** \n\t\t\t *  @private\n\t\t\t *  @type {Tone.Add}\n\t\t\t *  @private\n\t\t\t */\n\t        this._add = this.output = new Tone.Add(0);\n\t        this._scale.connect(this._add);\n\t        this._setRange();\n\t    };\n\t    Tone.extend(Tone.Scale, Tone.SignalBase);\n\t    /**\n\t\t * The minimum output value. This number is output when \n\t\t * the value input value is 0. \n\t\t * @memberOf Tone.Scale#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.Scale.prototype, 'min', {\n\t        get: function () {\n\t            return this._outputMin;\n\t        },\n\t        set: function (min) {\n\t            this._outputMin = min;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output value. This number is output when \n\t\t * the value input value is 1. \n\t\t * @memberOf Tone.Scale#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.Scale.prototype, 'max', {\n\t        get: function () {\n\t            return this._outputMax;\n\t        },\n\t        set: function (max) {\n\t            this._outputMax = max;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t *  set the values\n\t\t *  @private\n\t\t */\n\t    Tone.Scale.prototype._setRange = function () {\n\t        this._add.value = this._outputMin;\n\t        this._scale.value = this._outputMax - this._outputMin;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Scale} this\n\t\t */\n\t    Tone.Scale.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._add.dispose();\n\t        this._add = null;\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        return this;\n\t    };\n\t    return Tone.Scale;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class  Performs an exponential scaling on an input signal.\n\t\t *          Scales a NormalRange value [0,1] exponentially\n\t\t *          to the output range of outputMin to outputMax.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @param {number} [outputMin=0] The output value when the input is 0. \n\t\t *  @param {number} [outputMax=1]\tThe output value when the input is 1. \n\t\t *  @param {number} [exponent=2] The exponent which scales the incoming signal.\n\t\t *  @example\n\t\t * var scaleExp = new Tone.ScaleExp(0, 100, 2);\n\t\t * var signal = new Tone.Signal(0.5).connect(scaleExp);\n\t\t */\n\t    Tone.ScaleExp = function (outputMin, outputMax, exponent) {\n\t        /**\n\t\t\t *  scale the input to the output range\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.output = new Tone.Scale(outputMin, outputMax);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Pow}\n\t\t\t *  @private\n\t\t\t */\n\t        this._exp = this.input = new Tone.Pow(this.defaultArg(exponent, 2));\n\t        this._exp.connect(this._scale);\n\t    };\n\t    Tone.extend(Tone.ScaleExp, Tone.SignalBase);\n\t    /**\n\t\t * Instead of interpolating linearly between the <code>min</code> and \n\t\t * <code>max</code> values, setting the exponent will interpolate between\n\t\t * the two values with an exponential curve. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t * The minimum output value. This number is output when \n\t\t * the value input value is 0. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'min', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output value. This number is output when \n\t\t * the value input value is 1. \n\t\t * @memberOf Tone.ScaleExp#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.ScaleExp.prototype, 'max', {\n\t        get: function () {\n\t            return this._scale.max;\n\t        },\n\t        set: function (max) {\n\t            this._scale.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.ScaleExp} this\n\t\t */\n\t    Tone.ScaleExp.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._exp.dispose();\n\t        this._exp = null;\n\t        return this;\n\t    };\n\t    return Tone.ScaleExp;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  createDelay shim\n\t\t *  @private\n\t\t */\n\t    if (window.DelayNode && !AudioContext.prototype.createDelay) {\n\t        AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface). \n\t\t *  @extends {Tone}\n\t\t *  @param {Time=} delayTime The delay applied to the incoming signal.\n\t\t *  @param {Time=} maxDelay The maximum delay time. \n\t\t */\n\t    Tone.Delay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'maxDelay'\n\t        ], Tone.Delay.defaults);\n\t        /**\n\t\t\t *  The native delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = this.input = this.output = this.context.createDelay(this.toSeconds(options.maxDelay));\n\t        /**\n\t\t\t *  The amount of time the incoming signal is\n\t\t\t *  delayed. \n\t\t\t *  @type {Tone.Param}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = new Tone.Param({\n\t            'param': this._delayNode.delayTime,\n\t            'units': Tone.Type.Time,\n\t            'value': options.delayTime\n\t        });\n\t        this._readOnly('delayTime');\n\t    };\n\t    Tone.extend(Tone.Delay);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Delay.defaults = {\n\t        'maxDelay': 1,\n\t        'delayTime': 0\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Delay}  this\n\t\t */\n\t    Tone.Delay.prototype.dispose = function () {\n\t        Tone.Param.prototype.dispose.call(this);\n\t        this._delayNode.disconnect();\n\t        this._delayNode = null;\n\t        this._writable('delayTime');\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.Delay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Comb filters are basic building blocks for physical modeling. Read more\n\t\t *         about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [delayTime] The delay time of the filter. \n\t\t *  @param {NormalRange=} resonance The amount of feedback the filter has. \n\t\t */\n\t    Tone.FeedbackCombFilter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'resonance'\n\t        ], Tone.FeedbackCombFilter.defaults);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = this.input = this.output = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The amount of delay of the comb filter. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delay.delayTime;\n\t        /**\n\t\t\t *  the feedback node\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of feedback of the delayed signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._feedback.gain;\n\t        this._delay.chain(this._feedback, this._delay);\n\t        this._readOnly([\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FeedbackCombFilter);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackCombFilter.defaults = {\n\t        'delayTime': 0.1,\n\t        'resonance': 0.5\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FeedbackCombFilter} this\n\t\t */\n\t    Tone.FeedbackCombFilter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this.delayTime = null;\n\t        this._feedback.dispose();\n\t        this._feedback = null;\n\t        this.resonance = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackCombFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Follower is a  crude envelope follower which will follow \n\t\t *          the amplitude of an incoming signal. \n\t\t *          Take care with small (< 0.02) attack or decay values \n\t\t *          as follower has some ripple which is exaggerated\n\t\t *          at these values. Read more about envelope followers (also known \n\t\t *          as envelope detectors) on [Wikipedia](https://en.wikipedia.org/wiki/Envelope_detector).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Time|Object} [attack] The rate at which the follower rises.\n\t\t *  @param {Time=} release The rate at which the folower falls. \n\t\t *  @example\n\t\t * var follower = new Tone.Follower(0.2, 0.4);\n\t\t */\n\t    Tone.Follower = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'release'\n\t        ], Tone.Follower.defaults);\n\t        /**\n\t\t\t *  @type {Tone.Abs}\n\t\t\t *  @private\n\t\t\t */\n\t        this._abs = new Tone.Abs();\n\t        /**\n\t\t\t *  the lowpass filter which smooths the input\n\t\t\t *  @type {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filter = this.context.createBiquadFilter();\n\t        this._filter.type = 'lowpass';\n\t        this._filter.frequency.value = 0;\n\t        this._filter.Q.value = -100;\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._frequencyValues = new Tone.WaveShaper();\n\t        /**\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sub = new Tone.Subtract();\n\t        /**\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = new Tone.Delay(this.blockTime);\n\t        /**\n\t\t\t *  this keeps it far from 0, even for very small differences\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mult = new Tone.Multiply(10000);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._attack = options.attack;\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._release = options.release;\n\t        //the smoothed signal to get the values\n\t        this.input.chain(this._abs, this._filter, this.output);\n\t        //the difference path\n\t        this._abs.connect(this._sub, 0, 1);\n\t        this._filter.chain(this._delay, this._sub);\n\t        //threshold the difference and use the thresh to set the frequency\n\t        this._sub.chain(this._mult, this._frequencyValues, this._filter.frequency);\n\t        //set the attack and release values in the table\n\t        this._setAttackRelease(this._attack, this._release);\n\t    };\n\t    Tone.extend(Tone.Follower);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Follower.defaults = {\n\t        'attack': 0.05,\n\t        'release': 0.5\n\t    };\n\t    /**\n\t\t *  sets the attack and release times in the wave shaper\n\t\t *  @param   {Time} attack  \n\t\t *  @param   {Time} release \n\t\t *  @private\n\t\t */\n\t    Tone.Follower.prototype._setAttackRelease = function (attack, release) {\n\t        var minTime = this.blockTime;\n\t        attack = Tone.Time(attack).toFrequency();\n\t        release = Tone.Time(release).toFrequency();\n\t        attack = Math.max(attack, minTime);\n\t        release = Math.max(release, minTime);\n\t        this._frequencyValues.setMap(function (val) {\n\t            if (val <= 0) {\n\t                return attack;\n\t            } else {\n\t                return release;\n\t            }\n\t        });\n\t    };\n\t    /**\n\t\t * The attack time.\n\t\t * @memberOf Tone.Follower#\n\t\t * @type {Time}\n\t\t * @name attack\n\t\t */\n\t    Object.defineProperty(Tone.Follower.prototype, 'attack', {\n\t        get: function () {\n\t            return this._attack;\n\t        },\n\t        set: function (attack) {\n\t            this._attack = attack;\n\t            this._setAttackRelease(this._attack, this._release);\n\t        }\n\t    });\n\t    /**\n\t\t * The release time.\n\t\t * @memberOf Tone.Follower#\n\t\t * @type {Time}\n\t\t * @name release\n\t\t */\n\t    Object.defineProperty(Tone.Follower.prototype, 'release', {\n\t        get: function () {\n\t            return this._release;\n\t        },\n\t        set: function (release) {\n\t            this._release = release;\n\t            this._setAttackRelease(this._attack, this._release);\n\t        }\n\t    });\n\t    /**\n\t\t *  Borrows the connect method from Signal so that the output can be used\n\t\t *  as a Tone.Signal control signal.\n\t\t *  @function\n\t\t */\n\t    Tone.Follower.prototype.connect = Tone.Signal.prototype.connect;\n\t    /**\n\t\t *  dispose\n\t\t *  @returns {Tone.Follower} this\n\t\t */\n\t    Tone.Follower.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._filter.disconnect();\n\t        this._filter = null;\n\t        this._frequencyValues.disconnect();\n\t        this._frequencyValues = null;\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this._sub.disconnect();\n\t        this._sub = null;\n\t        this._abs.dispose();\n\t        this._abs = null;\n\t        this._mult.dispose();\n\t        this._mult = null;\n\t        this._curve = null;\n\t        return this;\n\t    };\n\t    return Tone.Follower;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.ScaledEnvelop is an envelope which can be scaled \n\t\t *         to any range. It's useful for applying an envelope \n\t\t *         to a frequency or any other non-NormalRange signal \n\t\t *         parameter. \n\t\t *\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [attack]\tthe attack time in seconds\n\t\t *  @param {Time} [decay]\tthe decay time in seconds\n\t\t *  @param {number} [sustain] \ta percentage (0-1) of the full amplitude\n\t\t *  @param {Time} [release]\tthe release time in seconds\n\t\t *  @example\n\t\t *  var scaledEnv = new Tone.ScaledEnvelope({\n\t\t *  \t\"attack\" : 0.2,\n\t\t *  \t\"min\" : 200,\n\t\t *  \t\"max\" : 2000\n\t\t *  });\n\t\t *  scaledEnv.connect(oscillator.frequency);\n\t\t */\n\t    Tone.ScaledEnvelope = function () {\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        Tone.Envelope.call(this, options);\n\t        options = this.defaultArg(options, Tone.ScaledEnvelope.defaults);\n\t        /** \n\t\t\t *  scale the incoming signal by an exponent\n\t\t\t *  @type {Tone.Pow}\n\t\t\t *  @private\n\t\t\t */\n\t        this._exp = this.output = new Tone.Pow(options.exponent);\n\t        /**\n\t\t\t *  scale the signal to the desired range\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = this.output = new Tone.Scale(options.min, options.max);\n\t        this._sig.chain(this._exp, this._scale);\n\t    };\n\t    Tone.extend(Tone.ScaledEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.ScaledEnvelope.defaults = {\n\t        'min': 0,\n\t        'max': 1,\n\t        'exponent': 1\n\t    };\n\t    /**\n\t\t * The envelope's min output value. This is the value which it\n\t\t * starts at. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'min', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's max output value. In other words, the value\n\t\t * at the peak of the attack portion of the envelope. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'max', {\n\t        get: function () {\n\t            return this._scale.max;\n\t        },\n\t        set: function (max) {\n\t            this._scale.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's exponent value. \n\t\t * @memberOf Tone.ScaledEnvelope#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.ScaledEnvelope.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.ScaledEnvelope} this\n\t\t */\n\t    Tone.ScaledEnvelope.prototype.dispose = function () {\n\t        Tone.Envelope.prototype.dispose.call(this);\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._exp.dispose();\n\t        this._exp = null;\n\t        return this;\n\t    };\n\t    return Tone.ScaledEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FrequencyEnvelope is a Tone.ScaledEnvelope, but instead of `min` and `max`\n\t\t *         it's got a `baseFrequency` and `octaves` parameter. \n\t\t *\n\t\t *  @extends {Tone.Envelope}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [attack]\tthe attack time in seconds\n\t\t *  @param {Time} [decay]\tthe decay time in seconds\n\t\t *  @param {number} [sustain] \ta percentage (0-1) of the full amplitude\n\t\t *  @param {Time} [release]\tthe release time in seconds\n\t\t *  @example\n\t\t *  var env = new Tone.FrequencyEnvelope({\n\t\t *  \t\"attack\" : 0.2,\n\t\t *  \t\"baseFrequency\" : \"C2\",\n\t\t *  \t\"octaves\" : 4\n\t\t *  });\n\t\t *  scaledEnv.connect(oscillator.frequency);\n\t\t */\n\t    Tone.FrequencyEnvelope = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'attack',\n\t            'decay',\n\t            'sustain',\n\t            'release'\n\t        ], Tone.Envelope.defaults);\n\t        Tone.ScaledEnvelope.call(this, options);\n\t        options = this.defaultArg(options, Tone.FrequencyEnvelope.defaults);\n\t        /**\n\t\t\t *  Stores the octave value\n\t\t\t *  @type {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        //setup\n\t        this.baseFrequency = options.baseFrequency;\n\t        this.octaves = options.octaves;\n\t    };\n\t    Tone.extend(Tone.FrequencyEnvelope, Tone.Envelope);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.FrequencyEnvelope.defaults = {\n\t        'baseFrequency': 200,\n\t        'octaves': 4,\n\t        'exponent': 2\n\t    };\n\t    /**\n\t\t * The envelope's mininum output value. This is the value which it\n\t\t * starts at. \n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {Frequency}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._scale.min;\n\t        },\n\t        set: function (min) {\n\t            this._scale.min = this.toFrequency(min);\n\t            //also update the octaves\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t * The number of octaves above the baseFrequency that the\n\t\t * envelope will scale to.\n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            this._scale.max = this.baseFrequency * Math.pow(2, octaves);\n\t        }\n\t    });\n\t    /**\n\t\t * The envelope's exponent value. \n\t\t * @memberOf Tone.FrequencyEnvelope#\n\t\t * @type {number}\n\t\t * @name exponent\n\t\t */\n\t    Object.defineProperty(Tone.FrequencyEnvelope.prototype, 'exponent', {\n\t        get: function () {\n\t            return this._exp.value;\n\t        },\n\t        set: function (exp) {\n\t            this._exp.value = exp;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FrequencyEnvelope} this\n\t\t */\n\t    Tone.FrequencyEnvelope.prototype.dispose = function () {\n\t        Tone.ScaledEnvelope.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.FrequencyEnvelope;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Gate only passes a signal through when the incoming \n\t\t *          signal exceeds a specified threshold. To do this, Gate uses \n\t\t *          a Tone.Follower to follow the amplitude of the incoming signal. \n\t\t *          A common implementation of this class is a [Noise Gate](https://en.wikipedia.org/wiki/Noise_gate).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Decibels|Object} [threshold] The threshold above which the gate will open. \n\t\t *  @param {Time=} attack The follower's attack time\n\t\t *  @param {Time=} release The follower's release time\n\t\t *  @example\n\t\t * var gate = new Tone.Gate(-30, 0.2, 0.3).toMaster();\n\t\t * var mic = new Tone.UserMedia().connect(gate);\n\t\t * //the gate will only pass through the incoming \n\t\t * //signal when it's louder than -30db\n\t\t */\n\t    Tone.Gate = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'threshold',\n\t            'attack',\n\t            'release'\n\t        ], Tone.Gate.defaults);\n\t        /**\n\t\t\t *  @type {Tone.Follower}\n\t\t\t *  @private\n\t\t\t */\n\t        this._follower = new Tone.Follower(options.attack, options.release);\n\t        /**\n\t\t\t *  @type {Tone.GreaterThan}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gt = new Tone.GreaterThan(this.dbToGain(options.threshold));\n\t        //the connections\n\t        this.input.connect(this.output);\n\t        //the control signal\n\t        this.input.chain(this._gt, this._follower, this.output.gain);\n\t    };\n\t    Tone.extend(Tone.Gate);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Gate.defaults = {\n\t        'attack': 0.1,\n\t        'release': 0.1,\n\t        'threshold': -40\n\t    };\n\t    /**\n\t\t * The threshold of the gate in decibels\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Decibels}\n\t\t * @name threshold\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'threshold', {\n\t        get: function () {\n\t            return this.gainToDb(this._gt.value);\n\t        },\n\t        set: function (thresh) {\n\t            this._gt.value = this.dbToGain(thresh);\n\t        }\n\t    });\n\t    /**\n\t\t * The attack speed of the gate\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Time}\n\t\t * @name attack\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'attack', {\n\t        get: function () {\n\t            return this._follower.attack;\n\t        },\n\t        set: function (attackTime) {\n\t            this._follower.attack = attackTime;\n\t        }\n\t    });\n\t    /**\n\t\t * The release speed of the gate\n\t\t * @memberOf Tone.Gate#\n\t\t * @type {Time}\n\t\t * @name release\n\t\t */\n\t    Object.defineProperty(Tone.Gate.prototype, 'release', {\n\t        get: function () {\n\t            return this._follower.release;\n\t        },\n\t        set: function (releaseTime) {\n\t            this._follower.release = releaseTime;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Gate} this\n\t\t */\n\t    Tone.Gate.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._follower.dispose();\n\t        this._gt.dispose();\n\t        this._follower = null;\n\t        this._gt = null;\n\t        return this;\n\t    };\n\t    return Tone.Gate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A Timeline State. Provides the methods: <code>setStateAtTime(\"state\", time)</code>\n\t\t *          and <code>getValueAtTime(time)</code>.\n\t\t *\n\t\t *  @extends {Tone.Timeline}\n\t\t *  @param {String} initial The initial state of the TimelineState. \n\t\t *                          Defaults to <code>undefined</code>\n\t\t */\n\t    Tone.TimelineState = function (initial) {\n\t        Tone.Timeline.call(this);\n\t        /**\n\t\t\t *  The initial state\n\t\t\t *  @private\n\t\t\t *  @type {String}\n\t\t\t */\n\t        this._initial = initial;\n\t    };\n\t    Tone.extend(Tone.TimelineState, Tone.Timeline);\n\t    /**\n\t\t *  Returns the scheduled state scheduled before or at\n\t\t *  the given time.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @return  {String}  The name of the state input in setStateAtTime.\n\t\t */\n\t    Tone.TimelineState.prototype.getValueAtTime = function (time) {\n\t        var event = this.get(time);\n\t        if (event !== null) {\n\t            return event.state;\n\t        } else {\n\t            return this._initial;\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the scheduled state scheduled before or at\n\t\t *  the given time.\n\t\t *  @param  {String}  state The name of the state to set.\n\t\t *  @param  {Number}  time  The time to query.\n\t\t */\n\t    Tone.TimelineState.prototype.setStateAtTime = function (state, time) {\n\t        this.add({\n\t            'state': state,\n\t            'time': time\n\t        });\n\t    };\n\t    return Tone.TimelineState;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A sample accurate clock which provides a callback at the given rate. \n\t\t *          While the callback is not sample-accurate (it is still susceptible to\n\t\t *          loose JS timing), the time passed in as the argument to the callback\n\t\t *          is precise. For most applications, it is better to use Tone.Transport\n\t\t *          instead of the Clock by itself since you can synchronize multiple callbacks.\n\t\t *\n\t\t * \t@constructor\n\t\t *  @extends {Tone.Emitter}\n\t\t * \t@param {function} callback The callback to be invoked with the time of the audio event\n\t\t * \t@param {Frequency} frequency The rate of the callback\n\t\t * \t@example\n\t\t * //the callback will be invoked approximately once a second\n\t\t * //and will print the time exactly once a second apart.\n\t\t * var clock = new Tone.Clock(function(time){\n\t\t * \tconsole.log(time);\n\t\t * }, 1);\n\t\t */\n\t    Tone.Clock = function () {\n\t        Tone.Emitter.call(this);\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'frequency'\n\t        ], Tone.Clock.defaults);\n\t        /**\n\t\t\t *  The callback function to invoke at the scheduled tick.\n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  The next time the callback is scheduled.\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._nextTick = 0;\n\t        /**\n\t\t\t *  The last state of the clock.\n\t\t\t *  @type  {State}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lastState = Tone.State.Stopped;\n\t        /**\n\t\t\t *  The rate the callback function should be invoked. \n\t\t\t *  @type  {BPM}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.TimelineSignal(options.frequency, Tone.Type.Frequency);\n\t        this._readOnly('frequency');\n\t        /**\n\t\t\t *  The number of times the callback was invoked. Starts counting at 0\n\t\t\t *  and increments after the callback was invoked. \n\t\t\t *  @type {Ticks}\n\t\t\t *  @readOnly\n\t\t\t */\n\t        this.ticks = 0;\n\t        /**\n\t\t\t *  The state timeline\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  The loop function bound to its context. \n\t\t\t *  This is necessary to remove the event in the end.\n\t\t\t *  @type {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._boundLoop = this._loop.bind(this);\n\t        //bind a callback to the worker thread\n\t        this.context.on('tick', this._boundLoop);\n\t    };\n\t    Tone.extend(Tone.Clock, Tone.Emitter);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Clock.defaults = {\n\t        'callback': Tone.noOp,\n\t        'frequency': 1,\n\t        'lookAhead': 'auto'\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Clock#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Clock.prototype, 'state', {\n\t        get: function () {\n\t            return this._state.getValueAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the clock at the given time. Optionally pass in an offset\n\t\t *  of where to start the tick counter from.\n\t\t *  @param  {Time}  time    The time the clock should start\n\t\t *  @param  {Ticks=}  offset  Where the tick counter starts counting from.\n\t\t *  @return  {Tone.Clock}  this\n\t\t */\n\t    Tone.Clock.prototype.start = function (time, offset) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) !== Tone.State.Started) {\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': time,\n\t                'offset': offset\n\t            });\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the clock. Stopping the clock resets the tick counter to 0.\n\t\t *  @param {Time} [time=now] The time when the clock should stop.\n\t\t *  @returns {Tone.Clock} this\n\t\t *  @example\n\t\t * clock.stop();\n\t\t */\n\t    Tone.Clock.prototype.stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._state.cancel(time);\n\t        this._state.setStateAtTime(Tone.State.Stopped, time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Pause the clock. Pausing does not reset the tick counter.\n\t\t *  @param {Time} [time=now] The time when the clock should stop.\n\t\t *  @returns {Tone.Clock} this\n\t\t */\n\t    Tone.Clock.prototype.pause = function (time) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this._state.setStateAtTime(Tone.State.Paused, time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The scheduling loop.\n\t\t *  @param  {Number}  time  The current page time starting from 0\n\t\t *                          when the page was loaded.\n\t\t *  @private\n\t\t */\n\t    Tone.Clock.prototype._loop = function () {\n\t        //get the frequency value to compute the value of the next loop\n\t        var now = this.now();\n\t        //if it's started\n\t        var lookAhead = this.context.lookAhead;\n\t        var updateInterval = this.context.updateInterval;\n\t        var lagCompensation = this.context.lag * 2;\n\t        var loopInterval = now + lookAhead + updateInterval + lagCompensation;\n\t        while (loopInterval > this._nextTick && this._state) {\n\t            var currentState = this._state.getValueAtTime(this._nextTick);\n\t            if (currentState !== this._lastState) {\n\t                this._lastState = currentState;\n\t                var event = this._state.get(this._nextTick);\n\t                // emit an event\n\t                if (currentState === Tone.State.Started) {\n\t                    //correct the time\n\t                    this._nextTick = event.time;\n\t                    if (!this.isUndef(event.offset)) {\n\t                        this.ticks = event.offset;\n\t                    }\n\t                    this.emit('start', event.time, this.ticks);\n\t                } else if (currentState === Tone.State.Stopped) {\n\t                    this.ticks = 0;\n\t                    this.emit('stop', event.time);\n\t                } else if (currentState === Tone.State.Paused) {\n\t                    this.emit('pause', event.time);\n\t                }\n\t            }\n\t            var tickTime = this._nextTick;\n\t            if (this.frequency) {\n\t                this._nextTick += 1 / this.frequency.getValueAtTime(this._nextTick);\n\t                if (currentState === Tone.State.Started) {\n\t                    this.callback(tickTime);\n\t                    this.ticks++;\n\t                }\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the scheduled state at the given time.\n\t\t *  @param  {Time}  time  The time to query.\n\t\t *  @return  {String}  The name of the state input in setStateAtTime.\n\t\t *  @example\n\t\t * clock.start(\"+0.1\");\n\t\t * clock.getStateAtTime(\"+0.1\"); //returns \"started\"\n\t\t */\n\t    Tone.Clock.prototype.getStateAtTime = function (time) {\n\t        time = this.toSeconds(time);\n\t        return this._state.getValueAtTime(time);\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.Clock} this\n\t\t */\n\t    Tone.Clock.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this.context.off('tick', this._boundLoop);\n\t        this._writable('frequency');\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._boundLoop = null;\n\t        this._nextTick = Infinity;\n\t        this.callback = null;\n\t        this._state.dispose();\n\t        this._state = null;\n\t    };\n\t    return Tone.Clock;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Similar to Tone.Timeline, but all events represent\n\t\t *         intervals with both \"time\" and \"duration\" times. The \n\t\t *         events are placed in a tree structure optimized\n\t\t *         for querying an intersection point with the timeline\n\t\t *         events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n\t\t *         to represent the data.\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.IntervalTimeline = function () {\n\t        /**\n\t\t\t *  The root node of the inteval tree\n\t\t\t *  @type  {IntervalNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._root = null;\n\t        /**\n\t\t\t *  Keep track of the length of the timeline.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._length = 0;\n\t    };\n\t    Tone.extend(Tone.IntervalTimeline);\n\t    /**\n\t\t *  The event to add to the timeline. All events must \n\t\t *  have a time and duration value\n\t\t *  @param  {Object}  event  The event to add to the timeline\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.add = function (event) {\n\t        if (this.isUndef(event.time) || this.isUndef(event.duration)) {\n\t            throw new Error('Tone.IntervalTimeline: events must have time and duration parameters');\n\t        }\n\t        var node = new IntervalNode(event.time, event.time + event.duration, event);\n\t        if (this._root === null) {\n\t            this._root = node;\n\t        } else {\n\t            this._root.insert(node);\n\t        }\n\t        this._length++;\n\t        // Restructure tree to be balanced\n\t        while (node !== null) {\n\t            node.updateHeight();\n\t            node.updateMax();\n\t            this._rebalance(node);\n\t            node = node.parent;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove an event from the timeline.\n\t\t *  @param  {Object}  event  The event to remove from the timeline\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.remove = function (event) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(event.time, results);\n\t            for (var i = 0; i < results.length; i++) {\n\t                var node = results[i];\n\t                if (node.event === event) {\n\t                    this._removeNode(node);\n\t                    this._length--;\n\t                    break;\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The number of items in the timeline.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.IntervalTimeline#\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.IntervalTimeline.prototype, 'length', {\n\t        get: function () {\n\t            return this._length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Remove events whose time time is after the given time\n\t\t *  @param  {Number}  time  The time to query.\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.cancel = function (after) {\n\t        this.forEachAfter(after, function (event) {\n\t            this.remove(event);\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the root node as the given node\n\t\t *  @param {IntervalNode} node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._setRoot = function (node) {\n\t        this._root = node;\n\t        if (this._root !== null) {\n\t            this._root.parent = null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Replace the references to the node in the node's parent\n\t\t *  with the replacement node.\n\t\t *  @param  {IntervalNode}  node        \n\t\t *  @param  {IntervalNode}  replacement \n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._replaceNodeInParent = function (node, replacement) {\n\t        if (node.parent !== null) {\n\t            if (node.isLeftChild()) {\n\t                node.parent.left = replacement;\n\t            } else {\n\t                node.parent.right = replacement;\n\t            }\n\t            this._rebalance(node.parent);\n\t        } else {\n\t            this._setRoot(replacement);\n\t        }\n\t    };\n\t    /**\n\t\t *  Remove the node from the tree and replace it with \n\t\t *  a successor which follows the schema.\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._removeNode = function (node) {\n\t        if (node.left === null && node.right === null) {\n\t            this._replaceNodeInParent(node, null);\n\t        } else if (node.right === null) {\n\t            this._replaceNodeInParent(node, node.left);\n\t        } else if (node.left === null) {\n\t            this._replaceNodeInParent(node, node.right);\n\t        } else {\n\t            var balance = node.getBalance();\n\t            var replacement, temp;\n\t            if (balance > 0) {\n\t                if (node.left.right === null) {\n\t                    replacement = node.left;\n\t                    replacement.right = node.right;\n\t                    temp = replacement;\n\t                } else {\n\t                    replacement = node.left.right;\n\t                    while (replacement.right !== null) {\n\t                        replacement = replacement.right;\n\t                    }\n\t                    replacement.parent.right = replacement.left;\n\t                    temp = replacement.parent;\n\t                    replacement.left = node.left;\n\t                    replacement.right = node.right;\n\t                }\n\t            } else {\n\t                if (node.right.left === null) {\n\t                    replacement = node.right;\n\t                    replacement.left = node.left;\n\t                    temp = replacement;\n\t                } else {\n\t                    replacement = node.right.left;\n\t                    while (replacement.left !== null) {\n\t                        replacement = replacement.left;\n\t                    }\n\t                    replacement.parent = replacement.parent;\n\t                    replacement.parent.left = replacement.right;\n\t                    temp = replacement.parent;\n\t                    replacement.left = node.left;\n\t                    replacement.right = node.right;\n\t                }\n\t            }\n\t            if (node.parent !== null) {\n\t                if (node.isLeftChild()) {\n\t                    node.parent.left = replacement;\n\t                } else {\n\t                    node.parent.right = replacement;\n\t                }\n\t            } else {\n\t                this._setRoot(replacement);\n\t            }\n\t            // this._replaceNodeInParent(node, replacement);\n\t            this._rebalance(temp);\n\t        }\n\t        node.dispose();\n\t    };\n\t    /**\n\t\t *  Rotate the tree to the left\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rotateLeft = function (node) {\n\t        var parent = node.parent;\n\t        var isLeftChild = node.isLeftChild();\n\t        // Make node.right the new root of this sub tree (instead of node)\n\t        var pivotNode = node.right;\n\t        node.right = pivotNode.left;\n\t        pivotNode.left = node;\n\t        if (parent !== null) {\n\t            if (isLeftChild) {\n\t                parent.left = pivotNode;\n\t            } else {\n\t                parent.right = pivotNode;\n\t            }\n\t        } else {\n\t            this._setRoot(pivotNode);\n\t        }\n\t    };\n\t    /**\n\t\t *  Rotate the tree to the right\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rotateRight = function (node) {\n\t        var parent = node.parent;\n\t        var isLeftChild = node.isLeftChild();\n\t        // Make node.left the new root of this sub tree (instead of node)\n\t        var pivotNode = node.left;\n\t        node.left = pivotNode.right;\n\t        pivotNode.right = node;\n\t        if (parent !== null) {\n\t            if (isLeftChild) {\n\t                parent.left = pivotNode;\n\t            } else {\n\t                parent.right = pivotNode;\n\t            }\n\t        } else {\n\t            this._setRoot(pivotNode);\n\t        }\n\t    };\n\t    /**\n\t\t *  Balance the BST\n\t\t *  @param  {IntervalNode}  node\n\t\t *  @private\n\t\t */\n\t    Tone.IntervalTimeline.prototype._rebalance = function (node) {\n\t        var balance = node.getBalance();\n\t        if (balance > 1) {\n\t            if (node.left.getBalance() < 0) {\n\t                this._rotateLeft(node.left);\n\t            } else {\n\t                this._rotateRight(node);\n\t            }\n\t        } else if (balance < -1) {\n\t            if (node.right.getBalance() > 0) {\n\t                this._rotateRight(node.right);\n\t            } else {\n\t                this._rotateLeft(node);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Get an event whose time and duration span the give time. Will\n\t\t *  return the match whose \"time\" value is closest to the given time.\n\t\t *  @param  {Object}  event  The event to add to the timeline\n\t\t *  @return  {Object}  The event which spans the desired time\n\t\t */\n\t    Tone.IntervalTimeline.prototype.get = function (time) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(time, results);\n\t            if (results.length > 0) {\n\t                var max = results[0];\n\t                for (var i = 1; i < results.length; i++) {\n\t                    if (results[i].low > max.low) {\n\t                        max = results[i];\n\t                    }\n\t                }\n\t                return max.event;\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the timeline.\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEach = function (callback) {\n\t        if (this._root !== null) {\n\t            var allNodes = [];\n\t            if (this._root !== null) {\n\t                this._root.traverse(function (node) {\n\t                    allNodes.push(node);\n\t                });\n\t            }\n\t            for (var i = 0; i < allNodes.length; i++) {\n\t                var ev = allNodes[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array in which the given time\n\t\t *  overlaps with the time and duration time of the event.\n\t\t *  @param  {Number}  time The time to check if items are overlapping\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEachAtTime = function (time, callback) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.search(time, results);\n\t            for (var i = results.length - 1; i >= 0; i--) {\n\t                var ev = results[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over everything in the array in which the time is greater\n\t\t *  than the given time.\n\t\t *  @param  {Number}  time The time to check if items are before\n\t\t *  @param  {Function}  callback The callback to invoke with every item\n\t\t *  @returns {Tone.IntervalTimeline} this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.forEachAfter = function (time, callback) {\n\t        if (this._root !== null) {\n\t            var results = [];\n\t            this._root.searchAfter(time, results);\n\t            for (var i = results.length - 1; i >= 0; i--) {\n\t                var ev = results[i].event;\n\t                if (ev) {\n\t                    callback(ev);\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.IntervalTimeline}  this\n\t\t */\n\t    Tone.IntervalTimeline.prototype.dispose = function () {\n\t        var allNodes = [];\n\t        if (this._root !== null) {\n\t            this._root.traverse(function (node) {\n\t                allNodes.push(node);\n\t            });\n\t        }\n\t        for (var i = 0; i < allNodes.length; i++) {\n\t            allNodes[i].dispose();\n\t        }\n\t        allNodes = null;\n\t        this._root = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tINTERVAL NODE HELPER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Represents a node in the binary search tree, with the addition\n\t\t *  of a \"high\" value which keeps track of the highest value of\n\t\t *  its children. \n\t\t *  References: \n\t\t *  https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n\t\t *  http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n\t\t *  @param {Number} low\n\t\t *  @param {Number} high\n\t\t *  @private\n\t\t */\n\t    var IntervalNode = function (low, high, event) {\n\t        //the event container\n\t        this.event = event;\n\t        //the low value\n\t        this.low = low;\n\t        //the high value\n\t        this.high = high;\n\t        //the high value for this and all child nodes\n\t        this.max = this.high;\n\t        //the nodes to the left\n\t        this._left = null;\n\t        //the nodes to the right\n\t        this._right = null;\n\t        //the parent node\n\t        this.parent = null;\n\t        //the number of child nodes\n\t        this.height = 0;\n\t    };\n\t    /** \n\t\t *  Insert a node into the correct spot in the tree\n\t\t *  @param  {IntervalNode}  node\n\t\t */\n\t    IntervalNode.prototype.insert = function (node) {\n\t        if (node.low <= this.low) {\n\t            if (this.left === null) {\n\t                this.left = node;\n\t            } else {\n\t                this.left.insert(node);\n\t            }\n\t        } else {\n\t            if (this.right === null) {\n\t                this.right = node;\n\t            } else {\n\t                this.right.insert(node);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  Search the tree for nodes which overlap \n\t\t *  with the given point\n\t\t *  @param  {Number}  point  The point to query\n\t\t *  @param  {Array}  results  The array to put the results\n\t\t */\n\t    IntervalNode.prototype.search = function (point, results) {\n\t        // If p is to the right of the rightmost point of any interval\n\t        // in this node and all children, there won't be any matches.\n\t        if (point > this.max) {\n\t            return;\n\t        }\n\t        // Search left children\n\t        if (this.left !== null) {\n\t            this.left.search(point, results);\n\t        }\n\t        // Check this node\n\t        if (this.low <= point && this.high > point) {\n\t            results.push(this);\n\t        }\n\t        // If p is to the left of the time of this interval,\n\t        // then it can't be in any child to the right.\n\t        if (this.low > point) {\n\t            return;\n\t        }\n\t        // Search right children\n\t        if (this.right !== null) {\n\t            this.right.search(point, results);\n\t        }\n\t    };\n\t    /**\n\t\t *  Search the tree for nodes which are less \n\t\t *  than the given point\n\t\t *  @param  {Number}  point  The point to query\n\t\t *  @param  {Array}  results  The array to put the results\n\t\t */\n\t    IntervalNode.prototype.searchAfter = function (point, results) {\n\t        // Check this node\n\t        if (this.low >= point) {\n\t            results.push(this);\n\t            if (this.left !== null) {\n\t                this.left.searchAfter(point, results);\n\t            }\n\t        }\n\t        // search the right side\n\t        if (this.right !== null) {\n\t            this.right.searchAfter(point, results);\n\t        }\n\t    };\n\t    /**\n\t\t *  Invoke the callback on this element and both it's branches\n\t\t *  @param  {Function}  callback\n\t\t */\n\t    IntervalNode.prototype.traverse = function (callback) {\n\t        callback(this);\n\t        if (this.left !== null) {\n\t            this.left.traverse(callback);\n\t        }\n\t        if (this.right !== null) {\n\t            this.right.traverse(callback);\n\t        }\n\t    };\n\t    /**\n\t\t *  Update the height of the node\n\t\t */\n\t    IntervalNode.prototype.updateHeight = function () {\n\t        if (this.left !== null && this.right !== null) {\n\t            this.height = Math.max(this.left.height, this.right.height) + 1;\n\t        } else if (this.right !== null) {\n\t            this.height = this.right.height + 1;\n\t        } else if (this.left !== null) {\n\t            this.height = this.left.height + 1;\n\t        } else {\n\t            this.height = 0;\n\t        }\n\t    };\n\t    /**\n\t\t *  Update the height of the node\n\t\t */\n\t    IntervalNode.prototype.updateMax = function () {\n\t        this.max = this.high;\n\t        if (this.left !== null) {\n\t            this.max = Math.max(this.max, this.left.max);\n\t        }\n\t        if (this.right !== null) {\n\t            this.max = Math.max(this.max, this.right.max);\n\t        }\n\t    };\n\t    /**\n\t\t *  The balance is how the leafs are distributed on the node\n\t\t *  @return  {Number}  Negative numbers are balanced to the right\n\t\t */\n\t    IntervalNode.prototype.getBalance = function () {\n\t        var balance = 0;\n\t        if (this.left !== null && this.right !== null) {\n\t            balance = this.left.height - this.right.height;\n\t        } else if (this.left !== null) {\n\t            balance = this.left.height + 1;\n\t        } else if (this.right !== null) {\n\t            balance = -(this.right.height + 1);\n\t        }\n\t        return balance;\n\t    };\n\t    /**\n\t\t *  @returns {Boolean} true if this node is the left child\n\t\t *  of its parent\n\t\t */\n\t    IntervalNode.prototype.isLeftChild = function () {\n\t        return this.parent !== null && this.parent.left === this;\n\t    };\n\t    /**\n\t\t *  get/set the left node\n\t\t *  @type {IntervalNode}\n\t\t */\n\t    Object.defineProperty(IntervalNode.prototype, 'left', {\n\t        get: function () {\n\t            return this._left;\n\t        },\n\t        set: function (node) {\n\t            this._left = node;\n\t            if (node !== null) {\n\t                node.parent = this;\n\t            }\n\t            this.updateHeight();\n\t            this.updateMax();\n\t        }\n\t    });\n\t    /**\n\t\t *  get/set the right node\n\t\t *  @type {IntervalNode}\n\t\t */\n\t    Object.defineProperty(IntervalNode.prototype, 'right', {\n\t        get: function () {\n\t            return this._right;\n\t        },\n\t        set: function (node) {\n\t            this._right = node;\n\t            if (node !== null) {\n\t                node.parent = this;\n\t            }\n\t            this.updateHeight();\n\t            this.updateMax();\n\t        }\n\t    });\n\t    /**\n\t\t *  null out references.\n\t\t */\n\t    IntervalNode.prototype.dispose = function () {\n\t        this.parent = null;\n\t        this._left = null;\n\t        this._right = null;\n\t        this.event = null;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tEND INTERVAL NODE HELPER\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    return Tone.IntervalTimeline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Transport for timing musical events.\n\t\t *          Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n\t\t *          Tone.Transport timing events pass in the exact time of the scheduled event\n\t\t *          in the argument of the callback function. Pass that time value to the object\n\t\t *          you're scheduling. <br><br>\n\t\t *          A single transport is created for you when the library is initialized. \n\t\t *          <br><br>\n\t\t *          The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n\t\t *          called with the time of that event as the argument. \n\t\t *\n\t\t *  @extends {Tone.Emitter}\n\t\t *  @singleton\n\t\t *  @example\n\t\t * //repeated event every 8th note\n\t\t * Tone.Transport.scheduleRepeat(function(time){\n\t\t * \t//do something with the time\n\t\t * }, \"8n\");\n\t\t *  @example\n\t\t * //schedule an event on the 16th measure\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \t//do something with the time\n\t\t * }, \"16:0:0\");\n\t\t */\n\t    Tone.Transport = function () {\n\t        Tone.Emitter.call(this);\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tLOOPING\n\t        //////////////////////////////////////////////////////////////////////\n\t        /** \n\t\t\t * \tIf the transport loops or not.\n\t\t\t *  @type {boolean}\n\t\t\t */\n\t        this.loop = false;\n\t        /** \n\t\t\t * \tThe loop start position in ticks\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = 0;\n\t        /** \n\t\t\t * \tThe loop end position in ticks\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = 0;\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tCLOCK/TEMPO\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  Pulses per quarter is the number of ticks per quarter note.\n\t\t\t *  @private\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this._ppq = TransportConstructor.defaults.PPQ;\n\t        /**\n\t\t\t *  watches the main oscillator for timing ticks\n\t\t\t *  initially starts at 120bpm\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Clock}\n\t\t\t */\n\t        this._clock = new Tone.Clock({\n\t            'callback': this._processTick.bind(this),\n\t            'frequency': 0\n\t        });\n\t        this._bindClockEvents();\n\t        /**\n\t\t\t *  The Beats Per Minute of the Transport. \n\t\t\t *  @type {BPM}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * Tone.Transport.bpm.value = 80;\n\t\t\t * //ramp the bpm to 120 over 10 seconds\n\t\t\t * Tone.Transport.bpm.rampTo(120, 10);\n\t\t\t */\n\t        this.bpm = this._clock.frequency;\n\t        this.bpm._toUnits = this._toUnits.bind(this);\n\t        this.bpm._fromUnits = this._fromUnits.bind(this);\n\t        this.bpm.units = Tone.Type.BPM;\n\t        this.bpm.value = TransportConstructor.defaults.bpm;\n\t        this._readOnly('bpm');\n\t        /**\n\t\t\t *  The time signature, or more accurately the numerator\n\t\t\t *  of the time signature over a denominator of 4. \n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeSignature = TransportConstructor.defaults.timeSignature;\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tTIMELINE EVENTS\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  All the events in an object to keep track by ID\n\t\t\t *  @type {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scheduledEvents = {};\n\t        /**\n\t\t\t *  The event ID counter\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._eventID = 0;\n\t        /**\n\t\t\t * \tThe scheduled events.\n\t\t\t *  @type {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._timeline = new Tone.Timeline();\n\t        /**\n\t\t\t *  Repeated events\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._repeatedEvents = new Tone.IntervalTimeline();\n\t        /**\n\t\t\t *  Events that occur once\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._onceEvents = new Tone.Timeline();\n\t        /** \n\t\t\t *  All of the synced Signals\n\t\t\t *  @private \n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this._syncedSignals = [];\n\t        ///////////////////////////////////////////////////////////////////////\n\t        //\tSWING\n\t        //////////////////////////////////////////////////////////////////////\n\t        /**\n\t\t\t *  The subdivision of the swing\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._swingTicks = TransportConstructor.defaults.PPQ / 2;\n\t        //8n\n\t        /**\n\t\t\t *  The swing amount\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._swingAmount = 0;\n\t    };\n\t    Tone.extend(Tone.Transport, Tone.Emitter);\n\t    /**\n\t\t *  the defaults\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Transport.defaults = {\n\t        'bpm': 120,\n\t        'swing': 0,\n\t        'swingSubdivision': '8n',\n\t        'timeSignature': 4,\n\t        'loopStart': 0,\n\t        'loopEnd': '4m',\n\t        'PPQ': 192\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tTICKS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  called on every tick\n\t\t *  @param   {number} tickTime clock relative tick time\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._processTick = function (tickTime) {\n\t        var ticks = this._clock.ticks;\n\t        //handle swing\n\t        if (this._swingAmount > 0 && ticks % this._ppq !== 0 && //not on a downbeat\n\t            ticks % (this._swingTicks * 2) !== 0) {\n\t            //add some swing\n\t            var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\t            var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\t            tickTime += Tone.Time(this._swingTicks * 2 / 3, 'i') * amount;\n\t        }\n\t        //do the loop test\n\t        if (this.loop) {\n\t            if (ticks === this._loopEnd) {\n\t                this.emit('loopEnd', tickTime);\n\t                this._clock.ticks = this._loopStart;\n\t                ticks = this._loopStart;\n\t                this.emit('loopStart', tickTime, this.seconds);\n\t                this.emit('loop', tickTime);\n\t            }\n\t        }\n\t        //process the single occurrence events\n\t        this._onceEvents.forEachBefore(ticks, function (event) {\n\t            event.callback(tickTime);\n\t            //remove the event\n\t            delete this._scheduledEvents[event.id.toString()];\n\t        }.bind(this));\n\t        //and clear the single occurrence timeline\n\t        this._onceEvents.cancelBefore(ticks);\n\t        //fire the next tick events if their time has come\n\t        this._timeline.forEachAtTime(ticks, function (event) {\n\t            event.callback(tickTime);\n\t        });\n\t        //process the repeated events\n\t        this._repeatedEvents.forEachAtTime(ticks, function (event) {\n\t            if ((ticks - event.time) % event.interval === 0) {\n\t                event.callback(tickTime);\n\t            }\n\t        });\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSCHEDULABLE EVENTS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Schedule an event along the timeline.\n\t\t *  @param {Function} callback The callback to be invoked at the time.\n\t\t *  @param {TransportTime}  time The time to invoke the callback at.\n\t\t *  @return {Number} The id of the event which can be used for canceling the event. \n\t\t *  @example\n\t\t * //trigger the callback when the Transport reaches the desired time\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \tenvelope.triggerAttack(time);\n\t\t * }, \"128i\");\n\t\t */\n\t    Tone.Transport.prototype.schedule = function (callback, time) {\n\t        var event = {\n\t            'time': this.toTicks(time),\n\t            'callback': callback\n\t        };\n\t        var id = this._eventID++;\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._timeline\n\t        };\n\t        this._timeline.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Schedule a repeated event along the timeline. The event will fire\n\t\t *  at the `interval` starting at the `startTime` and for the specified\n\t\t *  `duration`. \n\t\t *  @param  {Function}  callback   The callback to invoke.\n\t\t *  @param  {Time}    interval   The duration between successive\n\t\t *                               callbacks.\n\t\t *  @param  {TimelinePosition=}    startTime  When along the timeline the events should\n\t\t *                               start being invoked.\n\t\t *  @param {Time} [duration=Infinity] How long the event should repeat. \n\t\t *  @return  {Number}    The ID of the scheduled event. Use this to cancel\n\t\t *                           the event. \n\t\t *  @example\n\t\t * //a callback invoked every eighth note after the first measure\n\t\t * Tone.Transport.scheduleRepeat(callback, \"8n\", \"1m\");\n\t\t */\n\t    Tone.Transport.prototype.scheduleRepeat = function (callback, interval, startTime, duration) {\n\t        if (interval <= 0) {\n\t            throw new Error('Tone.Transport: repeat events must have an interval larger than 0');\n\t        }\n\t        var event = {\n\t            'time': this.toTicks(startTime),\n\t            'duration': this.toTicks(this.defaultArg(duration, Infinity)),\n\t            'interval': this.toTicks(interval),\n\t            'callback': callback\n\t        };\n\t        var id = this._eventID++;\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._repeatedEvents\n\t        };\n\t        this._repeatedEvents.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Schedule an event that will be removed after it is invoked. \n\t\t *  Note that if the given time is less than the current transport time, \n\t\t *  the event will be invoked immediately. \n\t\t *  @param {Function} callback The callback to invoke once.\n\t\t *  @param {TransportTime} time The time the callback should be invoked.\n\t\t *  @returns {Number} The ID of the scheduled event. \n\t\t */\n\t    Tone.Transport.prototype.scheduleOnce = function (callback, time) {\n\t        var id = this._eventID++;\n\t        var event = {\n\t            'time': this.toTicks(time),\n\t            'callback': callback,\n\t            'id': id\n\t        };\n\t        this._scheduledEvents[id.toString()] = {\n\t            'event': event,\n\t            'timeline': this._onceEvents\n\t        };\n\t        this._onceEvents.add(event);\n\t        return id;\n\t    };\n\t    /**\n\t\t *  Clear the passed in event id from the timeline\n\t\t *  @param {Number} eventId The id of the event.\n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.clear = function (eventId) {\n\t        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t            var item = this._scheduledEvents[eventId.toString()];\n\t            item.timeline.remove(item.event);\n\t            delete this._scheduledEvents[eventId.toString()];\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove scheduled events from the timeline after\n\t\t *  the given time. Repeated events will be removed\n\t\t *  if their startTime is after the given time\n\t\t *  @param {TransportTime} [after=0] Clear all events after\n\t\t *                          this time. \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.cancel = function (after) {\n\t        after = this.defaultArg(after, 0);\n\t        after = this.toTicks(after);\n\t        this._timeline.cancel(after);\n\t        this._onceEvents.cancel(after);\n\t        this._repeatedEvents.cancel(after);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSTART/STOP/PAUSE\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Bind start/stop/pause events from the clock and emit them.\n\t\t */\n\t    Tone.Transport.prototype._bindClockEvents = function () {\n\t        this._clock.on('start', function (time, offset) {\n\t            offset = Tone.Time(this._clock.ticks, 'i').toSeconds();\n\t            this.emit('start', time, offset);\n\t        }.bind(this));\n\t        this._clock.on('stop', function (time) {\n\t            this.emit('stop', time);\n\t        }.bind(this));\n\t        this._clock.on('pause', function (time) {\n\t            this.emit('pause', time);\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'state', {\n\t        get: function () {\n\t            return this._clock.getStateAtTime(this.now());\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now] The time when the transport should start.\n\t\t *  @param  {TransportTime=} offset The timeline offset to start the transport.\n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * //start the transport in one second starting at beginning of the 5th measure. \n\t\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t\t */\n\t    Tone.Transport.prototype.start = function (time, offset) {\n\t        //start the clock\n\t        if (!this.isUndef(offset)) {\n\t            offset = this.toTicks(offset);\n\t        }\n\t        this._clock.start(time, offset);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now] The time when the transport should stop. \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * Tone.Transport.stop();\n\t\t */\n\t    Tone.Transport.prototype.stop = function (time) {\n\t        this._clock.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Pause the transport and all sources synced to the transport.\n\t\t *  @param  {Time} [time=now]\n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.pause = function (time) {\n\t        this._clock.pause(time);\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSETTERS/GETTERS\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  The time signature as just the numerator over 4. \n\t\t *  For example 4/4 would be just 4 and 6/8 would be 3.\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Number|Array}\n\t\t *  @name timeSignature\n\t\t *  @example\n\t\t * //common time\n\t\t * Tone.Transport.timeSignature = 4;\n\t\t * // 7/8\n\t\t * Tone.Transport.timeSignature = [7, 8];\n\t\t * //this will be reduced to a single number\n\t\t * Tone.Transport.timeSignature; //returns 3.5\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'timeSignature', {\n\t        get: function () {\n\t            return this._timeSignature;\n\t        },\n\t        set: function (timeSig) {\n\t            if (this.isArray(timeSig)) {\n\t                timeSig = timeSig[0] / timeSig[1] * 4;\n\t            }\n\t            this._timeSignature = timeSig;\n\t        }\n\t    });\n\t    /**\n\t\t * When the Tone.Transport.loop = true, this is the starting position of the loop.\n\t\t * @memberOf Tone.Transport#\n\t\t * @type {TransportTime}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toSeconds();\n\t        },\n\t        set: function (startPosition) {\n\t            this._loopStart = this.toTicks(startPosition);\n\t        }\n\t    });\n\t    /**\n\t\t * When the Tone.Transport.loop = true, this is the ending position of the loop.\n\t\t * @memberOf Tone.Transport#\n\t\t * @type {TransportTime}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toSeconds();\n\t        },\n\t        set: function (endPosition) {\n\t            this._loopEnd = this.toTicks(endPosition);\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the loop start and stop at the same time. \n\t\t *  @param {TransportTime} startPosition \n\t\t *  @param {TransportTime} endPosition   \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @example\n\t\t * //loop over the first measure\n\t\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t\t * Tone.Transport.loop = true;\n\t\t */\n\t    Tone.Transport.prototype.setLoopPoints = function (startPosition, endPosition) {\n\t        this.loopStart = startPosition;\n\t        this.loopEnd = endPosition;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The swing value. Between 0-1 where 1 equal to \n\t\t *  the note + half the subdivision.\n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {NormalRange}\n\t\t *  @name swing\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'swing', {\n\t        get: function () {\n\t            return this._swingAmount;\n\t        },\n\t        set: function (amount) {\n\t            //scale the values to a normal range\n\t            this._swingAmount = amount;\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the subdivision which the swing will be applied to. \n\t\t *  The default value is an 8th note. Value must be less \n\t\t *  than a quarter note.\n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Time}\n\t\t *  @name swingSubdivision\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'swingSubdivision', {\n\t        get: function () {\n\t            return Tone.Time(this._swingTicks, 'i').toNotation();\n\t        },\n\t        set: function (subdivision) {\n\t            this._swingTicks = this.toTicks(subdivision);\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's position in Bars:Beats:Sixteenths.\n\t\t *  Setting the value will jump to that position right away. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {BarsBeatsSixteenths}\n\t\t *  @name position\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'position', {\n\t        get: function () {\n\t            return Tone.TransportTime(this.ticks, 'i').toBarsBeatsSixteenths();\n\t        },\n\t        set: function (progress) {\n\t            var ticks = this.toTicks(progress);\n\t            this.ticks = ticks;\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's position in seconds\n\t\t *  Setting the value will jump to that position right away. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Seconds}\n\t\t *  @name seconds\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'seconds', {\n\t        get: function () {\n\t            return Tone.TransportTime(this.ticks, 'i').toSeconds();\n\t        },\n\t        set: function (progress) {\n\t            var ticks = this.toTicks(progress);\n\t            this.ticks = ticks;\n\t        }\n\t    });\n\t    /**\n\t\t *  The Transport's loop position as a normalized value. Always\n\t\t *  returns 0 if the transport if loop is not true. \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @name progress\n\t\t *  @type {NormalRange}\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'progress', {\n\t        get: function () {\n\t            if (this.loop) {\n\t                return (this.ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The transports current tick position.\n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Ticks}\n\t\t *  @name ticks\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'ticks', {\n\t        get: function () {\n\t            return this._clock.ticks;\n\t        },\n\t        set: function (t) {\n\t            if (this._clock.ticks !== t) {\n\t                var now = this.now();\n\t                //stop everything synced to the transport\n\t                if (this.state === Tone.State.Started) {\n\t                    this.emit('stop', now);\n\t                    this._clock.ticks = t;\n\t                    //restart it with the new time\n\t                    this.emit('start', now, this.seconds);\n\t                } else {\n\t                    this._clock.ticks = t;\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Pulses Per Quarter note. This is the smallest resolution\n\t\t *  the Transport timing supports. This should be set once\n\t\t *  on initialization and not set again. Changing this value \n\t\t *  after other objects have been created can cause problems. \n\t\t *  \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Number}\n\t\t *  @name PPQ\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'PPQ', {\n\t        get: function () {\n\t            return this._ppq;\n\t        },\n\t        set: function (ppq) {\n\t            var bpm = this.bpm.value;\n\t            this._ppq = ppq;\n\t            this.bpm.value = bpm;\n\t        }\n\t    });\n\t    /**\n\t\t *  The hint to the type of playback. Affects tradeoffs between audio \n\t\t *  output latency and responsiveness. \n\t\t *  \n\t\t *  In addition to setting the value in seconds, the latencyHint also\n\t\t *  accepts the strings \"interactive\" (prioritizes low latency), \n\t\t *  \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t\t *  latency and performance), and \"fastest\" (lowest latency, might glitch more often). \n\t\t *  @memberOf Tone.Transport#\n\t\t *  @type {Seconds|String}\n\t\t *  @name latencyHint\n\t\t */\n\t    Object.defineProperty(Tone.Transport.prototype, 'latencyHint', {\n\t        get: function () {\n\t            return Tone.Clock.latencyHint;\n\t        },\n\t        set: function (hint) {\n\t            Tone.Clock.latencyHint = hint;\n\t        }\n\t    });\n\t    /**\n\t\t *  Convert from BPM to frequency (factoring in PPQ)\n\t\t *  @param  {BPM}  bpm The BPM value to convert to frequency\n\t\t *  @return  {Frequency}  The BPM as a frequency with PPQ factored in.\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._fromUnits = function (bpm) {\n\t        return 1 / (60 / bpm / this.PPQ);\n\t    };\n\t    /**\n\t\t *  Convert from frequency (with PPQ) into BPM\n\t\t *  @param  {Frequency}  freq The clocks frequency to convert to BPM\n\t\t *  @return  {BPM}  The frequency value as BPM.\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype._toUnits = function (freq) {\n\t        return freq / this.PPQ * 60;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tSYNCING\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Returns the time aligned to the next subdivision\n\t\t *  of the Transport. If the Transport is not started,\n\t\t *  it will return 0.\n\t\t *  Note: this will not work precisely during tempo ramps.\n\t\t *  @param  {Time}  subdivision  The subdivision to quantize to\n\t\t *  @return  {Number}  The context time of the next subdivision.\n\t\t *  @example\n\t\t * Tone.Transport.start(); //the transport must be started\n\t\t * Tone.Transport.nextSubdivision(\"4n\");\n\t\t */\n\t    Tone.Transport.prototype.nextSubdivision = function (subdivision) {\n\t        subdivision = this.toSeconds(subdivision);\n\t        //if the transport's not started, return 0\n\t        var now;\n\t        if (this.state === Tone.State.Started) {\n\t            now = this._clock._nextTick;\n\t        } else {\n\t            return 0;\n\t        }\n\t        var transportPos = Tone.Time(this.ticks, 'i');\n\t        var remainingTime = subdivision - transportPos % subdivision;\n\t        if (remainingTime === 0) {\n\t            remainingTime = subdivision;\n\t        }\n\t        return now + remainingTime;\n\t    };\n\t    /**\n\t\t *  Attaches the signal to the tempo control signal so that \n\t\t *  any changes in the tempo will change the signal in the same\n\t\t *  ratio. \n\t\t *  \n\t\t *  @param  {Tone.Signal} signal \n\t\t *  @param {number=} ratio Optionally pass in the ratio between\n\t\t *                         the two signals. Otherwise it will be computed\n\t\t *                         based on their current values. \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.syncSignal = function (signal, ratio) {\n\t        if (!ratio) {\n\t            //get the sync ratio\n\t            if (signal._param.value !== 0) {\n\t                ratio = signal._param.value / this.bpm._param.value;\n\t            } else {\n\t                ratio = 0;\n\t            }\n\t        }\n\t        var ratioSignal = new Tone.Gain(ratio);\n\t        this.bpm.chain(ratioSignal, signal._param);\n\t        this._syncedSignals.push({\n\t            'ratio': ratioSignal,\n\t            'signal': signal,\n\t            'initial': signal._param.value\n\t        });\n\t        signal._param.value = 0;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsyncs a previously synced signal from the transport's control. \n\t\t *  See Tone.Transport.syncSignal.\n\t\t *  @param  {Tone.Signal} signal \n\t\t *  @returns {Tone.Transport} this\n\t\t */\n\t    Tone.Transport.prototype.unsyncSignal = function (signal) {\n\t        for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t            var syncedSignal = this._syncedSignals[i];\n\t            if (syncedSignal.signal === signal) {\n\t                syncedSignal.ratio.dispose();\n\t                syncedSignal.signal._param.value = syncedSignal.initial;\n\t                this._syncedSignals.splice(i, 1);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Transport} this\n\t\t *  @private\n\t\t */\n\t    Tone.Transport.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this._clock.dispose();\n\t        this._clock = null;\n\t        this._writable('bpm');\n\t        this.bpm = null;\n\t        this._timeline.dispose();\n\t        this._timeline = null;\n\t        this._onceEvents.dispose();\n\t        this._onceEvents = null;\n\t        this._repeatedEvents.dispose();\n\t        this._repeatedEvents = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    //\tINITIALIZATION\n\t    ///////////////////////////////////////////////////////////////////////////////\n\t    var TransportConstructor = Tone.Transport;\n\t    Tone.Transport = new TransportConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Transport instanceof TransportConstructor) {\n\t            Tone.Transport = context.Transport;\n\t        } else {\n\t            Tone.Transport = new TransportConstructor();\n\t            //store the Transport on the context so it can be retrieved later\n\t            context.Transport = Tone.Transport;\n\t        }\n\t    });\n\t    return Tone.Transport;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Volume is a simple volume node, useful for creating a volume fader. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Decibels} [volume=0] the initial volume\n\t\t *  @example\n\t\t * var vol = new Tone.Volume(-12);\n\t\t * instrument.chain(vol, Tone.Master);\n\t\t */\n\t    Tone.Volume = function () {\n\t        var options = this.optionsObject(arguments, ['volume'], Tone.Volume.defaults);\n\t        /**\n\t\t\t * the output node\n\t\t\t * @type {GainNode}\n\t\t\t * @private\n\t\t\t */\n\t        this.output = this.input = new Tone.Gain(options.volume, Tone.Type.Decibels);\n\t        /**\n\t\t\t * The unmuted volume\n\t\t\t * @type {Decibels}\n\t\t\t * @private\n\t\t\t */\n\t        this._unmutedVolume = options.volume;\n\t        /**\n\t\t\t *  The volume control in decibels. \n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.volume = this.output.gain;\n\t        this._readOnly('volume');\n\t        //set the mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.Volume);\n\t    /**\n\t\t *  Defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Volume.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Volume#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * volume.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Volume.prototype, 'mute', {\n\t        get: function () {\n\t            return this.volume.value === -Infinity;\n\t        },\n\t        set: function (mute) {\n\t            if (!this.mute && mute) {\n\t                this._unmutedVolume = this.volume.value;\n\t                //maybe it should ramp here?\n\t                this.volume.value = -Infinity;\n\t            } else if (this.mute && !mute) {\n\t                this.volume.value = this._unmutedVolume;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Volume} this\n\t\t */\n\t    Tone.Volume.prototype.dispose = function () {\n\t        this.input.dispose();\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('volume');\n\t        this.volume.dispose();\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.Volume;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A single master output which is connected to the\n\t\t *          AudioDestinationNode (aka your speakers). \n\t\t *          It provides useful conveniences such as the ability \n\t\t *          to set the volume and mute the entire application. \n\t\t *          It also gives you the ability to apply master effects to your application. \n\t\t *          <br><br>\n\t\t *          Like Tone.Transport, A single Tone.Master is created\n\t\t *          on initialization and you do not need to explicitly construct one.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @singleton\n\t\t *  @example\n\t\t * //the audio will go from the oscillator to the speakers\n\t\t * oscillator.connect(Tone.Master);\n\t\t * //a convenience for connecting to the master output is also provided:\n\t\t * oscillator.toMaster();\n\t\t * //the above two examples are equivalent.\n\t\t */\n\t    Tone.Master = function () {\n\t        this.createInsOuts(1, 1);\n\t        /**\n\t\t\t *  The private volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume();\n\t        /**\n\t\t\t * The volume of the master output.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        //connections\n\t        this.input.chain(this.output, this.context.destination);\n\t    };\n\t    Tone.extend(Tone.Master);\n\t    /**\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Master.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Master#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * Tone.Master.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Master.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Add a master effects chain. NOTE: this will disconnect any nodes which were previously \n\t\t *  chained in the master effects chain. \n\t\t *  @param {AudioNode|Tone...} args All arguments will be connected in a row\n\t\t *                                  and the Master will be routed through it.\n\t\t *  @return  {Tone.Master}  this\n\t\t *  @example\n\t\t * //some overall compression to keep the levels in check\n\t\t * var masterCompressor = new Tone.Compressor({\n\t\t * \t\"threshold\" : -6,\n\t\t * \t\"ratio\" : 3,\n\t\t * \t\"attack\" : 0.5,\n\t\t * \t\"release\" : 0.1\n\t\t * });\n\t\t * //give a little boost to the lows\n\t\t * var lowBump = new Tone.Filter(200, \"lowshelf\");\n\t\t * //route everything through the filter \n\t\t * //and compressor before going to the speakers\n\t\t * Tone.Master.chain(lowBump, masterCompressor);\n\t\t */\n\t    Tone.Master.prototype.chain = function () {\n\t        this.input.disconnect();\n\t        this.input.chain.apply(this.input, arguments);\n\t        arguments[arguments.length - 1].connect(this.output);\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Master}  this\n\t\t */\n\t    Tone.Master.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //\tAUGMENT TONE's PROTOTYPE\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    /**\n\t\t *  Connect 'this' to the master output. Shorthand for this.connect(Tone.Master)\n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * //connect an oscillator to the master output\n\t\t * var osc = new Tone.Oscillator().toMaster();\n\t\t */\n\t    Tone.prototype.toMaster = function () {\n\t        this.connect(Tone.Master);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Also augment AudioNode's prototype to include toMaster\n\t\t *  as a convenience\n\t\t *  @returns {AudioNode} this\n\t\t */\n\t    AudioNode.prototype.toMaster = function () {\n\t        this.connect(Tone.Master);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  initialize the module and listen for new audio contexts\n\t\t */\n\t    var MasterConstructor = Tone.Master;\n\t    Tone.Master = new MasterConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        // if it already exists, just restore it\n\t        if (context.Master instanceof MasterConstructor) {\n\t            Tone.Master = context.Master;\n\t        } else {\n\t            Tone.Master = new MasterConstructor();\n\t        }\n\t        context.Master = Tone.Master;\n\t    });\n\t    return Tone.Master;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base class for sources. Sources have start/stop methods\n\t\t *          and the ability to be synced to the \n\t\t *          start/stop of Tone.Transport. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * //Multiple state change events can be chained together,\n\t\t * //but must be set in the correct order and with ascending times\n\t\t * \n\t\t * // OK\n\t\t * state.start().stop(\"+0.2\");\n\t\t * // AND\n\t\t * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n\t\t *\n\t\t * // BAD\n\t\t * state.stop(\"+0.2\").start();\n\t\t * // OR\n\t\t * state.start(\"+0.3\").stop(\"+0.2\");\n\t\t * \n\t\t */\n\t    Tone.Source = function (options) {\n\t        // this.createInsOuts(0, 1);\n\t        options = this.defaultArg(options, Tone.Source.defaults);\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        /**\n\t\t\t * \tKeep track of the scheduled state.\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        this._state.memory = 10;\n\t        /**\n\t\t\t *  The synced `start` callback function from the transport\n\t\t\t *  @type {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._synced = false;\n\t        /**\n\t\t\t *  Keep track of all of the scheduled event ids\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scheduled = [];\n\t        //make the output explicitly stereo\n\t        this._volume.output.output.channelCount = 2;\n\t        this._volume.output.output.channelCountMode = 'explicit';\n\t        //mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.Source);\n\t    /**\n\t\t *  The default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Source.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Source#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Source.prototype, 'state', {\n\t        get: function () {\n\t            if (this._synced) {\n\t                if (Tone.Transport.state === Tone.State.Started) {\n\t                    return this._state.getValueAtTime(Tone.Transport.seconds);\n\t                } else {\n\t                    return Tone.State.Stopped;\n\t                }\n\t            } else {\n\t                return this._state.getValueAtTime(this.now());\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.Source#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * source.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.Source.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    //overwrite these functions\n\t    Tone.Source.prototype._start = Tone.noOp;\n\t    Tone.Source.prototype._stop = Tone.noOp;\n\t    /**\n\t\t *  Start the source at the specified time. If no time is given, \n\t\t *  start the source now.\n\t\t *  @param  {Time} [time=now] When the source should be started.\n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * source.start(\"+0.5\"); //starts the source 0.5 seconds from now\n\t\t */\n\t    Tone.Source.prototype.start = function (time, offset, duration) {\n\t        if (this.isUndef(time) && this._synced) {\n\t            time = Tone.Transport.seconds;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        //if it's started, stop it and restart it\n\t        if (!this.retrigger && this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this.stop(time);\n\t        }\n\t        this._state.setStateAtTime(Tone.State.Started, time);\n\t        if (this._synced) {\n\t            // add the offset time to the event\n\t            var event = this._state.get(time);\n\t            event.offset = this.defaultArg(offset, 0);\n\t            event.duration = duration;\n\t            var sched = Tone.Transport.schedule(function (t) {\n\t                this._start(t, offset, duration);\n\t            }.bind(this), time);\n\t            this._scheduled.push(sched);\n\t        } else {\n\t            this._start.apply(this, arguments);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the source at the specified time. If no time is given, \n\t\t *  stop the source now.\n\t\t *  @param  {Time} [time=now] When the source should be stopped. \n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * source.stop(); // stops the source immediately\n\t\t */\n\t    Tone.Source.prototype.stop = function (time) {\n\t        if (this.isUndef(time) && this._synced) {\n\t            time = Tone.Transport.seconds;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._state.cancel(time);\n\t        this._state.setStateAtTime(Tone.State.Stopped, time);\n\t        if (!this._synced) {\n\t            this._stop.apply(this, arguments);\n\t        } else {\n\t            var sched = Tone.Transport.schedule(this._stop.bind(this), time);\n\t            this._scheduled.push(sched);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the source to the Transport so that all subsequent\n\t\t *  calls to `start` and `stop` are synced to the TransportTime\n\t\t *  instead of the AudioContext time. \n\t\t *\n\t\t *  @returns {Tone.Source} this\n\t\t *  @example\n\t\t * //sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t\t * source.sync().start(0).stop(0.3);\n\t\t * //start the transport.\n\t\t * Tone.Transport.start();\n\t\t *\n\t\t *  @example\n\t\t * //start the transport with an offset and the sync'ed sources\n\t\t * //will start in the correct position\n\t\t * source.sync().start(0.1);\n\t\t * //the source will be invoked with an offset of 0.4\n\t\t * Tone.Transport.start(\"+0.5\", 0.5);\n\t\t */\n\t    Tone.Source.prototype.sync = function () {\n\t        this._synced = true;\n\t        Tone.Transport.on('start loopStart', function (time, offset) {\n\t            if (offset > 0) {\n\t                // get the playback state at that time\n\t                var stateEvent = this._state.get(offset);\n\t                // listen for start events which may occur in the middle of the sync'ed time\n\t                if (stateEvent && stateEvent.state === Tone.State.Started && stateEvent.time !== offset) {\n\t                    // get the offset\n\t                    var startOffset = offset - this.toSeconds(stateEvent.time);\n\t                    var duration;\n\t                    if (stateEvent.duration) {\n\t                        duration = this.toSeconds(stateEvent.duration) - startOffset;\n\t                    }\n\t                    this._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t                }\n\t            }\n\t        }.bind(this));\n\t        Tone.Transport.on('stop pause loopEnd', function (time) {\n\t            if (this._state.getValueAtTime(Tone.Transport.seconds) === Tone.State.Started) {\n\t                this._stop(time);\n\t            }\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsync the source to the Transport. See Tone.Source.sync\n\t\t *  @returns {Tone.Source} this\n\t\t */\n\t    Tone.Source.prototype.unsync = function () {\n\t        this._synced = false;\n\t        Tone.Transport.off('start stop pause loopEnd loopStart');\n\t        // clear all of the scheduled ids\n\t        for (var i = 0; i < this._scheduled.length; i++) {\n\t            var id = this._scheduled[i];\n\t            Tone.Transport.clear(id);\n\t        }\n\t        this._scheduled = [];\n\t        this._state.cancel(0);\n\t        return this;\n\t    };\n\t    /**\n\t\t *\tClean up.\n\t\t *  @return {Tone.Source} this\n\t\t */\n\t    Tone.Source.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.unsync();\n\t        this._scheduled = null;\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        this._state.dispose();\n\t        this._state = null;\n\t    };\n\t    return Tone.Source;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  OscillatorNode shim\n\t\t *  @private\n\t\t */\n\t    if (window.OscillatorNode && !OscillatorNode.prototype.start) {\n\t        OscillatorNode.prototype.start = OscillatorNode.prototype.noteOn;\n\t        OscillatorNode.prototype.stop = OscillatorNode.prototype.noteOff;\n\t        if (!OscillatorNode.prototype.setPeriodicWave) {\n\t            OscillatorNode.prototype.setPeriodicWave = OscillatorNode.prototype.setWaveTable;\n\t        }\n\t        if (!AudioContext.prototype.createPeriodicWave) {\n\t            AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable;\n\t        }\n\t    }\n\t    /**\n\t\t *  @class Tone.Oscillator supports a number of features including\n\t\t *         phase rotation, multiple oscillator types (see Tone.Oscillator.type), \n\t\t *         and Transport syncing (see Tone.Oscillator.syncFrequency).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Source}\n\t\t *  @param {Frequency} [frequency] Starting frequency\n\t\t *  @param {string} [type] The oscillator type. Read more about type below.\n\t\t *  @example\n\t\t * //make and start a 440hz sine tone\n\t\t * var osc = new Tone.Oscillator(440, \"sine\").toMaster().start();\n\t\t */\n\t    Tone.Oscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type'\n\t        ], Tone.Oscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  the main oscillator\n\t\t\t *  @type {OscillatorNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = null;\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  the periodic wave\n\t\t\t *  @type {PeriodicWave}\n\t\t\t *  @private\n\t\t\t */\n\t        this._wave = null;\n\t        /**\n\t\t\t *  The partials of the oscillator\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._partials = this.defaultArg(options.partials, [1]);\n\t        /**\n\t\t\t *  the phase of the oscillator\n\t\t\t *  between 0 - 360\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._phase = options.phase;\n\t        /**\n\t\t\t *  the type of the oscillator\n\t\t\t *  @type {string}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = null;\n\t        //setup\n\t        this.type = options.type;\n\t        this.phase = this._phase;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Oscillator, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Oscillator.defaults = {\n\t        'type': 'sine',\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'partials': []\n\t    };\n\t    /**\n\t\t *  The Oscillator types\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Oscillator.Type = {\n\t        Sine: 'sine',\n\t        Triangle: 'triangle',\n\t        Sawtooth: 'sawtooth',\n\t        Square: 'square',\n\t        Custom: 'custom'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now] \n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._start = function (time) {\n\t        //new oscillator with previous values\n\t        this._oscillator = this.context.createOscillator();\n\t        this._oscillator.setPeriodicWave(this._wave);\n\t        //connect the control signal to the oscillator frequency & detune\n\t        this._oscillator.connect(this.output);\n\t        this.frequency.connect(this._oscillator.frequency);\n\t        this.detune.connect(this._oscillator.detune);\n\t        //start the oscillator\n\t        this._oscillator.start(this.toSeconds(time));\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @private\n\t\t *  @param  {Time} [time=now] (optional) timing parameter\n\t\t *  @returns {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype._stop = function (time) {\n\t        if (this._oscillator) {\n\t            this._oscillator.stop(this.toSeconds(time));\n\t            this._oscillator = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t\t *  will also affect the oscillators frequency. \n\t\t *  @returns {Tone.Oscillator} this\n\t\t *  @example\n\t\t * Tone.Transport.bpm.value = 120;\n\t\t * osc.frequency.value = 440;\n\t\t * //the ration between the bpm and the frequency will be maintained\n\t\t * osc.syncFrequency();\n\t\t * Tone.Transport.bpm.value = 240; \n\t\t * // the frequency of the oscillator is doubled to 880\n\t\t */\n\t    Tone.Oscillator.prototype.syncFrequency = function () {\n\t        Tone.Transport.syncSignal(this.frequency);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Unsync the oscillator's frequency from the Transport. \n\t\t *  See Tone.Oscillator.syncFrequency\n\t\t *  @returns {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype.unsyncFrequency = function () {\n\t        Tone.Transport.unsyncSignal(this.frequency);\n\t        return this;\n\t    };\n\t    /**\n\t\t * The type of the oscillator: either sine, square, triangle, or sawtooth. Also capable of\n\t\t * setting the first x number of partials of the oscillator. For example: \"sine4\" would\n\t\t * set be the first 4 partials of the sine wave and \"triangle8\" would set the first\n\t\t * 8 partials of the triangle wave.\n\t\t * <br><br> \n\t\t * Uses PeriodicWave internally even for native types so that it can set the phase. \n\t\t * PeriodicWave equations are from the \n\t\t * [Webkit Web Audio implementation](https://code.google.com/p/chromium/codesearch#chromium/src/third_party/WebKit/Source/modules/webaudio/PeriodicWave.cpp&sq=package:chromium).\n\t\t *  \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t * @example\n\t\t * //set it to a square wave\n\t\t * osc.type = \"square\";\n\t\t * @example\n\t\t * //set the first 6 partials of a sawtooth wave\n\t\t * osc.type = \"sawtooth6\";\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            var coefs = this._getRealImaginary(type, this._phase);\n\t            var periodicWave = this.context.createPeriodicWave(coefs[0], coefs[1]);\n\t            this._wave = periodicWave;\n\t            if (this._oscillator !== null) {\n\t                this._oscillator.setPeriodicWave(this._wave);\n\t            }\n\t            this._type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Returns the real and imaginary components based \n\t\t *  on the oscillator type.\n\t\t *  @returns {Array} [real, imaginary]\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._getRealImaginary = function (type, phase) {\n\t        var fftSize = 4096;\n\t        var periodicWaveSize = fftSize / 2;\n\t        var real = new Float32Array(periodicWaveSize);\n\t        var imag = new Float32Array(periodicWaveSize);\n\t        var partialCount = 1;\n\t        if (type === Tone.Oscillator.Type.Custom) {\n\t            partialCount = this._partials.length + 1;\n\t            periodicWaveSize = partialCount;\n\t        } else {\n\t            var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t            if (partial) {\n\t                partialCount = parseInt(partial[2]) + 1;\n\t                type = partial[1];\n\t                partialCount = Math.max(partialCount, 2);\n\t                periodicWaveSize = partialCount;\n\t            }\n\t        }\n\t        for (var n = 1; n < periodicWaveSize; ++n) {\n\t            var piFactor = 2 / (n * Math.PI);\n\t            var b;\n\t            switch (type) {\n\t            case Tone.Oscillator.Type.Sine:\n\t                b = n <= partialCount ? 1 : 0;\n\t                break;\n\t            case Tone.Oscillator.Type.Square:\n\t                b = n & 1 ? 2 * piFactor : 0;\n\t                break;\n\t            case Tone.Oscillator.Type.Sawtooth:\n\t                b = piFactor * (n & 1 ? 1 : -1);\n\t                break;\n\t            case Tone.Oscillator.Type.Triangle:\n\t                if (n & 1) {\n\t                    b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n\t                } else {\n\t                    b = 0;\n\t                }\n\t                break;\n\t            case Tone.Oscillator.Type.Custom:\n\t                b = this._partials[n - 1];\n\t                break;\n\t            default:\n\t                throw new TypeError('Tone.Oscillator: invalid type: ' + type);\n\t            }\n\t            if (b !== 0) {\n\t                real[n] = -b * Math.sin(phase * n);\n\t                imag[n] = b * Math.cos(phase * n);\n\t            } else {\n\t                real[n] = 0;\n\t                imag[n] = 0;\n\t            }\n\t        }\n\t        return [\n\t            real,\n\t            imag\n\t        ];\n\t    };\n\t    /**\n\t\t *  Compute the inverse FFT for a given phase.\t\n\t\t *  @param  {Float32Array}  real\n\t\t *  @param  {Float32Array}  imag \n\t\t *  @param  {NormalRange}  phase \n\t\t *  @return  {AudioRange}\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._inverseFFT = function (real, imag, phase) {\n\t        var sum = 0;\n\t        var len = real.length;\n\t        for (var i = 0; i < len; i++) {\n\t            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t        }\n\t        return sum;\n\t    };\n\t    /**\n\t\t *  Returns the initial value of the oscillator.\n\t\t *  @return  {AudioRange}\n\t\t *  @private\n\t\t */\n\t    Tone.Oscillator.prototype._getInitialValue = function () {\n\t        var coefs = this._getRealImaginary(this._type, 0);\n\t        var real = coefs[0];\n\t        var imag = coefs[1];\n\t        var maxValue = 0;\n\t        var twoPi = Math.PI * 2;\n\t        //check for peaks in 8 places\n\t        for (var i = 0; i < 8; i++) {\n\t            maxValue = Math.max(this._inverseFFT(real, imag, i / 8 * twoPi), maxValue);\n\t        }\n\t        return -this._inverseFFT(real, imag, this._phase) / maxValue;\n\t    };\n\t    /**\n\t\t * The partials of the waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'partials', {\n\t        get: function () {\n\t            if (this._type !== Tone.Oscillator.Type.Custom) {\n\t                return [];\n\t            } else {\n\t                return this._partials;\n\t            }\n\t        },\n\t        set: function (partials) {\n\t            this._partials = partials;\n\t            this.type = Tone.Oscillator.Type.Custom;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees. \n\t\t * @memberOf Tone.Oscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t * @example\n\t\t * osc.phase = 180; //flips the phase of the oscillator\n\t\t */\n\t    Object.defineProperty(Tone.Oscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._phase * (180 / Math.PI);\n\t        },\n\t        set: function (phase) {\n\t            this._phase = phase * Math.PI / 180;\n\t            //reset the type\n\t            this.type = this._type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Dispose and disconnect.\n\t\t *  @return {Tone.Oscillator} this\n\t\t */\n\t    Tone.Oscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._oscillator !== null) {\n\t            this._oscillator.disconnect();\n\t            this._oscillator = null;\n\t        }\n\t        this._wave = null;\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this._partials = null;\n\t        return this;\n\t    };\n\t    return Tone.Oscillator;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Zero outputs 0's at audio-rate. The reason this has to be\n\t\t *         it's own class is that many browsers optimize out Tone.Signal\n\t\t *         with a value of 0 and will not process nodes further down the graph. \n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Zero = function () {\n\t        /**\n\t\t\t *  The gain node\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gain = this.input = this.output = new Tone.Gain();\n\t        this.context.getConstant(0).connect(this._gain);\n\t    };\n\t    Tone.extend(Tone.Zero);\n\t    /**\n\t\t *  clean up\n\t\t *  @return  {Tone.Zero}  this\n\t\t */\n\t    Tone.Zero.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._gain.dispose();\n\t        this._gain = null;\n\t        return this;\n\t    };\n\t    return Tone.Zero;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  LFO stands for low frequency oscillator. Tone.LFO produces an output signal \n\t\t *          which can be attached to an AudioParam or Tone.Signal \n\t\t *          in order to modulate that parameter with an oscillator. The LFO can \n\t\t *          also be synced to the transport to start/stop and change when the tempo changes.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @param {Frequency|Object} [frequency] The frequency of the oscillation. Typically, LFOs will be\n\t\t *                               in the frequency range of 0.1 to 10 hertz. \n\t\t *  @param {number=} min The minimum output value of the LFO. \n\t\t *  @param {number=} max The maximum value of the LFO. \n\t\t *  @example\n\t\t * var lfo = new Tone.LFO(\"4n\", 400, 4000);\n\t\t * lfo.connect(filter.frequency);\n\t\t */\n\t    Tone.LFO = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'min',\n\t            'max'\n\t        ], Tone.LFO.defaults);\n\t        /** \n\t\t\t *  The oscillator. \n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = new Tone.Oscillator({\n\t            'frequency': options.frequency,\n\t            'type': options.type\n\t        });\n\t        /**\n\t\t\t *  the lfo's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._oscillator.frequency;\n\t        /**\n\t\t\t * The amplitude of the LFO, which controls the output range between\n\t\t\t * the min and max output. For example if the min is -10 and the max \n\t\t\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t\t\t * between -5 and 5. \n\t\t\t * @type {Number}\n\t\t\t * @signal\n\t\t\t */\n\t        this.amplitude = this._oscillator.volume;\n\t        this.amplitude.units = Tone.Type.NormalRange;\n\t        this.amplitude.value = options.amplitude;\n\t        /**\n\t\t\t *  The signal which is output when the LFO is stopped\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stoppedSignal = new Tone.Signal(0, Tone.Type.AudioRange);\n\t        /**\n\t\t\t *  Just outputs zeros.\n\t\t\t *  @type {Tone.Zero}\n\t\t\t *  @private\n\t\t\t */\n\t        this._zeros = new Tone.Zero();\n\t        /**\n\t\t\t *  The value that the LFO outputs when it's stopped\n\t\t\t *  @type {AudioRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stoppedValue = 0;\n\t        /**\n\t\t\t *  @type {Tone.AudioToGain} \n\t\t\t *  @private\n\t\t\t */\n\t        this._a2g = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  @type {Tone.Scale} \n\t\t\t *  @private\n\t\t\t */\n\t        this._scaler = this.output = new Tone.Scale(options.min, options.max);\n\t        /**\n\t\t\t *  the units of the LFO (used for converting)\n\t\t\t *  @type {Tone.Type} \n\t\t\t *  @private\n\t\t\t */\n\t        this._units = Tone.Type.Default;\n\t        this.units = options.units;\n\t        //connect it up\n\t        this._oscillator.chain(this._a2g, this._scaler);\n\t        this._zeros.connect(this._a2g);\n\t        this._stoppedSignal.connect(this._a2g);\n\t        this._readOnly([\n\t            'amplitude',\n\t            'frequency'\n\t        ]);\n\t        this.phase = options.phase;\n\t    };\n\t    Tone.extend(Tone.LFO, Tone.Oscillator);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.LFO.defaults = {\n\t        'type': 'sine',\n\t        'min': 0,\n\t        'max': 1,\n\t        'phase': 0,\n\t        'frequency': '4n',\n\t        'amplitude': 1,\n\t        'units': Tone.Type.Default\n\t    };\n\t    /**\n\t\t *  Start the LFO. \n\t\t *  @param  {Time} [time=now] the time the LFO will start\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._stoppedSignal.setValueAtTime(0, time);\n\t        this._oscillator.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the LFO. \n\t\t *  @param  {Time} [time=now] the time the LFO will stop\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t        this._oscillator.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sync the start/stop/pause to the transport \n\t\t *  and the frequency to the bpm of the transport\n\t\t *  @returns {Tone.LFO} this\n\t\t *  @example\n\t\t *  lfo.frequency.value = \"8n\";\n\t\t *  lfo.sync().start(0)\n\t\t *  //the rate of the LFO will always be an eighth note, \n\t\t *  //even as the tempo changes\n\t\t */\n\t    Tone.LFO.prototype.sync = function () {\n\t        this._oscillator.sync();\n\t        this._oscillator.syncFrequency();\n\t        return this;\n\t    };\n\t    /**\n\t\t *  unsync the LFO from transport control\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.unsync = function () {\n\t        this._oscillator.unsync();\n\t        this._oscillator.unsyncFrequency();\n\t        return this;\n\t    };\n\t    /**\n\t\t * The miniumum output of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'min', {\n\t        get: function () {\n\t            return this._toUnits(this._scaler.min);\n\t        },\n\t        set: function (min) {\n\t            min = this._fromUnits(min);\n\t            this._scaler.min = min;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum output of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'max', {\n\t        get: function () {\n\t            return this._toUnits(this._scaler.max);\n\t        },\n\t        set: function (max) {\n\t            max = this._fromUnits(max);\n\t            this._scaler.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the oscillator: sine, square, sawtooth, triangle. \n\t\t * @memberOf Tone.LFO#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'type', {\n\t        get: function () {\n\t            return this._oscillator.type;\n\t        },\n\t        set: function (type) {\n\t            this._oscillator.type = type;\n\t            this._stoppedValue = this._oscillator._getInitialValue();\n\t            this._stoppedSignal.value = this._stoppedValue;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'phase', {\n\t        get: function () {\n\t            return this._oscillator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._oscillator.phase = phase;\n\t            this._stoppedValue = this._oscillator._getInitialValue();\n\t            this._stoppedSignal.value = this._stoppedValue;\n\t        }\n\t    });\n\t    /**\n\t\t * The output units of the LFO.\n\t\t * @memberOf Tone.LFO#\n\t\t * @type {Tone.Type}\n\t\t * @name units\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'units', {\n\t        get: function () {\n\t            return this._units;\n\t        },\n\t        set: function (val) {\n\t            var currentMin = this.min;\n\t            var currentMax = this.max;\n\t            //convert the min and the max\n\t            this._units = val;\n\t            this.min = currentMin;\n\t            this.max = currentMax;\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.LFO#\n\t\t * @type {Boolean}\n\t\t * @name mute\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'mute', {\n\t        get: function () {\n\t            return this._oscillator.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._oscillator.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.LFO#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.LFO.prototype, 'state', {\n\t        get: function () {\n\t            return this._oscillator.state;\n\t        }\n\t    });\n\t    /**\n\t\t *  Connect the output of the LFO to an AudioParam, AudioNode, or Tone Node. \n\t\t *  Tone.LFO will automatically convert to the destination units of the \n\t\t *  will get the units from the connected node.\n\t\t *  @param  {Tone | AudioParam | AudioNode} node \n\t\t *  @param {number} [outputNum=0] optionally which output to connect from\n\t\t *  @param {number} [inputNum=0] optionally which input to connect to\n\t\t *  @returns {Tone.LFO} this\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype.connect = function (node) {\n\t        if (node.constructor === Tone.Signal || node.constructor === Tone.Param || node.constructor === Tone.TimelineSignal) {\n\t            this.convert = node.convert;\n\t            this.units = node.units;\n\t        }\n\t        Tone.Signal.prototype.connect.apply(this, arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  private method borrowed from Param converts \n\t\t *  units from their destination value\n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype._fromUnits = Tone.Param.prototype._fromUnits;\n\t    /**\n\t\t *  private method borrowed from Param converts \n\t\t *  units to their destination value\n\t\t *  @function\n\t\t *  @private\n\t\t */\n\t    Tone.LFO.prototype._toUnits = Tone.Param.prototype._toUnits;\n\t    /**\n\t\t *  disconnect and dispose\n\t\t *  @returns {Tone.LFO} this\n\t\t */\n\t    Tone.LFO.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'amplitude',\n\t            'frequency'\n\t        ]);\n\t        this._oscillator.dispose();\n\t        this._oscillator = null;\n\t        this._stoppedSignal.dispose();\n\t        this._stoppedSignal = null;\n\t        this._zeros.dispose();\n\t        this._zeros = null;\n\t        this._scaler.dispose();\n\t        this._scaler = null;\n\t        this._a2g.dispose();\n\t        this._a2g = null;\n\t        this.frequency = null;\n\t        this.amplitude = null;\n\t        return this;\n\t    };\n\t    return Tone.LFO;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Limiter will limit the loudness of an incoming signal. \n\t\t *         It is composed of a Tone.Compressor with a fast attack \n\t\t *         and release. Limiters are commonly used to safeguard against \n\t\t *         signal clipping. Unlike a compressor, limiters do not provide \n\t\t *         smooth gain reduction and almost completely prevent \n\t\t *         additional gain above the threshold.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {number} threshold The theshold above which the limiting is applied. \n\t\t *  @example\n\t\t *  var limiter = new Tone.Limiter(-6);\n\t\t */\n\t    Tone.Limiter = function () {\n\t        var options = this.optionsObject(arguments, ['threshold'], Tone.Limiter.defaults);\n\t        /**\n\t\t\t *  the compressor\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this._compressor = this.input = this.output = new Tone.Compressor({\n\t            'attack': 0.001,\n\t            'decay': 0.001,\n\t            'threshold': options.threshold\n\t        });\n\t        /**\n\t\t\t * The threshold of of the limiter\n\t\t\t * @type {Decibel}\n\t\t\t * @signal\n\t\t\t */\n\t        this.threshold = this._compressor.threshold;\n\t        this._readOnly('threshold');\n\t    };\n\t    Tone.extend(Tone.Limiter);\n\t    /**\n\t\t *  The default value\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.Limiter.defaults = { 'threshold': -12 };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Limiter} this\n\t\t */\n\t    Tone.Limiter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._compressor.dispose();\n\t        this._compressor = null;\n\t        this._writable('threshold');\n\t        this.threshold = null;\n\t        return this;\n\t    };\n\t    return Tone.Limiter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Lowpass is a lowpass feedback comb filter. It is similar to \n\t\t *         Tone.FeedbackCombFilter, but includes a lowpass filter.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Time|Object} [delayTime] The delay time of the comb filter\n\t\t *  @param {NormalRange=} resonance The resonance (feedback) of the comb filter\n\t\t *  @param {Frequency=} dampening The cutoff of the lowpass filter dampens the\n\t\t *                                signal as it is fedback. \n\t\t */\n\t    Tone.LowpassCombFilter = function () {\n\t        this.createInsOuts(1, 1);\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'resonance',\n\t            'dampening'\n\t        ], Tone.LowpassCombFilter.defaults);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delay = this.input = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The delayTime of the comb filter. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delay.delayTime;\n\t        /**\n\t\t\t *  the lowpass filter\n\t\t\t *  @type  {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lowpass = this.output = this.context.createBiquadFilter();\n\t        this._lowpass.Q.value = -3.0102999566398125;\n\t        this._lowpass.type = 'lowpass';\n\t        /**\n\t\t\t *  The dampening control of the feedback\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = new Tone.Param({\n\t            'param': this._lowpass.frequency,\n\t            'units': Tone.Type.Frequency,\n\t            'value': options.dampening\n\t        });\n\t        /**\n\t\t\t *  the feedback gain\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedback = new Tone.Gain(options.resonance, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of feedback of the delayed signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._feedback.gain;\n\t        //connections\n\t        this._delay.chain(this._lowpass, this._feedback, this._delay);\n\t        this._readOnly([\n\t            'dampening',\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.LowpassCombFilter);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.LowpassCombFilter.defaults = {\n\t        'delayTime': 0.1,\n\t        'resonance': 0.5,\n\t        'dampening': 3000\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.LowpassCombFilter} this\n\t\t */\n\t    Tone.LowpassCombFilter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'dampening',\n\t            'resonance',\n\t            'delayTime'\n\t        ]);\n\t        this.dampening.dispose();\n\t        this.dampening = null;\n\t        this.resonance.dispose();\n\t        this.resonance = null;\n\t        this._delay.dispose();\n\t        this._delay = null;\n\t        this.delayTime = null;\n\t        this._lowpass.disconnect();\n\t        this._lowpass = null;\n\t        this._feedback.disconnect();\n\t        this._feedback = null;\n\t        return this;\n\t    };\n\t    return Tone.LowpassCombFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Merge brings two signals into the left and right \n\t\t *          channels of a single stereo channel.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var merge = new Tone.Merge().toMaster();\n\t\t * //routing a sine tone in the left channel\n\t\t * //and noise in the right channel\n\t\t * var osc = new Tone.Oscillator().connect(merge.left);\n\t\t * var noise = new Tone.Noise().connect(merge.right);\n\t\t * //starting our oscillators\n\t\t * noise.start();\n\t\t * osc.start();\n\t\t */\n\t    Tone.Merge = function () {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  The left input channel.\n\t\t\t *  Alias for <code>input[0]</code>\n\t\t\t *  @type {GainNode}\n\t\t\t */\n\t        this.left = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  The right input channel.\n\t\t\t *  Alias for <code>input[1]</code>.\n\t\t\t *  @type {GainNode}\n\t\t\t */\n\t        this.right = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t *  the merger node for the two channels\n\t\t\t *  @type {ChannelMergerNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merger = this.output = this.context.createChannelMerger(2);\n\t        //connections\n\t        this.left.connect(this._merger, 0, 0);\n\t        this.right.connect(this._merger, 0, 1);\n\t        this.left.channelCount = 1;\n\t        this.right.channelCount = 1;\n\t        this.left.channelCountMode = 'explicit';\n\t        this.right.channelCountMode = 'explicit';\n\t    };\n\t    Tone.extend(Tone.Merge);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Merge} this\n\t\t */\n\t    Tone.Merge.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.left.dispose();\n\t        this.left = null;\n\t        this.right.dispose();\n\t        this.right = null;\n\t        this._merger.disconnect();\n\t        this._merger = null;\n\t        return this;\n\t    };\n\t    return Tone.Merge;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n\t\t *          of an input signal with some averaging applied. It can also get the raw \n\t\t *          value of the input signal.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {String} type Either \"level\" or \"signal\". \n\t\t *  @param {Number} smoothing The amount of smoothing applied between frames.\n\t\t *  @example\n\t\t * var meter = new Tone.Meter();\n\t\t * var mic = new Tone.UserMedia().start();\n\t\t * //connect mic to the meter\n\t\t * mic.connect(meter);\n\t\t * //the current level of the mic input\n\t\t * var level = meter.value;\n\t\t */\n\t    Tone.Meter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'type',\n\t            'smoothing'\n\t        ], Tone.Meter.defaults);\n\t        /**\n\t\t\t *  The type of the meter, either \"level\" or \"signal\". \n\t\t\t *  A \"level\" meter will return the volume level (rms) of the \n\t\t\t *  input signal and a \"signal\" meter will return\n\t\t\t *  the signal value of the input. \n\t\t\t *  @type  {String}\n\t\t\t */\n\t        this.type = options.type;\n\t        /**\n\t\t\t *  The analyser node which computes the levels.\n\t\t\t *  @private\n\t\t\t *  @type  {Tone.Analyser}\n\t\t\t */\n\t        this.input = this.output = this._analyser = new Tone.Analyser('waveform', 512);\n\t        this._analyser.returnType = 'float';\n\t        /**\n\t\t\t *  The amount of carryover between the current and last frame. \n\t\t\t *  Only applied meter for \"level\" type.\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this.smoothing = options.smoothing;\n\t        /**\n\t\t\t *  The last computed value\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lastValue = 0;\n\t    };\n\t    Tone.extend(Tone.Meter);\n\t    /**\n\t\t *  @private\n\t\t *  @enum {String}\n\t\t */\n\t    Tone.Meter.Type = {\n\t        Level: 'level',\n\t        Signal: 'signal'\n\t    };\n\t    /**\n\t\t *  The defaults\n\t\t *  @type {Object}\n\t\t *  @static\n\t\t *  @const\n\t\t */\n\t    Tone.Meter.defaults = {\n\t        'smoothing': 0.8,\n\t        'type': Tone.Meter.Type.Level\n\t    };\n\t    /**\n\t\t * The current value of the meter. A value of 1 is\n\t\t * \"unity\".\n\t\t * @memberOf Tone.Meter#\n\t\t * @type {Number}\n\t\t * @name value\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Meter.prototype, 'value', {\n\t        get: function () {\n\t            var signal = this._analyser.analyse();\n\t            if (this.type === Tone.Meter.Type.Level) {\n\t                //rms\n\t                var sum = 0;\n\t                for (var i = 0; i < signal.length; i++) {\n\t                    sum += Math.pow(signal[i], 2);\n\t                }\n\t                var rms = Math.sqrt(sum / signal.length);\n\t                //smooth it\n\t                rms = Math.max(rms, this._lastValue * this.smoothing);\n\t                this._lastValue = rms;\n\t                //scale it\n\t                var unity = 0.35;\n\t                var val = rms / unity;\n\t                //scale the output curve\n\t                return Math.sqrt(val);\n\t            } else {\n\t                return signal[0];\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Meter} this\n\t\t */\n\t    Tone.Meter.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._analyser.dispose();\n\t        this._analyser = null;\n\t        return this;\n\t    };\n\t    return Tone.Meter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *\t@class  Tone.Split splits an incoming signal into left and right channels.\n\t\t *\t\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var split = new Tone.Split();\n\t\t * stereoSignal.connect(split);\n\t\t */\n\t    Tone.Split = function () {\n\t        this.createInsOuts(0, 2);\n\t        /** \n\t\t\t *  @type {ChannelSplitterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._splitter = this.input = this.context.createChannelSplitter(2);\n\t        /** \n\t\t\t *  Left channel output. \n\t\t\t *  Alias for <code>output[0]</code>\n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.left = this.output[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  Right channel output.\n\t\t\t *  Alias for <code>output[1]</code>\n\t\t\t *  @type {Tone.Gain}\n\t\t\t */\n\t        this.right = this.output[1] = new Tone.Gain();\n\t        //connections\n\t        this._splitter.connect(this.left, 0, 0);\n\t        this._splitter.connect(this.right, 1, 0);\n\t    };\n\t    Tone.extend(Tone.Split);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Split} this\n\t\t */\n\t    Tone.Split.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._splitter.disconnect();\n\t        this.left.dispose();\n\t        this.left = null;\n\t        this.right.dispose();\n\t        this.right = null;\n\t        this._splitter = null;\n\t        return this;\n\t    };\n\t    return Tone.Split;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels). <br><br>\n\t\t *         <code>\n\t\t *         Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right<br>\n\t\t *         Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and righ<br>\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideSplit = function () {\n\t        this.createInsOuts(0, 2);\n\t        /**\n\t\t\t *  split the incoming signal into left and right channels\n\t\t\t *  @type  {Tone.Split}\n\t\t\t *  @private\n\t\t\t */\n\t        this._split = this.input = new Tone.Split();\n\t        /**\n\t\t\t *  The mid send. Connect to mid processing. Alias for\n\t\t\t *  <code>output[0]</code>\n\t\t\t *  @type {Tone.Expr}\n\t\t\t */\n\t        this.mid = this.output[0] = new Tone.Expr('($0 + $1) * $2');\n\t        /**\n\t\t\t *  The side output. Connect to side processing. Alias for\n\t\t\t *  <code>output[1]</code>\n\t\t\t *  @type {Tone.Expr}\n\t\t\t */\n\t        this.side = this.output[1] = new Tone.Expr('($0 - $1) * $2');\n\t        this._split.connect(this.mid, 0, 0);\n\t        this._split.connect(this.mid, 1, 1);\n\t        this._split.connect(this.side, 0, 0);\n\t        this._split.connect(this.side, 1, 1);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this.mid, 0, 2);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this.side, 0, 2);\n\t    };\n\t    Tone.extend(Tone.MidSideSplit);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MidSideSplit} this\n\t\t */\n\t    Tone.MidSideSplit.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._split.dispose();\n\t        this._split = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideSplit;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels). \n\t\t *         MidSideMerge merges the mid and side signal after they've been seperated\n\t\t *         by Tone.MidSideSplit.<br><br>\n\t\t *         <code>\n\t\t *         Left = (Mid+Side)/sqrt(2);   // obtain left signal from mid and side<br>\n\t\t *         Right = (Mid-Side)/sqrt(2);   // obtain right signal from mid and side<br>\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone.StereoEffect}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideMerge = function () {\n\t        this.createInsOuts(2, 0);\n\t        /**\n\t\t\t *  The mid signal input. Alias for\n\t\t\t *  <code>input[0]</code>\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t */\n\t        this.mid = this.input[0] = new Tone.Gain();\n\t        /**\n\t\t\t *  recombine the mid/side into Left\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._left = new Tone.Expr('($0 + $1) * $2');\n\t        /**\n\t\t\t *  The side signal input. Alias for\n\t\t\t *  <code>input[1]</code>\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t */\n\t        this.side = this.input[1] = new Tone.Gain();\n\t        /**\n\t\t\t *  recombine the mid/side into Right\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._right = new Tone.Expr('($0 - $1) * $2');\n\t        /**\n\t\t\t *  Merge the left/right signal back into a stereo signal.\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = this.output = new Tone.Merge();\n\t        this.mid.connect(this._left, 0, 0);\n\t        this.side.connect(this._left, 0, 1);\n\t        this.mid.connect(this._right, 0, 0);\n\t        this.side.connect(this._right, 0, 1);\n\t        this._left.connect(this._merge, 0, 0);\n\t        this._right.connect(this._merge, 0, 1);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this._left, 0, 2);\n\t        this.context.getConstant(Math.SQRT1_2).connect(this._right, 0, 2);\n\t    };\n\t    Tone.extend(Tone.MidSideMerge);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MidSideMerge} this\n\t\t */\n\t    Tone.MidSideMerge.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._left.dispose();\n\t        this._left = null;\n\t        this._right.dispose();\n\t        this._right = null;\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideMerge;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.MidSideCompressor applies two different compressors to the mid\n\t\t *         and side signal components. See Tone.MidSideSplit. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @param {Object} options The options that are passed to the mid and side\n\t\t *                          compressors. \n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideCompressor = function (options) {\n\t        options = this.defaultArg(options, Tone.MidSideCompressor.defaults);\n\t        /**\n\t\t\t *  the mid/side split\n\t\t\t *  @type  {Tone.MidSideSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideSplit = this.input = new Tone.MidSideSplit();\n\t        /**\n\t\t\t *  the mid/side recombination\n\t\t\t *  @type  {Tone.MidSideMerge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideMerge = this.output = new Tone.MidSideMerge();\n\t        /**\n\t\t\t *  The compressor applied to the mid signal\n\t\t\t *  @type  {Tone.Compressor}\n\t\t\t */\n\t        this.mid = new Tone.Compressor(options.mid);\n\t        /**\n\t\t\t *  The compressor applied to the side signal\n\t\t\t *  @type  {Tone.Compressor}\n\t\t\t */\n\t        this.side = new Tone.Compressor(options.side);\n\t        this._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\t        this._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\t        this._readOnly([\n\t            'mid',\n\t            'side'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MidSideCompressor);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MidSideCompressor.defaults = {\n\t        'mid': {\n\t            'ratio': 3,\n\t            'threshold': -24,\n\t            'release': 0.03,\n\t            'attack': 0.02,\n\t            'knee': 16\n\t        },\n\t        'side': {\n\t            'ratio': 6,\n\t            'threshold': -30,\n\t            'release': 0.25,\n\t            'attack': 0.03,\n\t            'knee': 10\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MidSideCompressor} this\n\t\t */\n\t    Tone.MidSideCompressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'mid',\n\t            'side'\n\t        ]);\n\t        this.mid.dispose();\n\t        this.mid = null;\n\t        this.side.dispose();\n\t        this.side = null;\n\t        this._midSideSplit.dispose();\n\t        this._midSideSplit = null;\n\t        this._midSideMerge.dispose();\n\t        this._midSideMerge = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideCompressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Mono coerces the incoming mono or stereo signal into a mono signal\n\t\t *         where both left and right channels have the same value. This can be useful \n\t\t *         for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t */\n\t    Tone.Mono = function () {\n\t        this.createInsOuts(1, 0);\n\t        /**\n\t\t\t *  merge the signal\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = this.output = new Tone.Merge();\n\t        this.input.connect(this._merge, 0, 0);\n\t        this.input.connect(this._merge, 0, 1);\n\t        this.input.gain.value = this.dbToGain(-10);\n\t    };\n\t    Tone.extend(Tone.Mono);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Mono} this\n\t\t */\n\t    Tone.Mono.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        return this;\n\t    };\n\t    return Tone.Mono;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A compressor with seperate controls over low/mid/high dynamics\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {Object} options The low/mid/high compressor settings.\n\t\t *  @example\n\t\t *  var multiband = new Tone.MultibandCompressor({\n\t\t *  \t\"lowFrequency\" : 200,\n\t\t *  \t\"highFrequency\" : 1300\n\t\t *  \t\"low\" : {\n\t\t *  \t\t\"threshold\" : -12\n\t\t *  \t}\n\t\t *  })\n\t\t */\n\t    Tone.MultibandCompressor = function (options) {\n\t        options = this.defaultArg(arguments, Tone.MultibandCompressor.defaults);\n\t        /**\n\t\t\t *  split the incoming signal into high/mid/low\n\t\t\t *  @type {Tone.MultibandSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._splitter = this.input = new Tone.MultibandSplit({\n\t            'lowFrequency': options.lowFrequency,\n\t            'highFrequency': options.highFrequency\n\t        });\n\t        /**\n\t\t\t *  low/mid crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.lowFrequency = this._splitter.lowFrequency;\n\t        /**\n\t\t\t *  mid/high crossover frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.highFrequency = this._splitter.highFrequency;\n\t        /**\n\t\t\t *  the output\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  The compressor applied to the low frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.low = new Tone.Compressor(options.low);\n\t        /**\n\t\t\t *  The compressor applied to the mid frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.mid = new Tone.Compressor(options.mid);\n\t        /**\n\t\t\t *  The compressor applied to the high frequencies.\n\t\t\t *  @type {Tone.Compressor}\n\t\t\t */\n\t        this.high = new Tone.Compressor(options.high);\n\t        //connect the compressor\n\t        this._splitter.low.chain(this.low, this.output);\n\t        this._splitter.mid.chain(this.mid, this.output);\n\t        this._splitter.high.chain(this.high, this.output);\n\t        this._readOnly([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MultibandCompressor);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MultibandCompressor.defaults = {\n\t        'low': Tone.Compressor.defaults,\n\t        'mid': Tone.Compressor.defaults,\n\t        'high': Tone.Compressor.defaults,\n\t        'lowFrequency': 250,\n\t        'highFrequency': 2000\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MultibandCompressor} this\n\t\t */\n\t    Tone.MultibandCompressor.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._splitter.dispose();\n\t        this._writable([\n\t            'high',\n\t            'mid',\n\t            'low',\n\t            'highFrequency',\n\t            'lowFrequency'\n\t        ]);\n\t        this.low.dispose();\n\t        this.mid.dispose();\n\t        this.high.dispose();\n\t        this._splitter = null;\n\t        this.low = null;\n\t        this.mid = null;\n\t        this.high = null;\n\t        this.lowFrequency = null;\n\t        this.highFrequency = null;\n\t        return this;\n\t    };\n\t    return Tone.MultibandCompressor;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Panner is an equal power Left/Right Panner and does not\n\t\t *          support 3D. Panner uses the StereoPannerNode when available. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {NormalRange} [initialPan=0] The initail panner value (defaults to 0 = center)\n\t\t *  @example\n\t\t *  //pan the input signal hard right. \n\t\t *  var panner = new Tone.Panner(1);\n\t\t */\n\t    Tone.Panner = function (initialPan) {\n\t        if (this._hasStereoPanner) {\n\t            /**\n\t\t\t\t *  the panner node\n\t\t\t\t *  @type {StereoPannerNode}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._panner = this.input = this.output = this.context.createStereoPanner();\n\t            /**\n\t\t\t\t *  The pan control. -1 = hard left, 1 = hard right. \n\t\t\t\t *  @type {NormalRange}\n\t\t\t\t *  @signal\n\t\t\t\t */\n\t            this.pan = this._panner.pan;\n\t        } else {\n\t            /**\n\t\t\t\t *  the dry/wet knob\n\t\t\t\t *  @type {Tone.CrossFade}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._crossFade = new Tone.CrossFade();\n\t            /**\n\t\t\t\t *  @type {Tone.Merge}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._merger = this.output = new Tone.Merge();\n\t            /**\n\t\t\t\t *  @type {Tone.Split}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._splitter = this.input = new Tone.Split();\n\t            /**\n\t\t\t\t *  The pan control. -1 = hard left, 1 = hard right. \n\t\t\t\t *  @type {AudioRange}\n\t\t\t\t *  @signal\n\t\t\t\t */\n\t            this.pan = new Tone.Signal(0, Tone.Type.AudioRange);\n\t            /**\n\t\t\t\t *  always sends 0\n\t\t\t\t *  @type {Tone.Zero}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._zero = new Tone.Zero();\n\t            /**\n\t\t\t\t *  The analog to gain conversion\n\t\t\t\t *  @type  {Tone.AudioToGain}\n\t\t\t\t *  @private\n\t\t\t\t */\n\t            this._a2g = new Tone.AudioToGain();\n\t            //CONNECTIONS:\n\t            this._zero.connect(this._a2g);\n\t            this.pan.chain(this._a2g, this._crossFade.fade);\n\t            //left channel is a, right channel is b\n\t            this._splitter.connect(this._crossFade, 0, 0);\n\t            this._splitter.connect(this._crossFade, 1, 1);\n\t            //merge it back together\n\t            this._crossFade.a.connect(this._merger, 0, 0);\n\t            this._crossFade.b.connect(this._merger, 0, 1);\n\t        }\n\t        //initial value\n\t        this.pan.value = this.defaultArg(initialPan, 0);\n\t        this._readOnly('pan');\n\t    };\n\t    Tone.extend(Tone.Panner);\n\t    /**\n\t\t *  indicates if the panner is using the new StereoPannerNode internally\n\t\t *  @type  {boolean}\n\t\t *  @private\n\t\t */\n\t    Tone.Panner.prototype._hasStereoPanner = Tone.prototype.isFunction(Tone.context.createStereoPanner);\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Panner} this\n\t\t */\n\t    Tone.Panner.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable('pan');\n\t        if (this._hasStereoPanner) {\n\t            this._panner.disconnect();\n\t            this._panner = null;\n\t            this.pan = null;\n\t        } else {\n\t            this._zero.dispose();\n\t            this._zero = null;\n\t            this._crossFade.dispose();\n\t            this._crossFade = null;\n\t            this._splitter.dispose();\n\t            this._splitter = null;\n\t            this._merger.dispose();\n\t            this._merger = null;\n\t            this.pan.dispose();\n\t            this.pan = null;\n\t            this._a2g.dispose();\n\t            this._a2g = null;\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Panner;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  A spatialized panner node which supports equalpower or HRTF panning.\n\t\t *          Tries to normalize the API across various browsers. See Tone.Listener\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Number} positionX The initial x position.\n\t\t *  @param {Number} positionY The initial y position.\n\t\t *  @param {Number} positionZ The initial z position.\n\t\t */\n\t    Tone.Panner3D = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'positionX',\n\t            'positionY',\n\t            'positionZ'\n\t        ], Tone.Panner3D.defaults);\n\t        /**\n\t\t\t *  The panner node\n\t\t\t *  @type {PannerNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = this.input = this.output = this.context.createPanner();\n\t        //set some values\n\t        this._panner.panningModel = options.panningModel;\n\t        this._panner.maxDistance = options.maxDistance;\n\t        this._panner.distanceModel = options.distanceModel;\n\t        this._panner.coneOuterGain = options.coneOuterGain;\n\t        this._panner.coneOuterAngle = options.coneOuterAngle;\n\t        this._panner.coneInnerAngle = options.coneInnerAngle;\n\t        this._panner.refDistance = options.refDistance;\n\t        this._panner.rolloffFactor = options.rolloffFactor;\n\t        /**\n\t\t\t *  Holds the current orientation\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._orientation = [\n\t            options.orientationX,\n\t            options.orientationY,\n\t            options.orientationZ\n\t        ];\n\t        /**\n\t\t\t *  Holds the current position\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._position = [\n\t            options.positionX,\n\t            options.positionY,\n\t            options.positionZ\n\t        ];\n\t        // set the default position/orientation\n\t        this.orientationX = options.orientationX;\n\t        this.orientationY = options.orientationY;\n\t        this.orientationZ = options.orientationZ;\n\t        this.positionX = options.positionX;\n\t        this.positionY = options.positionY;\n\t        this.positionZ = options.positionZ;\n\t    };\n\t    Tone.extend(Tone.Panner3D);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t *  Defaults according to the specification\n\t\t */\n\t    Tone.Panner3D.defaults = {\n\t        'positionX': 0,\n\t        'positionY': 0,\n\t        'positionZ': 0,\n\t        'orientationX': 0,\n\t        'orientationY': 0,\n\t        'orientationZ': 0,\n\t        'panningModel': 'equalpower',\n\t        'maxDistance': 10000,\n\t        'distanceModel': 'inverse',\n\t        'coneOuterGain': 0,\n\t        'coneOuterAngle': 360,\n\t        'coneInnerAngle': 360,\n\t        'refDistance': 1,\n\t        'rolloffFactor': 1\n\t    };\n\t    /**\n\t\t * The ramp time which is applied to the setTargetAtTime\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t    Tone.Panner3D.prototype._rampTimeConstant = 0.01;\n\t    /**\n\t\t *  Sets the position of the source in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.setPosition = function (x, y, z) {\n\t        if (this._panner.positionX) {\n\t            var now = this.now();\n\t            this._panner.positionX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this._panner.positionY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this._panner.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this._panner.setPosition(x, y, z);\n\t        }\n\t        this._position = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the orientation of the source in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.setOrientation = function (x, y, z) {\n\t        if (this._panner.orientationX) {\n\t            var now = this.now();\n\t            this._panner.orientationX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this._panner.orientationY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this._panner.orientationZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this._panner.setOrientation(x, y, z);\n\t        }\n\t        this._orientation = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The x position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionX\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionX', {\n\t        set: function (pos) {\n\t            this._position[0] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionY\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionY', {\n\t        set: function (pos) {\n\t            this._position[1] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name positionZ\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'positionZ', {\n\t        set: function (pos) {\n\t            this._position[2] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationX\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationX', {\n\t        set: function (pos) {\n\t            this._orientation[0] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationY\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationY', {\n\t        set: function (pos) {\n\t            this._orientation[1] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z orientation of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name orientationZ\n\t\t */\n\t    Object.defineProperty(Tone.Panner3D.prototype, 'orientationZ', {\n\t        set: function (pos) {\n\t            this._orientation[2] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  Proxy a property on the panner to an exposed public propery\n\t\t *  @param  {String}  prop\n\t\t *  @private\n\t\t */\n\t    Tone.Panner3D._aliasProperty = function (prop) {\n\t        Object.defineProperty(Tone.Panner3D.prototype, prop, {\n\t            set: function (val) {\n\t                this._panner[prop] = val;\n\t            },\n\t            get: function () {\n\t                return this._panner[prop];\n\t            }\n\t        });\n\t    };\n\t    /**\n\t\t *  The panning model. Either \"equalpower\" or \"HRTF\".\n\t\t *  @type {String}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name panningModel\n\t\t */\n\t    Tone.Panner3D._aliasProperty('panningModel');\n\t    /**\n\t\t *  A reference distance for reducing volume as source move further from the listener\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name refDistance\n\t\t */\n\t    Tone.Panner3D._aliasProperty('refDistance');\n\t    /**\n\t\t *  Describes how quickly the volume is reduced as source moves away from listener.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name rolloffFactor\n\t\t */\n\t    Tone.Panner3D._aliasProperty('rolloffFactor');\n\t    /**\n\t\t *  The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n\t\t *  @type {String}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name distanceModel\n\t\t */\n\t    Tone.Panner3D._aliasProperty('distanceModel');\n\t    /**\n\t\t *  The angle, in degrees, inside of which there will be no volume reduction\n\t\t *  @type {Degrees}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneInnerAngle\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneInnerAngle');\n\t    /**\n\t\t *  The angle, in degrees, outside of which the volume will be reduced \n\t\t *  to a constant value of coneOuterGain\n\t\t *  @type {Degrees}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneOuterAngle\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneOuterAngle');\n\t    /**\n\t\t *  The gain outside of the coneOuterAngle\n\t\t *  @type {Gain}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name coneOuterGain\n\t\t */\n\t    Tone.Panner3D._aliasProperty('coneOuterGain');\n\t    /**\n\t\t *  The maximum distance between source and listener, \n\t\t *  after which the volume will not be reduced any further.\n\t\t *  @type {Positive}\n\t\t *  @memberOf Tone.Panner3D#\n\t\t *  @name maxDistance\n\t\t */\n\t    Tone.Panner3D._aliasProperty('maxDistance');\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Panner3D} this\n\t\t */\n\t    Tone.Panner3D.prototype.dispose = function () {\n\t        this._panner.disconnect();\n\t        this._panner = null;\n\t        this._orientation = null;\n\t        this._position = null;\n\t        return this;\n\t    };\n\t    return Tone.Panner3D;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PanVol is a Tone.Panner and Tone.Volume in one.\n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @constructor\n\t\t *  @param {AudioRange} pan the initial pan\n\t\t *  @param {number} volume The output volume. \n\t\t *  @example\n\t\t * //pan the incoming signal left and drop the volume\n\t\t * var panVol = new Tone.PanVol(0.25, -12);\n\t\t */\n\t    Tone.PanVol = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'pan',\n\t            'volume'\n\t        ], Tone.PanVol.defaults);\n\t        /**\n\t\t\t *  The panning node\n\t\t\t *  @type {Tone.Panner}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = this.input = new Tone.Panner(options.pan);\n\t        /**\n\t\t\t *  The L/R panning control.\n\t\t\t *  @type {AudioRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.pan = this._panner.pan;\n\t        /**\n\t\t\t *  The volume node\n\t\t\t *  @type {Tone.Volume}\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t *  The volume control in decibels. \n\t\t\t *  @type {Decibels}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        //connections\n\t        this._panner.connect(this._volume);\n\t        this._readOnly([\n\t            'pan',\n\t            'volume'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PanVol);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t *  @static\n\t\t */\n\t    Tone.PanVol.defaults = {\n\t        'pan': 0.5,\n\t        'volume': 0\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.PanVol} this\n\t\t */\n\t    Tone.PanVol.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._writable([\n\t            'pan',\n\t            'volume'\n\t        ]);\n\t        this._panner.dispose();\n\t        this._panner = null;\n\t        this.pan = null;\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.PanVol;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.CtrlInterpolate will interpolate between given values based\n\t\t *         on the \"index\" property. Passing in an array or object literal\n\t\t *         will interpolate each of the parameters. Note (i.e. \"C3\")\n\t\t *         and Time (i.e. \"4n + 2\") can be interpolated. All other values are\n\t\t *         assumed to be numbers. \n\t\t *  @example\n\t\t * var interp = new Tone.CtrlInterpolate([0, 2, 9, 4]);\n\t\t * interp.index = 0.75;\n\t\t * interp.value; //returns 1.5\n\t\t *\n\t\t *  @example\n\t\t * var interp = new Tone.CtrlInterpolate([\n\t\t * \t[2, 4, 5],\n\t\t * \t[9, 3, 2],\n\t\t * ]);\n\t\t * @param {Array} values The array of values to interpolate over\n\t\t * @param {Positive} index The initial interpolation index.\n\t\t * @extends {Tone}\n\t\t */\n\t    Tone.CtrlInterpolate = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'values',\n\t            'index'\n\t        ], Tone.CtrlInterpolate.defaults);\n\t        /**\n\t\t\t *  The values to interpolate between\n\t\t\t *  @type  {Array}\n\t\t\t */\n\t        this.values = options.values;\n\t        /**\n\t\t\t *  The interpolated index between values. For example: a value of 1.5\n\t\t\t *  would interpolate equally between the value at index 1\n\t\t\t *  and the value at index 2. \n\t\t\t *  @example\n\t\t\t * interp.index = 0; \n\t\t\t * interp.value; //returns the value at 0\n\t\t\t * interp.index = 0.5;\n\t\t\t * interp.value; //returns the value between indices 0 and 1. \n\t\t\t *  @type  {Positive}\n\t\t\t */\n\t        this.index = options.index;\n\t    };\n\t    Tone.extend(Tone.CtrlInterpolate);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlInterpolate.defaults = {\n\t        'index': 0,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  The current interpolated value based on the index\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlInterpolate#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlInterpolate.prototype, 'value', {\n\t        get: function () {\n\t            var index = this.index;\n\t            index = Math.min(index, this.values.length - 1);\n\t            var lowerPosition = Math.floor(index);\n\t            var lower = this.values[lowerPosition];\n\t            var upper = this.values[Math.ceil(index)];\n\t            return this._interpolate(index - lowerPosition, lower, upper);\n\t        }\n\t    });\n\t    /**\n\t\t *  Internal interpolation routine\n\t\t *  @param  {NormalRange}  index  The index between the lower and upper\n\t\t *  @param  {*}  lower \n\t\t *  @param  {*}  upper \n\t\t *  @return  {*}  The interpolated value\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlInterpolate.prototype._interpolate = function (index, lower, upper) {\n\t        if (this.isArray(lower)) {\n\t            var retArray = [];\n\t            for (var i = 0; i < lower.length; i++) {\n\t                retArray[i] = this._interpolate(index, lower[i], upper[i]);\n\t            }\n\t            return retArray;\n\t        } else if (this.isObject(lower)) {\n\t            var retObj = {};\n\t            for (var attr in lower) {\n\t                retObj[attr] = this._interpolate(index, lower[attr], upper[attr]);\n\t            }\n\t            return retObj;\n\t        } else {\n\t            lower = this._toNumber(lower);\n\t            upper = this._toNumber(upper);\n\t            return (1 - index) * lower + index * upper;\n\t        }\n\t    };\n\t    /**\n\t\t *  Convert from the given type into a number\n\t\t *  @param  {Number|String}  value\n\t\t *  @return  {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlInterpolate.prototype._toNumber = function (val) {\n\t        if (this.isNumber(val)) {\n\t            return val;\n\t        } else {\n\t            //otherwise assume that it's Time...\n\t            return this.toSeconds(val);\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.CtrlInterpolate}  this\n\t\t */\n\t    Tone.CtrlInterpolate.prototype.dispose = function () {\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlInterpolate;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.CtrlMarkov represents a Markov Chain where each call\n\t\t *         to Tone.CtrlMarkov.next will move to the next state. If the next\n\t\t *         state choice is an array, the next state is chosen randomly with\n\t\t *         even probability for all of the choices. For a weighted probability\n\t\t *         of the next choices, pass in an object with \"state\" and \"probability\" attributes. \n\t\t *         The probabilities will be normalized and then chosen. If no next options\n\t\t *         are given for the current state, the state will stay there. \n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var chain = new Tone.CtrlMarkov({\n\t\t * \t\"beginning\" : [\"end\", \"middle\"],\n\t\t * \t\"middle\" : \"end\"\n\t\t * });\n\t\t * chain.value = \"beginning\";\n\t\t * chain.next(); //returns \"end\" or \"middle\" with 50% probability\n\t\t *\n\t\t *  @example\n\t\t * var chain = new Tone.CtrlMarkov({\n\t\t * \t\"beginning\" : [{\"value\" : \"end\", \"probability\" : 0.8}, \n\t\t * \t\t\t\t\t{\"value\" : \"middle\", \"probability\" : 0.2}],\n\t\t * \t\"middle\" : \"end\"\n\t\t * });\n\t\t * chain.value = \"beginning\";\n\t\t * chain.next(); //returns \"end\" with 80% probability or \"middle\" with 20%.\n\t\t *  @param {Object} values An object with the state names as the keys\n\t\t *                         and the next state(s) as the values. \n\t\t */\n\t    Tone.CtrlMarkov = function (values, initial) {\n\t        /**\n\t\t\t *  The Markov values with states as the keys\n\t\t\t *  and next state(s) as the values. \n\t\t\t *  @type {Object}\n\t\t\t */\n\t        this.values = this.defaultArg(values, {});\n\t        /**\n\t\t\t *  The current state of the Markov values. The next\n\t\t\t *  state will be evaluated and returned when Tone.CtrlMarkov.next\n\t\t\t *  is invoked.\n\t\t\t *  @type {String}\n\t\t\t */\n\t        this.value = this.defaultArg(initial, Object.keys(this.values)[0]);\n\t    };\n\t    Tone.extend(Tone.CtrlMarkov);\n\t    /**\n\t\t *  Returns the next state of the Markov values. \n\t\t *  @return  {String}\n\t\t */\n\t    Tone.CtrlMarkov.prototype.next = function () {\n\t        if (this.values.hasOwnProperty(this.value)) {\n\t            var next = this.values[this.value];\n\t            if (this.isArray(next)) {\n\t                var distribution = this._getProbDistribution(next);\n\t                var rand = Math.random();\n\t                var total = 0;\n\t                for (var i = 0; i < distribution.length; i++) {\n\t                    var dist = distribution[i];\n\t                    if (rand > total && rand < total + dist) {\n\t                        var chosen = next[i];\n\t                        if (this.isObject(chosen)) {\n\t                            this.value = chosen.value;\n\t                        } else {\n\t                            this.value = chosen;\n\t                        }\n\t                    }\n\t                    total += dist;\n\t                }\n\t            } else {\n\t                this.value = next;\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    /**\n\t\t *  Choose randomly from an array weighted options in the form \n\t\t *  {\"state\" : string, \"probability\" : number} or an array of values\n\t\t *  @param  {Array}  options \n\t\t *  @return  {Array}  The randomly selected choice\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlMarkov.prototype._getProbDistribution = function (options) {\n\t        var distribution = [];\n\t        var total = 0;\n\t        var needsNormalizing = false;\n\t        for (var i = 0; i < options.length; i++) {\n\t            var option = options[i];\n\t            if (this.isObject(option)) {\n\t                needsNormalizing = true;\n\t                distribution[i] = option.probability;\n\t            } else {\n\t                distribution[i] = 1 / options.length;\n\t            }\n\t            total += distribution[i];\n\t        }\n\t        if (needsNormalizing) {\n\t            //normalize the values\n\t            for (var j = 0; j < distribution.length; j++) {\n\t                distribution[j] = distribution[j] / total;\n\t            }\n\t        }\n\t        return distribution;\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.CtrlMarkov}  this\n\t\t */\n\t    Tone.CtrlMarkov.prototype.dispose = function () {\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlMarkov;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Generate patterns from an array of values.\n\t\t *         Has a number of arpeggiation and randomized\n\t\t *         selection patterns. \n\t\t *           <ul>\n\t\t *  \t        <li>\"up\" - cycles upward</li>\n\t\t *  \t\t\t<li>\"down\" - cycles downward</li>\n\t\t *  \t\t\t<li>\"upDown\" - up then and down</li>\n\t\t *  \t\t\t<li>\"downUp\" - cycles down then and up</li>\n\t\t *  \t\t\t<li>\"alternateUp\" - jump up two and down one</li>\n\t\t *  \t\t\t<li>\"alternateDown\" - jump down two and up one</li>\n\t\t *  \t\t\t<li>\"random\" - randomly select an index</li>\n\t\t *  \t\t\t<li>\"randomWalk\" - randomly moves one index away from the current position</li>\n\t\t *  \t\t\t<li>\"randomOnce\" - randomly select an index without repeating until all values have been chosen.</li>\n\t\t *     \t\t</ul>\n\t\t *  @param  {Array}  values   An array of options to choose from.\n\t\t *  @param  {Tone.CtrlPattern.Type=}  type  The name of the pattern.\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.CtrlPattern = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'values',\n\t            'type'\n\t        ], Tone.CtrlPattern.defaults);\n\t        /**\n\t\t\t *  The array of values to arpeggiate over\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.values = options.values;\n\t        /**\n\t\t\t *  The current position in the values array\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this.index = 0;\n\t        /**\n\t\t\t *  The type placeholder\n\t\t\t *  @type {Tone.CtrlPattern.Type}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = null;\n\t        /**\n\t\t\t *  Shuffled values for the RandomOnce type\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shuffled = null;\n\t        /**\n\t\t\t *  The direction of the movement\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._direction = null;\n\t        this.type = options.type;\n\t    };\n\t    Tone.extend(Tone.CtrlPattern);\n\t    /**\n\t\t *  The Control Patterns\n\t\t *  @type  {Object}\n\t\t *  @static\n\t\t */\n\t    Tone.CtrlPattern.Type = {\n\t        Up: 'up',\n\t        Down: 'down',\n\t        UpDown: 'upDown',\n\t        DownUp: 'downUp',\n\t        AlternateUp: 'alternateUp',\n\t        AlternateDown: 'alternateDown',\n\t        Random: 'random',\n\t        RandomWalk: 'randomWalk',\n\t        RandomOnce: 'randomOnce'\n\t    };\n\t    /**\n\t\t *  The default values. \n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlPattern.defaults = {\n\t        'type': Tone.CtrlPattern.Type.Up,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  The value at the current index of the pattern.\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlPattern#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlPattern.prototype, 'value', {\n\t        get: function () {\n\t            //some safeguards\n\t            if (this.values.length === 0) {\n\t                return;\n\t            } else if (this.values.length === 1) {\n\t                return this.values[0];\n\t            }\n\t            this.index = Math.min(this.index, this.values.length - 1);\n\t            var val = this.values[this.index];\n\t            if (this.type === Tone.CtrlPattern.Type.RandomOnce) {\n\t                if (this.values.length !== this._shuffled.length) {\n\t                    this._shuffleValues();\n\t                }\n\t                val = this.values[this._shuffled[this.index]];\n\t            }\n\t            return val;\n\t        }\n\t    });\n\t    /**\n\t\t *  The pattern used to select the next\n\t\t *  item from the values array\n\t\t *  @memberOf Tone.CtrlPattern#\n\t\t *  @type {Tone.CtrlPattern.Type}\n\t\t *  @name type\n\t\t */\n\t    Object.defineProperty(Tone.CtrlPattern.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            this._type = type;\n\t            this._shuffled = null;\n\t            //the first index\n\t            if (this._type === Tone.CtrlPattern.Type.Up || this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.RandomOnce || this._type === Tone.CtrlPattern.Type.AlternateUp) {\n\t                this.index = 0;\n\t            } else if (this._type === Tone.CtrlPattern.Type.Down || this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {\n\t                this.index = this.values.length - 1;\n\t            }\n\t            //the direction\n\t            if (this._type === Tone.CtrlPattern.Type.UpDown || this._type === Tone.CtrlPattern.Type.AlternateUp) {\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            } else if (this._type === Tone.CtrlPattern.Type.DownUp || this._type === Tone.CtrlPattern.Type.AlternateDown) {\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t            //randoms\n\t            if (this._type === Tone.CtrlPattern.Type.RandomOnce) {\n\t                this._shuffleValues();\n\t            } else if (this._type === Tone.CtrlPattern.Random) {\n\t                this.index = Math.floor(Math.random() * this.values.length);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Return the next value given the current position\n\t\t *  and pattern.\n\t\t *  @return {*} The next value\n\t\t */\n\t    Tone.CtrlPattern.prototype.next = function () {\n\t        var type = this.type;\n\t        //choose the next index\n\t        if (type === Tone.CtrlPattern.Type.Up) {\n\t            this.index++;\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.Down) {\n\t            this.index--;\n\t            if (this.index < 0) {\n\t                this.index = this.values.length - 1;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.UpDown || type === Tone.CtrlPattern.Type.DownUp) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index++;\n\t            } else {\n\t                this.index--;\n\t            }\n\t            if (this.index < 0) {\n\t                this.index = 1;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            } else if (this.index >= this.values.length) {\n\t                this.index = this.values.length - 2;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.Random) {\n\t            this.index = Math.floor(Math.random() * this.values.length);\n\t        } else if (type === Tone.CtrlPattern.Type.RandomWalk) {\n\t            if (Math.random() < 0.5) {\n\t                this.index--;\n\t                this.index = Math.max(this.index, 0);\n\t            } else {\n\t                this.index++;\n\t                this.index = Math.min(this.index, this.values.length - 1);\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.RandomOnce) {\n\t            this.index++;\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t                //reshuffle the values for next time\n\t                this._shuffleValues();\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.AlternateUp) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index += 2;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            } else {\n\t                this.index -= 1;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t            if (this.index >= this.values.length) {\n\t                this.index = 0;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t        } else if (type === Tone.CtrlPattern.Type.AlternateDown) {\n\t            if (this._direction === Tone.CtrlPattern.Type.Up) {\n\t                this.index += 1;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            } else {\n\t                this.index -= 2;\n\t                this._direction = Tone.CtrlPattern.Type.Up;\n\t            }\n\t            if (this.index < 0) {\n\t                this.index = this.values.length - 1;\n\t                this._direction = Tone.CtrlPattern.Type.Down;\n\t            }\n\t        }\n\t        return this.value;\n\t    };\n\t    /**\n\t\t *  Shuffles the values and places the results into the _shuffled\n\t\t *  @private\n\t\t */\n\t    Tone.CtrlPattern.prototype._shuffleValues = function () {\n\t        var copy = [];\n\t        this._shuffled = [];\n\t        for (var i = 0; i < this.values.length; i++) {\n\t            copy[i] = i;\n\t        }\n\t        while (copy.length > 0) {\n\t            var randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t            this._shuffled.push(randVal[0]);\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.CtrlPattern} this\n\t\t */\n\t    Tone.CtrlPattern.prototype.dispose = function () {\n\t        this._shuffled = null;\n\t        this.values = null;\n\t    };\n\t    return Tone.CtrlPattern;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Choose a random value.\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var randomWalk = new Tone.CtrlRandom({\n\t\t * \t\"min\" : 0,\n\t\t * \t\"max\" : 10,\n\t\t * \t\"integer\" : true\n\t\t * });\n\t\t * randomWalk.eval();\n\t\t *\n\t\t *  @param {Number|Time=} min The minimum return value.\n\t\t *  @param {Number|Time=} max The maximum return value.\n\t\t */\n\t    Tone.CtrlRandom = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'min',\n\t            'max'\n\t        ], Tone.CtrlRandom.defaults);\n\t        /**\n\t\t\t *  The minimum return value\n\t\t\t *  @type  {Number|Time}\n\t\t\t */\n\t        this.min = options.min;\n\t        /**\n\t\t\t *  The maximum return value\n\t\t\t *  @type  {Number|Time}\n\t\t\t */\n\t        this.max = options.max;\n\t        /**\n\t\t\t *  If the return value should be an integer\n\t\t\t *  @type  {Boolean}\n\t\t\t */\n\t        this.integer = options.integer;\n\t    };\n\t    Tone.extend(Tone.CtrlRandom);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.CtrlRandom.defaults = {\n\t        'min': 0,\n\t        'max': 1,\n\t        'integer': false\n\t    };\n\t    /**\n\t\t *  Return a random value between min and max. \n\t\t *  @readOnly\n\t\t *  @memberOf Tone.CtrlRandom#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t */\n\t    Object.defineProperty(Tone.CtrlRandom.prototype, 'value', {\n\t        get: function () {\n\t            var min = this.toSeconds(this.min);\n\t            var max = this.toSeconds(this.max);\n\t            var rand = Math.random();\n\t            var val = rand * min + (1 - rand) * max;\n\t            if (this.integer) {\n\t                val = Math.floor(val);\n\t            }\n\t            return val;\n\t        }\n\t    });\n\t    return Tone.CtrlRandom;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  AudioBuffer.copyToChannel polyfill\n\t\t *  @private\n\t\t */\n\t    if (window.AudioBuffer && !AudioBuffer.prototype.copyToChannel) {\n\t        AudioBuffer.prototype.copyToChannel = function (src, chanNum, start) {\n\t            var channel = this.getChannelData(chanNum);\n\t            start = start || 0;\n\t            for (var i = 0; i < channel.length; i++) {\n\t                channel[i + start] = src[i];\n\t            }\n\t        };\n\t        AudioBuffer.prototype.copyFromChannel = function (dest, chanNum, start) {\n\t            var channel = this.getChannelData(chanNum);\n\t            start = start || 0;\n\t            for (var i = 0; i < channel.length; i++) {\n\t                dest[i] = channel[i + start];\n\t            }\n\t        };\n\t    }\n\t    /**\n\t\t *  @class  Buffer loading and storage. Tone.Buffer is used internally by all \n\t\t *          classes that make requests for audio files such as Tone.Player,\n\t\t *          Tone.Sampler and Tone.Convolver.\n\t\t *          <br><br>\n\t\t *          Aside from load callbacks from individual buffers, Tone.Buffer \n\t\t *  \t\tprovides static methods which keep track of the loading progress \n\t\t *  \t\tof all of the buffers. These methods are Tone.Buffer.on(\"load\" / \"progress\" / \"error\")\n\t\t *\n\t\t *  @constructor \n\t\t *  @extends {Tone}\n\t\t *  @param {AudioBuffer|string} url The url to load, or the audio buffer to set. \n\t\t *  @param {Function=} onload A callback which is invoked after the buffer is loaded. \n\t\t *                            It's recommended to use Tone.Buffer.onload instead \n\t\t *                            since it will give you a callback when ALL buffers are loaded.\n\t\t *  @param {Function=} onerror The callback to invoke if there is an error\n\t\t *  @example\n\t\t * var buffer = new Tone.Buffer(\"path/to/sound.mp3\", function(){\n\t\t * \t//the buffer is now available.\n\t\t * \tvar buff = buffer.get();\n\t\t * });\n\t\t */\n\t    Tone.Buffer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload',\n\t            'onerror'\n\t        ], Tone.Buffer.defaults);\n\t        /**\n\t\t\t *  stores the loaded AudioBuffer\n\t\t\t *  @type {AudioBuffer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = null;\n\t        /**\n\t\t\t *  indicates if the buffer should be reversed or not\n\t\t\t *  @type {Boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this._reversed = options.reverse;\n\t        /**\n\t\t\t *  The XHR\n\t\t\t *  @type  {XMLHttpRequest}\n\t\t\t *  @private\n\t\t\t */\n\t        this._xhr = null;\n\t        if (options.url instanceof AudioBuffer || options.url instanceof Tone.Buffer) {\n\t            this.set(options.url);\n\t            // invoke the onload callback\n\t            if (options.onload) {\n\t                options.onload(this);\n\t            }\n\t        } else if (this.isString(options.url)) {\n\t            this.load(options.url, options.onload, options.onerror);\n\t        }\n\t    };\n\t    Tone.extend(Tone.Buffer);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Buffer.defaults = {\n\t        'url': undefined,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Pass in an AudioBuffer or Tone.Buffer to set the value\n\t\t *  of this buffer.\n\t\t *  @param {AudioBuffer|Tone.Buffer} buffer the buffer\n\t\t *  @returns {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.set = function (buffer) {\n\t        if (buffer instanceof Tone.Buffer) {\n\t            this._buffer = buffer.get();\n\t        } else {\n\t            this._buffer = buffer;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  @return {AudioBuffer} The audio buffer stored in the object.\n\t\t */\n\t    Tone.Buffer.prototype.get = function () {\n\t        return this._buffer;\n\t    };\n\t    /**\n\t\t *  Makes an xhr reqest for the selected url then decodes\n\t\t *  the file as an audio buffer. Invokes\n\t\t *  the callback once the audio buffer loads.\n\t\t *  @param {String} url The url of the buffer to load.\n\t\t *                      filetype support depends on the\n\t\t *                      browser.\n\t\t *  @returns {Promise} returns a Promise which resolves with the Tone.Buffer\n\t\t */\n\t    Tone.Buffer.prototype.load = function (url, onload, onerror) {\n\t        var promise = new Promise(function (load, error) {\n\t            this._xhr = Tone.Buffer.load(url, //success\n\t            function (buff) {\n\t                this._xhr = null;\n\t                this.set(buff);\n\t                load(this);\n\t                if (onload) {\n\t                    onload(this);\n\t                }\n\t            }.bind(this), //error\n\t            function (err) {\n\t                this._xhr = null;\n\t                error(err);\n\t                if (onerror) {\n\t                    onerror(err);\n\t                }\n\t            }.bind(this));\n\t        }.bind(this));\n\t        return promise;\n\t    };\n\t    /**\n\t\t *  dispose and disconnect\n\t\t *  @returns {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.dispose = function () {\n\t        Tone.Emitter.prototype.dispose.call(this);\n\t        this._buffer = null;\n\t        if (this._xhr) {\n\t            Tone.Buffer._currentDownloads--;\n\t            this._xhr.abort();\n\t            this._xhr = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * If the buffer is loaded or not\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Boolean}\n\t\t * @name loaded\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'loaded', {\n\t        get: function () {\n\t            return this.length > 0;\n\t        }\n\t    });\n\t    /**\n\t\t * The duration of the buffer. \n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name duration\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'duration', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.duration;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The length of the buffer in samples\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name length\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'length', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.length;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of discrete audio channels. Returns 0 if no buffer\n\t\t * is loaded.\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Number}\n\t\t * @name numberOfChannels\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'numberOfChannels', {\n\t        get: function () {\n\t            if (this._buffer) {\n\t                return this._buffer.numberOfChannels;\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Set the audio buffer from the array\n\t\t *  @param {Float32Array} array The array to fill the audio buffer\n\t\t *  @param {Number} [channels=1] The number of channels contained in the array. \n\t\t *                               If the channel is more than 1, the input array\n\t\t *                               is expected to be a multidimensional array\n\t\t *                               with dimensions equal to the number of channels.\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.fromArray = function (array) {\n\t        var isMultidimensional = array[0].length > 0;\n\t        var channels = isMultidimensional ? array.length : 1;\n\t        var len = isMultidimensional ? array[0].length : array.length;\n\t        var buffer = this.context.createBuffer(channels, len, this.context.sampleRate);\n\t        if (!isMultidimensional && channels === 1) {\n\t            array = [array];\n\t        }\n\t        for (var c = 0; c < channels; c++) {\n\t            buffer.copyToChannel(array[c], c);\n\t        }\n\t        this._buffer = buffer;\n\t        return this;\n\t    };\n\t    /**\n\t\t * \tSums muliple channels into 1 channel\n\t\t *  @param {Number=} channel Optionally only copy a single channel from the array.\n\t\t *  @return {Array}\n\t\t */\n\t    Tone.Buffer.prototype.toMono = function (chanNum) {\n\t        if (this.isNumber(chanNum)) {\n\t            this.fromArray(this.toArray(chanNum));\n\t        } else {\n\t            var outputArray = new Float32Array(this.length);\n\t            var numChannels = this.numberOfChannels;\n\t            for (var channel = 0; channel < numChannels; channel++) {\n\t                var channelArray = this.toArray(channel);\n\t                for (var i = 0; i < channelArray.length; i++) {\n\t                    outputArray[i] += channelArray[i];\n\t                }\n\t            }\n\t            //divide by the number of channels\n\t            outputArray = outputArray.map(function (sample) {\n\t                return sample / numChannels;\n\t            });\n\t            this.fromArray(outputArray);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * \tGet the buffer as an array. Single channel buffers will return a 1-dimensional \n\t\t * \tFloat32Array, and multichannel buffers will return multidimensional arrays.\n\t\t *  @param {Number=} channel Optionally only copy a single channel from the array.\n\t\t *  @return {Array}\n\t\t */\n\t    Tone.Buffer.prototype.toArray = function (channel) {\n\t        if (this.isNumber(channel)) {\n\t            return this.getChannelData(channel);\n\t        } else if (this.numberOfChannels === 1) {\n\t            return this.toArray(0);\n\t        } else {\n\t            var ret = [];\n\t            for (var c = 0; c < this.numberOfChannels; c++) {\n\t                ret[c] = this.getChannelData(c);\n\t            }\n\t            return ret;\n\t        }\n\t    };\n\t    /**\n\t\t *  Returns the Float32Array representing the PCM audio data for the specific channel.\n\t\t *  @param  {Number}  channel  The channel number to return\n\t\t *  @return  {Float32Array}  The audio as a TypedArray\n\t\t */\n\t    Tone.Buffer.prototype.getChannelData = function (channel) {\n\t        return this._buffer.getChannelData(channel);\n\t    };\n\t    /**\n\t\t *  Cut a subsection of the array and return a buffer of the\n\t\t *  subsection. Does not modify the original buffer\n\t\t *  @param {Time} start The time to start the slice\n\t\t *  @param {Time=} end The end time to slice. If none is given\n\t\t *                     will default to the end of the buffer\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype.slice = function (start, end) {\n\t        end = this.defaultArg(end, this.duration);\n\t        var startSamples = Math.floor(this.context.sampleRate * this.toSeconds(start));\n\t        var endSamples = Math.floor(this.context.sampleRate * this.toSeconds(end));\n\t        var replacement = [];\n\t        for (var i = 0; i < this.numberOfChannels; i++) {\n\t            replacement[i] = this.toArray(i).slice(startSamples, endSamples);\n\t        }\n\t        var retBuffer = new Tone.Buffer().fromArray(replacement);\n\t        return retBuffer;\n\t    };\n\t    /**\n\t\t *  Reverse the buffer.\n\t\t *  @private\n\t\t *  @return {Tone.Buffer} this\n\t\t */\n\t    Tone.Buffer.prototype._reverse = function () {\n\t        if (this.loaded) {\n\t            for (var i = 0; i < this.numberOfChannels; i++) {\n\t                Array.prototype.reverse.call(this.getChannelData(i));\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t * Reverse the buffer.\n\t\t * @memberOf Tone.Buffer#\n\t\t * @type {Boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Buffer.prototype, 'reverse', {\n\t        get: function () {\n\t            return this._reversed;\n\t        },\n\t        set: function (rev) {\n\t            if (this._reversed !== rev) {\n\t                this._reversed = rev;\n\t                this._reverse();\n\t            }\n\t        }\n\t    });\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // STATIC METHODS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //statically inherits Emitter methods\n\t    Tone.Emitter.mixin(Tone.Buffer);\n\t    /**\n\t\t *  the static queue for all of the xhr requests\n\t\t *  @type {Array}\n\t\t *  @private\n\t\t */\n\t    Tone.Buffer._downloadQueue = [];\n\t    /**\n\t\t *  the total number of downloads\n\t\t *  @type {Number}\n\t\t *  @private\n\t\t */\n\t    Tone.Buffer._currentDownloads = 0;\n\t    /**\n\t\t *  A path which is prefixed before every url.\n\t\t *  @type  {String}\n\t\t *  @static\n\t\t */\n\t    Tone.Buffer.baseUrl = '';\n\t    /**\n\t\t *  Loads a url using XMLHttpRequest.\n\t\t *  @param {String} url\n\t\t *  @param {Function} onload\n\t\t *  @param {Function} onerror\n\t\t *  @param {Function} onprogress\n\t\t *  @return {XMLHttpRequest}\n\t\t */\n\t    Tone.Buffer.load = function (url, onload, onerror) {\n\t        //default\n\t        onload = onload || Tone.noOp;\n\t        function onError(e) {\n\t            if (onerror) {\n\t                onerror(e);\n\t                Tone.Buffer.emit('error', e);\n\t            } else {\n\t                throw new Error(e);\n\t            }\n\t        }\n\t        function onProgress() {\n\t            //calculate the progress\n\t            var totalProgress = 0;\n\t            for (var i = 0; i < Tone.Buffer._downloadQueue.length; i++) {\n\t                totalProgress += Tone.Buffer._downloadQueue[i].progress;\n\t            }\n\t            Tone.Buffer.emit('progress', totalProgress / Tone.Buffer._downloadQueue.length);\n\t        }\n\t        var request = new XMLHttpRequest();\n\t        request.open('GET', Tone.Buffer.baseUrl + url, true);\n\t        request.responseType = 'arraybuffer';\n\t        //start out as 0\n\t        request.progress = 0;\n\t        Tone.Buffer._currentDownloads++;\n\t        Tone.Buffer._downloadQueue.push(request);\n\t        request.addEventListener('load', function () {\n\t            if (request.status === 200) {\n\t                Tone.context.decodeAudioData(request.response, function (buff) {\n\t                    request.progress = 1;\n\t                    onProgress();\n\t                    onload(buff);\n\t                    Tone.Buffer._currentDownloads--;\n\t                    if (Tone.Buffer._currentDownloads === 0) {\n\t                        // clear the downloads\n\t                        Tone.Buffer._downloadQueue = [];\n\t                        //emit the event at the end\n\t                        Tone.Buffer.emit('load');\n\t                    }\n\t                }, function () {\n\t                    onError('Tone.Buffer: could not decode audio data: ' + url);\n\t                });\n\t            } else {\n\t                onError('Tone.Buffer: could not locate file: ' + url);\n\t            }\n\t        });\n\t        request.addEventListener('error', onError);\n\t        request.addEventListener('progress', function (event) {\n\t            if (event.lengthComputable) {\n\t                //only go to 95%, the last 5% is when the audio is decoded\n\t                request.progress = event.loaded / event.total * 0.95;\n\t                onProgress();\n\t            }\n\t        });\n\t        request.send();\n\t        return request;\n\t    };\n\t    /**\n\t\t *  Stop all of the downloads in progress\n\t\t *  @return {Tone.Buffer}\n\t\t *  @static\n\t\t */\n\t    Tone.Buffer.cancelDownloads = function () {\n\t        Tone.Buffer._downloadQueue.forEach(function (request) {\n\t            request.abort();\n\t        });\n\t        Tone.Buffer._currentDownloads = 0;\n\t        return Tone.Buffer;\n\t    };\n\t    /**\n\t\t *  Checks a url's extension to see if the current browser can play that file type.\n\t\t *  @param {String} url The url/extension to test\n\t\t *  @return {Boolean} If the file extension can be played\n\t\t *  @static\n\t\t *  @example\n\t\t * Tone.Buffer.supportsType(\"wav\"); //returns true\n\t\t * Tone.Buffer.supportsType(\"path/to/file.wav\"); //returns true\n\t\t */\n\t    Tone.Buffer.supportsType = function (url) {\n\t        var extension = url.split('.');\n\t        extension = extension[extension.length - 1];\n\t        var response = document.createElement('audio').canPlayType('audio/' + extension);\n\t        return response !== '';\n\t    };\n\t    /**\n\t\t *  Returns a Promise which resolves when all of the buffers have loaded\n\t\t *  @return {Promise}\n\t\t */\n\t    Tone.loaded = function () {\n\t        var onload, onerror;\n\t        function removeEvents() {\n\t            //remove the events when it's resolved\n\t            Tone.Buffer.off('load', onload);\n\t            Tone.Buffer.off('error', onerror);\n\t        }\n\t        return new Promise(function (success, fail) {\n\t            onload = function () {\n\t                success();\n\t            };\n\t            onerror = function () {\n\t                fail();\n\t            };\n\t            //add the event listeners\n\t            Tone.Buffer.on('load', onload);\n\t            Tone.Buffer.on('error', onerror);\n\t        }).then(removeEvents).catch(function (e) {\n\t            removeEvents();\n\t            throw new Error(e);\n\t        });\n\t    };\n\t    return Tone.Buffer;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class A data structure for holding multiple buffers.\n\t\t *  \n\t\t *  @param  {Object|Array}    urls      An object literal or array\n\t\t *                                      of urls to load.\n\t\t *  @param  {Function=}  callback  The callback to invoke when\n\t\t *                                 the buffers are loaded. \n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * //load a whole bank of piano samples\n\t\t * var pianoSamples = new Tone.Buffers({\n\t\t * \t\"C4\" : \"path/to/C4.mp3\"\n\t\t * \t\"C#4\" : \"path/to/C#4.mp3\"\n\t\t * \t\"D4\" : \"path/to/D4.mp3\"\n\t\t * \t\"D#4\" : \"path/to/D#4.mp3\"\n\t\t * \t...\n\t\t * }, function(){\n\t\t * \t//play one of the samples when they all load\n\t\t * \tplayer.buffer = pianoSamples.get(\"C4\");\n\t\t * \tplayer.start();\n\t\t * });\n\t\t * \n\t\t */\n\t    Tone.Buffers = function (urls, onload, baseUrl) {\n\t        /**\n\t\t\t *  All of the buffers\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffers = {};\n\t        /**\n\t\t\t *  A path which is prefixed before every url.\n\t\t\t *  @type  {String}\n\t\t\t */\n\t        this.baseUrl = this.defaultArg(baseUrl, '');\n\t        urls = this._flattenUrls(urls);\n\t        this._loadingCount = 0;\n\t        //add each one\n\t        for (var key in urls) {\n\t            this._loadingCount++;\n\t            this.add(key, urls[key], this._bufferLoaded.bind(this, onload));\n\t        }\n\t    };\n\t    Tone.extend(Tone.Buffers);\n\t    /**\n\t\t *  True if the buffers object has a buffer by that name.\n\t\t *  @param  {String|Number}  name  The key or index of the \n\t\t *                                 buffer.\n\t\t *  @return  {Boolean}\n\t\t */\n\t    Tone.Buffers.prototype.has = function (name) {\n\t        return this._buffers.hasOwnProperty(name);\n\t    };\n\t    /**\n\t\t *  Get a buffer by name. If an array was loaded, \n\t\t *  then use the array index.\n\t\t *  @param  {String|Number}  name  The key or index of the \n\t\t *                                 buffer.\n\t\t *  @return  {Tone.Buffer}\n\t\t */\n\t    Tone.Buffers.prototype.get = function (name) {\n\t        if (this.has(name)) {\n\t            return this._buffers[name];\n\t        } else {\n\t            throw new Error('Tone.Buffers: no buffer named ' + name);\n\t        }\n\t    };\n\t    /**\n\t\t *  A buffer was loaded. decrement the counter.\n\t\t *  @param  {Function}  callback \n\t\t *  @private\n\t\t */\n\t    Tone.Buffers.prototype._bufferLoaded = function (callback) {\n\t        this._loadingCount--;\n\t        if (this._loadingCount === 0 && callback) {\n\t            callback(this);\n\t        }\n\t    };\n\t    /**\n\t\t * If the buffers are loaded or not\n\t\t * @memberOf Tone.Buffers#\n\t\t * @type {Boolean}\n\t\t * @name loaded\n\t\t * @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Buffers.prototype, 'loaded', {\n\t        get: function () {\n\t            var isLoaded = true;\n\t            for (var buffName in this._buffers) {\n\t                var buff = this.get(buffName);\n\t                isLoaded = isLoaded && buff.loaded;\n\t            }\n\t            return isLoaded;\n\t        }\n\t    });\n\t    /**\n\t\t *  Add a buffer by name and url to the Buffers\n\t\t *  @param  {String}    name      A unique name to give\n\t\t *                                the buffer\n\t\t *  @param  {String|Tone.Buffer|Audiobuffer}  url  Either the url of the bufer, \n\t\t *                                                 or a buffer which will be added\n\t\t *                                                 with the given name.\n\t\t *  @param  {Function=}  callback  The callback to invoke \n\t\t *                                 when the url is loaded.\n\t\t */\n\t    Tone.Buffers.prototype.add = function (name, url, callback) {\n\t        callback = this.defaultArg(callback, Tone.noOp);\n\t        if (url instanceof Tone.Buffer) {\n\t            this._buffers[name] = url;\n\t            callback(this);\n\t        } else if (url instanceof AudioBuffer) {\n\t            this._buffers[name] = new Tone.Buffer(url);\n\t            callback(this);\n\t        } else if (this.isString(url)) {\n\t            this._buffers[name] = new Tone.Buffer(this.baseUrl + url, callback);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Flatten an object into a single depth object. \n\t\t *  thanks to https://gist.github.com/penguinboy/762197\n\t\t *  @param   {Object} ob \t\n\t\t *  @return  {Object}    \n\t\t *  @private\n\t\t */\n\t    Tone.Buffers.prototype._flattenUrls = function (ob) {\n\t        var toReturn = {};\n\t        for (var i in ob) {\n\t            if (!ob.hasOwnProperty(i))\n\t                continue;\n\t            if (this.isObject(ob[i])) {\n\t                var flatObject = this._flattenUrls(ob[i]);\n\t                for (var x in flatObject) {\n\t                    if (!flatObject.hasOwnProperty(x))\n\t                        continue;\n\t                    toReturn[i + '.' + x] = flatObject[x];\n\t                }\n\t            } else {\n\t                toReturn[i] = ob[i];\n\t            }\n\t        }\n\t        return toReturn;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.Buffers} this\n\t\t */\n\t    Tone.Buffers.prototype.dispose = function () {\n\t        for (var name in this._buffers) {\n\t            this._buffers[name].dispose();\n\t        }\n\t        this._buffers = null;\n\t        return this;\n\t    };\n\t    return Tone.Buffers;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  buses are another way of routing audio\n\t\t *\n\t\t *  augments Tone.prototype to include send and recieve\n\t\t */\n\t    /**\n\t\t  *  All of the routes\n\t\t  *  \n\t\t  *  @type {Object}\n\t\t  *  @static\n\t\t  *  @private\n\t\t  */\n\t    var Buses = {};\n\t    /**\n\t\t *  Send this signal to the channel name. \n\t\t *  @param  {string} channelName A named channel to send the signal to.\n\t\t *  @param  {Decibels} amount The amount of the source to send to the bus. \n\t\t *  @return {GainNode} The gain node which connects this node to the desired channel. \n\t\t *                     Can be used to adjust the levels of the send.\n\t\t *  @example\n\t\t * source.send(\"reverb\", -12);\n\t\t */\n\t    Tone.prototype.send = function (channelName, amount) {\n\t        if (!Buses.hasOwnProperty(channelName)) {\n\t            Buses[channelName] = this.context.createGain();\n\t        }\n\t        amount = this.defaultArg(amount, 0);\n\t        var sendKnob = new Tone.Gain(amount, Tone.Type.Decibels);\n\t        this.output.chain(sendKnob, Buses[channelName]);\n\t        return sendKnob;\n\t    };\n\t    /**\n\t\t *  Recieve the input from the desired channelName to the input\n\t\t *\n\t\t *  @param  {string} channelName A named channel to send the signal to.\n\t\t *  @param {AudioNode} [input] If no input is selected, the\n\t\t *                                         input of the current node is\n\t\t *                                         chosen. \n\t\t *  @returns {Tone} this\n\t\t *  @example\n\t\t * reverbEffect.receive(\"reverb\");\n\t\t */\n\t    Tone.prototype.receive = function (channelName, input) {\n\t        if (!Buses.hasOwnProperty(channelName)) {\n\t            Buses[channelName] = this.context.createGain();\n\t        }\n\t        if (this.isUndef(input)) {\n\t            input = this.input;\n\t        }\n\t        Buses[channelName].connect(input);\n\t        return this;\n\t    };\n\t    //remove all the send/receives when a new audio context is passed in\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Buses) {\n\t            Buses = context.Buses;\n\t        } else {\n\t            Buses = {};\n\t            context.Buses = Buses;\n\t        }\n\t    });\n\t    return Tone;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Draw is useful for synchronizing visuals and audio events.\n\t\t *         Callbacks from Tone.Transport or any of the Tone.Event classes\n\t\t *         always happen _before_ the scheduled time and are not synchronized\n\t\t *         to the animation frame so they are not good for triggering tightly\n\t\t *         synchronized visuals and sound. Tone.Draw makes it easy to schedule\n\t\t *         callbacks using the AudioContext time and uses requestAnimationFrame.\n\t\t *         \n\t\t *  @singleton\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * Tone.Transport.schedule(function(time){\n\t\t * \t//use the time argument to schedule a callback with Tone.Draw\n\t\t * \tTone.Draw.schedule(function(){\n\t\t * \t\t//do drawing or DOM manipulation here\n\t\t * \t}, time)\n\t\t * }, \"+0.5\")\n\t\t */\n\t    Tone.Draw = function () {\n\t        /**\n\t\t\t *  All of the events.\n\t\t\t *  @type  {Tone.Timeline}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = new Tone.Timeline();\n\t        /**\n\t\t\t *  The duration after which events are not invoked.\n\t\t\t *  @type  {Number}\n\t\t\t *  @default 0.25\n\t\t\t */\n\t        this.expiration = 0.25;\n\t        /**\n\t\t\t *  The amount of time before the scheduled time \n\t\t\t *  that the callback can be invoked. Default is\n\t\t\t *  half the time of an animation frame (0.008 seconds).\n\t\t\t *  @type  {Number}\n\t\t\t *  @default 0.008\n\t\t\t */\n\t        this.anticipation = 0.008;\n\t        /**\n\t\t\t *  The draw loop\n\t\t\t *  @type  {Function}\n\t\t\t *  @private\n\t\t\t */\n\t        this._boundDrawLoop = this._drawLoop.bind(this);\n\t    };\n\t    Tone.extend(Tone.Draw);\n\t    /**\n\t\t *  Schedule a function at the given time to be invoked\n\t\t *  on the nearest animation frame.\n\t\t *  @param  {Function}  callback  Callback is invoked at the given time.\n\t\t *  @param  {Time}    time      The time relative to the AudioContext time\n\t\t *                              to invoke the callback.\n\t\t *  @return  {Tone.Draw}    this\n\t\t */\n\t    Tone.Draw.prototype.schedule = function (callback, time) {\n\t        this._events.add({\n\t            callback: callback,\n\t            time: this.toSeconds(time)\n\t        });\n\t        //start the draw loop on the first event\n\t        if (this._events.length === 1) {\n\t            requestAnimationFrame(this._boundDrawLoop);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel events scheduled after the given time\n\t\t *  @param  {Time=}  after  Time after which scheduled events will \n\t\t *                          be removed from the scheduling timeline.\n\t\t *  @return  {Tone.Draw}  this\n\t\t */\n\t    Tone.Draw.prototype.cancel = function (after) {\n\t        this._events.cancel(this.toSeconds(after));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The draw loop\n\t\t *  @private\n\t\t */\n\t    Tone.Draw.prototype._drawLoop = function () {\n\t        var now = Tone.now();\n\t        while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n\t            var event = this._events.shift();\n\t            if (now - event.time <= this.expiration) {\n\t                event.callback();\n\t            }\n\t        }\n\t        if (this._events.length > 0) {\n\t            requestAnimationFrame(this._boundDrawLoop);\n\t        }\n\t    };\n\t    //make a singleton\n\t    Tone.Draw = new Tone.Draw();\n\t    return Tone.Draw;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Both Tone.Panner3D and Tone.Listener have a position in 3D space \n\t\t *          using a right-handed cartesian coordinate system. \n\t\t *          The units used in the coordinate system are not defined; \n\t\t *          these coordinates are independent/invariant of any particular \n\t\t *          units such as meters or feet. Tone.Panner3D objects have an forward \n\t\t *          vector representing the direction the sound is projecting. Additionally, \n\t\t *          they have a sound cone representing how directional the sound is. \n\t\t *          For example, the sound could be omnidirectional, in which case it would \n\t\t *          be heard anywhere regardless of its forward, or it can be more directional \n\t\t *          and heard only if it is facing the listener. Tone.Listener objects \n\t\t *          (representing a person's ears) have an forward and up vector \n\t\t *          representing in which direction the person is facing. Because both the \n\t\t *          source stream and the listener can be moving, they both have a velocity \n\t\t *          vector representing both the speed and direction of movement. Taken together, \n\t\t *          these two velocities can be used to generate a doppler shift effect which changes the pitch.\n\t\t *          <br><br>\n\t\t *          Note: the position of the Listener will have no effect on nodes not connected to a Tone.Panner3D\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @singleton\n\t\t *  @param {Number} positionX The initial x position.\n\t\t *  @param {Number} positionY The initial y position.\n\t\t *  @param {Number} positionZ The initial z position.\n\t\t */\n\t    Tone.Listener = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'positionX',\n\t            'positionY',\n\t            'positionZ'\n\t        ], ListenerConstructor.defaults);\n\t        /**\n\t\t\t *  Holds the current forward orientation\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._orientation = [\n\t            options.forwardX,\n\t            options.forwardY,\n\t            options.forwardZ,\n\t            options.upX,\n\t            options.upY,\n\t            options.upZ\n\t        ];\n\t        /**\n\t\t\t *  Holds the current position\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._position = [\n\t            options.positionX,\n\t            options.positionY,\n\t            options.positionZ\n\t        ];\n\t        // set the default position/forward\n\t        this.forwardX = options.forwardX;\n\t        this.forwardY = options.forwardY;\n\t        this.forwardZ = options.forwardZ;\n\t        this.upX = options.upX;\n\t        this.upY = options.upY;\n\t        this.upZ = options.upZ;\n\t        this.positionX = options.positionX;\n\t        this.positionY = options.positionY;\n\t        this.positionZ = options.positionZ;\n\t    };\n\t    Tone.extend(Tone.Listener);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t *  Defaults according to the specification\n\t\t */\n\t    Tone.Listener.defaults = {\n\t        'positionX': 0,\n\t        'positionY': 0,\n\t        'positionZ': 0,\n\t        'forwardX': 0,\n\t        'forwardY': 0,\n\t        'forwardZ': 1,\n\t        'upX': 0,\n\t        'upY': 1,\n\t        'upZ': 0\n\t    };\n\t    /**\n\t\t * The ramp time which is applied to the setTargetAtTime\n\t\t * @type {Number}\n\t\t * @private\n\t\t */\n\t    Tone.Listener.prototype._rampTimeConstant = 0.01;\n\t    /**\n\t\t *  Sets the position of the listener in 3d space.\t\n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @return {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.setPosition = function (x, y, z) {\n\t        if (this.context.listener.positionX) {\n\t            var now = this.now();\n\t            this.context.listener.positionX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this.context.listener.positionY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this.context.listener.positionZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t        } else {\n\t            this.context.listener.setPosition(x, y, z);\n\t        }\n\t        this._position = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Sets the orientation of the listener using two vectors, the forward\n\t\t *  vector (which direction the listener is facing) and the up vector \n\t\t *  (which the up direction of the listener). An up vector\n\t\t *  of 0, 0, 1 is equivalent to the listener standing up in the Z direction. \n\t\t *  @param  {Number}  x\n\t\t *  @param  {Number}  y\n\t\t *  @param  {Number}  z\n\t\t *  @param  {Number}  upX\n\t\t *  @param  {Number}  upY\n\t\t *  @param  {Number}  upZ\n\t\t *  @return {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.setOrientation = function (x, y, z, upX, upY, upZ) {\n\t        if (this.context.listener.forwardX) {\n\t            var now = this.now();\n\t            this.context.listener.forwardX.setTargetAtTime(x, now, this._rampTimeConstant);\n\t            this.context.listener.forwardY.setTargetAtTime(y, now, this._rampTimeConstant);\n\t            this.context.listener.forwardZ.setTargetAtTime(z, now, this._rampTimeConstant);\n\t            this.context.listener.upX.setTargetAtTime(upX, now, this._rampTimeConstant);\n\t            this.context.listener.upY.setTargetAtTime(upY, now, this._rampTimeConstant);\n\t            this.context.listener.upZ.setTargetAtTime(upZ, now, this._rampTimeConstant);\n\t        } else {\n\t            this.context.listener.setOrientation(x, y, z, upX, upY, upZ);\n\t        }\n\t        this._orientation = Array.prototype.slice.call(arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The x position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionX', {\n\t        set: function (pos) {\n\t            this._position[0] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionY', {\n\t        set: function (pos) {\n\t            this._position[1] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z position of the panner object.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name positionZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'positionZ', {\n\t        set: function (pos) {\n\t            this._position[2] = pos;\n\t            this.setPosition.apply(this, this._position);\n\t        },\n\t        get: function () {\n\t            return this._position[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardX', {\n\t        set: function (pos) {\n\t            this._orientation[0] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[0];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardY', {\n\t        set: function (pos) {\n\t            this._orientation[1] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[1];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z coordinate of the listeners front direction. i.e. \n\t\t *  which way they are facing.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name forwardZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'forwardZ', {\n\t        set: function (pos) {\n\t            this._orientation[2] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[2];\n\t        }\n\t    });\n\t    /**\n\t\t *  The x coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upX\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upX', {\n\t        set: function (pos) {\n\t            this._orientation[3] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[3];\n\t        }\n\t    });\n\t    /**\n\t\t *  The y coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upY\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upY', {\n\t        set: function (pos) {\n\t            this._orientation[4] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[4];\n\t        }\n\t    });\n\t    /**\n\t\t *  The z coordinate of the listener's up direction. i.e.\n\t\t *  the direction the listener is standing in.\n\t\t *  @type {Number}\n\t\t *  @memberOf Tone.Listener#\n\t\t *  @name upZ\n\t\t */\n\t    Object.defineProperty(Tone.Listener.prototype, 'upZ', {\n\t        set: function (pos) {\n\t            this._orientation[5] = pos;\n\t            this.setOrientation.apply(this, this._orientation);\n\t        },\n\t        get: function () {\n\t            return this._orientation[5];\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Listener} this\n\t\t */\n\t    Tone.Listener.prototype.dispose = function () {\n\t        this._orientation = null;\n\t        this._position = null;\n\t        return this;\n\t    };\n\t    //SINGLETON SETUP\n\t    var ListenerConstructor = Tone.Listener;\n\t    Tone.Listener = new ListenerConstructor();\n\t    Tone.Context.on('init', function (context) {\n\t        if (context.Listener instanceof ListenerConstructor) {\n\t            //a single listener object\n\t            Tone.Listener = context.Listener;\n\t        } else {\n\t            //make new Listener insides\n\t            Tone.Listener = new ListenerConstructor();\n\t        }\n\t        context.Listener = Tone.Listener;\n\t    });\n\t    //END SINGLETON SETUP\n\t    return Tone.Listener;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  shim\n\t\t *  @private\n\t\t */\n\t    if (!window.hasOwnProperty('OfflineAudioContext') && window.hasOwnProperty('webkitOfflineAudioContext')) {\n\t        window.OfflineAudioContext = window.webkitOfflineAudioContext;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the OfflineAudioContext\n\t\t *  @extends {Tone.Context\n\t\t *  @param  {Number}  channels  The number of channels to render\n\t\t *  @param  {Number}  duration  The duration to render in samples\n\t\t *  @param {Number} sampleRate the sample rate to render at\n\t\t */\n\t    Tone.OfflineContext = function (channels, duration, sampleRate) {\n\t        /**\n\t\t\t *  The offline context\n\t\t\t *  @private\n\t\t\t *  @type  {OfflineAudioContext}\n\t\t\t */\n\t        var offlineContext = new OfflineAudioContext(channels, duration * sampleRate, sampleRate);\n\t        //wrap the methods/members\n\t        Tone.Context.call(this, offlineContext);\n\t        /**\n\t\t\t *  A private reference to the duration\n\t\t\t *  @private\n\t\t\t *  @type  {Number}\n\t\t\t */\n\t        this._duration = duration;\n\t        /**\n\t\t\t *  An artificial clock source\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._currentTime = 0;\n\t        //modify the lookAhead and updateInterval to one block\n\t        this.lookAhead = this.blockTime;\n\t        this.updateInterval = this.blockTime;\n\t    };\n\t    Tone.extend(Tone.OfflineContext, Tone.Context);\n\t    /**\n\t\t *  Override the now method to point to the internal clock time\n\t\t *  @return  {Number}\n\t\t */\n\t    Tone.OfflineContext.prototype.now = function () {\n\t        return this._currentTime;\n\t    };\n\t    /**\n\t\t *  Overwrite this method since the worker is not necessary for the offline context\n\t\t *  @private\n\t\t */\n\t    Tone.OfflineContext.prototype._createWorker = function () {\n\t        //dummy worker that does nothing\n\t        return {\n\t            postMessage: function () {\n\t            }\n\t        };\n\t    };\n\t    /**\n\t\t *  Render the output of the OfflineContext\n\t\t *  @return  {Promise}\n\t\t */\n\t    Tone.OfflineContext.prototype.render = function () {\n\t        while (this._duration - this._currentTime >= 0) {\n\t            //invoke all the callbacks on that time\n\t            this.emit('tick');\n\t            //increment the clock\n\t            this._currentTime += Tone.prototype.blockTime;\n\t        }\n\t        //promise returned is not yet implemented in all browsers\n\t        return new Promise(function (done) {\n\t            this._context.oncomplete = function (e) {\n\t                done(e.renderedBuffer);\n\t            };\n\t            this._context.startRendering();\n\t        }.bind(this));\n\t    };\n\t    return Tone.OfflineContext;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext. \n\t\t *  The OfflineAudioContext is capable of rendering much faster than real time in many cases. \n\t\t *  The callback function also passes in an offline instance of Tone.Transport which can be used\n\t\t *  to schedule events along the Transport. \n\t\t *  @param  {Function}  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n\t\t *  @param  {Time}  duration     the amount of time to record for.\n\t\t *  @return  {Promise}  The promise which is invoked with the Tone.Buffer of the recorded output.\n\t\t *  @example\n\t\t * //render 2 seconds of the oscillator\n\t\t * Tone.Offline(function(){\n\t\t * \t//only nodes created in this callback will be recorded\n\t\t * \tvar oscillator = new Tone.Oscillator().toMaster().start(0)\n\t\t * \t//schedule their events\n\t\t * }, 2).then(function(buffer){\n\t\t * \t//do something with the output buffer\n\t\t * })\n\t\t * @example\n\t\t * //can also schedule events along the Transport\n\t\t * //using the passed in Offline Transport\n\t\t * Tone.Offline(function(Transport){\n\t\t * \tvar osc = new Tone.Oscillator().toMaster()\n\t\t * \tTransport.schedule(function(time){\n\t\t * \t\tosc.start(time).stop(time + 0.1)\n\t\t * \t}, 1)\n\t\t * \tTransport.start(0.2)\n\t\t * }, 4).then(function(buffer){\n\t\t * \t//do something with the output buffer\n\t\t * })\n\t\t */\n\t    Tone.Offline = function (callback, duration) {\n\t        //set the OfflineAudioContext\n\t        var sampleRate = Tone.context.sampleRate;\n\t        var originalContext = Tone.context;\n\t        var context = new Tone.OfflineContext(2, duration, sampleRate);\n\t        Tone.context = context;\n\t        //invoke the callback/scheduling\n\t        callback(Tone.Transport);\n\t        //process the audio\n\t        var rendered = context.render();\n\t        //return the original AudioContext\n\t        Tone.context = originalContext;\n\t        //return the audio\n\t        return rendered.then(function (buffer) {\n\t            //wrap it in a Tone.Buffer\n\t            return new Tone.Buffer(buffer);\n\t        });\n\t    };\n\t    return Tone.Offline;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * \t@class  Tone.Effect is the base class for effects. Connect the effect between\n\t\t * \t        the effectSend and effectReturn GainNodes, then control the amount of\n\t\t * \t        effect which goes to the output using the wet control.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {NormalRange|Object} [wet] The starting wet value. \n\t\t */\n\t    Tone.Effect = function () {\n\t        this.createInsOuts(1, 1);\n\t        //get all of the defaults\n\t        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);\n\t        /**\n\t\t\t *  the drywet knob to control the amount of effect\n\t\t\t *  @type {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._dryWet = new Tone.CrossFade(options.wet);\n\t        /**\n\t\t\t *  The wet control is how much of the effected\n\t\t\t *  will pass through to the output. 1 = 100% effected\n\t\t\t *  signal, 0 = 100% dry signal. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.wet = this._dryWet.fade;\n\t        /**\n\t\t\t *  connect the effectSend to the input of hte effect\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSend = new Tone.Gain();\n\t        /**\n\t\t\t *  connect the output of the effect to the effectReturn\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturn = new Tone.Gain();\n\t        //connections\n\t        this.input.connect(this._dryWet.a);\n\t        this.input.connect(this.effectSend);\n\t        this.effectReturn.connect(this._dryWet.b);\n\t        this._dryWet.connect(this.output);\n\t        this._readOnly(['wet']);\n\t    };\n\t    Tone.extend(Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Effect.defaults = { 'wet': 1 };\n\t    /**\n\t\t *  chains the effect in between the effectSend and effectReturn\n\t\t *  @param  {Tone} effect\n\t\t *  @private\n\t\t *  @returns {Tone.Effect} this\n\t\t */\n\t    Tone.Effect.prototype.connectEffect = function (effect) {\n\t        this.effectSend.chain(effect, this.effectReturn);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Effect} this\n\t\t */\n\t    Tone.Effect.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._dryWet.dispose();\n\t        this._dryWet = null;\n\t        this.effectSend.dispose();\n\t        this.effectSend = null;\n\t        this.effectReturn.dispose();\n\t        this.effectReturn = null;\n\t        this._writable(['wet']);\n\t        this.wet = null;\n\t        return this;\n\t    };\n\t    return Tone.Effect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n\t\t *         Setting the LFO rate and depth allows for control over the filter modulation rate \n\t\t *         and depth.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Time|Object} [frequency] The rate of the LFO.\n\t\t *  @param {Frequency=} baseFrequency The lower value of the LFOs oscillation\n\t \t *  @param {Frequency=} octaves The number of octaves above the baseFrequency\n\t\t *  @example\n\t\t * //create an autofilter and start it's LFO\n\t\t * var autoFilter = new Tone.AutoFilter(\"4n\").toMaster().start();\n\t\t * //route an oscillator through the filter and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(autoFilter).start();\n\t\t */\n\t    Tone.AutoFilter = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'baseFrequency',\n\t            'octaves'\n\t        ], Tone.AutoFilter.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which drives the filter cutoff\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'amplitude': options.depth\n\t        });\n\t        /**\n\t\t\t * The range of the filter modulating between the min and max frequency. \n\t\t\t * 0 = no modulation. 1 = full modulation.\n\t\t\t * @type {NormalRange}\n\t\t\t * @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        /**\n\t\t\t * How fast the filter modulates between min and max. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        /**\n\t\t\t *  The filter node\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.filter = new Tone.Filter(options.filter);\n\t        /**\n\t\t\t *  The octaves placeholder\n\t\t\t *  @type {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = 0;\n\t        //connections\n\t        this.connectEffect(this.filter);\n\t        this._lfo.connect(this.filter.frequency);\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.octaves = options.octaves;\n\t        this.baseFrequency = options.baseFrequency;\n\t    };\n\t    //extend Effect\n\t    Tone.extend(Tone.AutoFilter, Tone.Effect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoFilter.defaults = {\n\t        'frequency': 1,\n\t        'type': 'sine',\n\t        'depth': 1,\n\t        'baseFrequency': 200,\n\t        'octaves': 2.6,\n\t        'filter': {\n\t            'type': 'lowpass',\n\t            'rolloff': -12,\n\t            'Q': 1\n\t        }\n\t    };\n\t    /**\n\t\t * Start the effect.\n\t\t * @param {Time} [time=now] When the LFO will start. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.start = function (time) {\n\t        this._lfo.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the effect.\n\t\t * @param {Time} [time=now] When the LFO will stop. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.stop = function (time) {\n\t        this._lfo.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the filter to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                               Transport has started. \n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.sync = function (delay) {\n\t        this._lfo.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the filter from the transport.\n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.unsync = function () {\n\t        this._lfo.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the AutoFilter. \n\t\t * Possible values: \"sine\", \"square\", \"triangle\", \"sawtooth\".\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The minimum value of the filter's cutoff frequency.\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {Frequency}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._lfo.min;\n\t        },\n\t        set: function (freq) {\n\t            this._lfo.min = this.toFrequency(freq);\n\t            //and set the max\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum value of the filter's cutoff frequency. \n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.AutoFilter.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (oct) {\n\t            this._octaves = oct;\n\t            this._lfo.max = this.baseFrequency * Math.pow(2, oct);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.AutoFilter.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this.filter.dispose();\n\t        this.filter = null;\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoFilter;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AutoPanner is a Tone.Panner with an LFO connected to the pan amount. \n\t\t *         More on using autopanners [here](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency|Object} [frequency] Rate of left-right oscillation. \n\t\t *  @example\n\t\t * //create an autopanner and start it's LFO\n\t\t * var autoPanner = new Tone.AutoPanner(\"4n\").toMaster().start();\n\t\t * //route an oscillator through the panner and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(autoPanner).start();\n\t\t */\n\t    Tone.AutoPanner = function () {\n\t        var options = this.optionsObject(arguments, ['frequency'], Tone.AutoPanner.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which drives the panning\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'amplitude': options.depth,\n\t            'min': -1,\n\t            'max': 1\n\t        });\n\t        /**\n\t\t\t * The amount of panning between left and right. \n\t\t\t * 0 = always center. 1 = full range between left and right. \n\t\t\t * @type {NormalRange}\n\t\t\t * @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        /**\n\t\t\t *  the panner node which does the panning\n\t\t\t *  @type {Tone.Panner}\n\t\t\t *  @private\n\t\t\t */\n\t        this._panner = new Tone.Panner();\n\t        /**\n\t\t\t * How fast the panner modulates between left and right. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        //connections\n\t        this.connectEffect(this._panner);\n\t        this._lfo.connect(this._panner.pan);\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'depth',\n\t            'frequency'\n\t        ]);\n\t    };\n\t    //extend Effect\n\t    Tone.extend(Tone.AutoPanner, Tone.Effect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoPanner.defaults = {\n\t        'frequency': 1,\n\t        'type': 'sine',\n\t        'depth': 1\n\t    };\n\t    /**\n\t\t * Start the effect.\n\t\t * @param {Time} [time=now] When the LFO will start. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.start = function (time) {\n\t        this._lfo.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the effect.\n\t\t * @param {Time} [time=now] When the LFO will stop. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.stop = function (time) {\n\t        this._lfo.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the panner to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                               Transport has started. \n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.sync = function (delay) {\n\t        this._lfo.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the panner from the transport\n\t\t * @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.unsync = function () {\n\t        this._lfo.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the AutoFilter. \n\t\t * Possible values: \"sine\", \"square\", \"triangle\", \"sawtooth\".\n\t\t * @memberOf Tone.AutoFilter#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AutoPanner.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AutoPanner} this\n\t\t */\n\t    Tone.AutoPanner.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this._panner.dispose();\n\t        this._panner = null;\n\t        this._writable([\n\t            'depth',\n\t            'frequency'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoPanner;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.AutoWah connects a Tone.Follower to a bandpass filter (Tone.Filter).\n\t\t *          The frequency of the filter is adjusted proportionally to the \n\t\t *          incoming signal's amplitude. Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency|Object} [baseFrequency] The frequency the filter is set \n\t\t *                                            to at the low point of the wah\n\t\t *  @param {Positive} [octaves] The number of octaves above the baseFrequency\n\t\t *                                the filter will sweep to when fully open\n\t\t *  @param {Decibels} [sensitivity] The decibel threshold sensitivity for \n\t\t *                                   the incoming signal. Normal range of -40 to 0. \n\t\t *  @example\n\t\t * var autoWah = new Tone.AutoWah(50, 6, -30).toMaster();\n\t\t * //initialize the synth and connect to autowah\n\t\t * var synth = new Synth.connect(autoWah);\n\t\t * //Q value influences the effect of the wah - default is 2\n\t\t * autoWah.Q.value = 6;\n\t\t * //more audible on higher notes\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\")\n\t\t */\n\t    Tone.AutoWah = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'baseFrequency',\n\t            'octaves',\n\t            'sensitivity'\n\t        ], Tone.AutoWah.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  The envelope follower. Set the attack/release\n\t\t\t *  timing to adjust how the envelope is followed. \n\t\t\t *  @type {Tone.Follower}\n\t\t\t *  @private\n\t\t\t */\n\t        this.follower = new Tone.Follower(options.follower);\n\t        /**\n\t\t\t *  scales the follower value to the frequency domain\n\t\t\t *  @type {Tone}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sweepRange = new Tone.ScaleExp(0, 1, 0.5);\n\t        /**\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._baseFrequency = options.baseFrequency;\n\t        /**\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  the input gain to adjust the sensitivity\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputBoost = new Tone.Gain();\n\t        /**\n\t\t\t *  @type {BiquadFilterNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._bandpass = new Tone.Filter({\n\t            'rolloff': -48,\n\t            'frequency': 0,\n\t            'Q': options.Q\n\t        });\n\t        /**\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._peaking = new Tone.Filter(0, 'peaking');\n\t        this._peaking.gain.value = options.gain;\n\t        /**\n\t\t\t * The gain of the filter.\n\t\t\t * @type {Number}\n\t\t\t * @signal\n\t\t\t */\n\t        this.gain = this._peaking.gain;\n\t        /**\n\t\t\t * The quality of the filter.\n\t\t\t * @type {Positive}\n\t\t\t * @signal\n\t\t\t */\n\t        this.Q = this._bandpass.Q;\n\t        //the control signal path\n\t        this.effectSend.chain(this._inputBoost, this.follower, this._sweepRange);\n\t        this._sweepRange.connect(this._bandpass.frequency);\n\t        this._sweepRange.connect(this._peaking.frequency);\n\t        //the filtered path\n\t        this.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t        //set the initial value\n\t        this._setSweepRange();\n\t        this.sensitivity = options.sensitivity;\n\t        this._readOnly([\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AutoWah, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AutoWah.defaults = {\n\t        'baseFrequency': 100,\n\t        'octaves': 6,\n\t        'sensitivity': 0,\n\t        'Q': 2,\n\t        'gain': 2,\n\t        'follower': {\n\t            'attack': 0.3,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t * The number of octaves that the filter will sweep above the \n\t\t * baseFrequency. \n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Number}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            this._setSweepRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The base frequency from which the sweep will start from.\n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Frequency}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._baseFrequency;\n\t        },\n\t        set: function (baseFreq) {\n\t            this._baseFrequency = baseFreq;\n\t            this._setSweepRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The sensitivity to control how responsive to the input signal the filter is. \n\t\t * @memberOf Tone.AutoWah#\n\t\t * @type {Decibels}\n\t\t * @name sensitivity\n\t\t */\n\t    Object.defineProperty(Tone.AutoWah.prototype, 'sensitivity', {\n\t        get: function () {\n\t            return this.gainToDb(1 / this._inputBoost.gain.value);\n\t        },\n\t        set: function (sensitivy) {\n\t            this._inputBoost.gain.value = 1 / this.dbToGain(sensitivy);\n\t        }\n\t    });\n\t    /**\n\t\t *  sets the sweep range of the scaler\n\t\t *  @private\n\t\t */\n\t    Tone.AutoWah.prototype._setSweepRange = function () {\n\t        this._sweepRange.min = this._baseFrequency;\n\t        this._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.AutoWah} this\n\t\t */\n\t    Tone.AutoWah.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this.follower.dispose();\n\t        this.follower = null;\n\t        this._sweepRange.dispose();\n\t        this._sweepRange = null;\n\t        this._bandpass.dispose();\n\t        this._bandpass = null;\n\t        this._peaking.dispose();\n\t        this._peaking = null;\n\t        this._inputBoost.dispose();\n\t        this._inputBoost = null;\n\t        this._writable([\n\t            'gain',\n\t            'Q'\n\t        ]);\n\t        this.gain = null;\n\t        this.Q = null;\n\t        return this;\n\t    };\n\t    return Tone.AutoWah;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Bitcrusher downsamples the incoming signal to a different bitdepth. \n\t\t *         Lowering the bitdepth of the signal creates distortion. Read more about Bitcrushing\n\t\t *         on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Number} bits The number of bits to downsample the signal. Nominal range\n\t\t *                       of 1 to 8. \n\t\t *  @example\n\t\t * //initialize crusher and route a synth through it\n\t\t * var crusher = new Tone.BitCrusher(4).toMaster();\n\t\t * var synth = new Tone.MonoSynth().connect(crusher);\n\t\t */\n\t    Tone.BitCrusher = function () {\n\t        var options = this.optionsObject(arguments, ['bits'], Tone.BitCrusher.defaults);\n\t        Tone.Effect.call(this, options);\n\t        var invStepSize = 1 / Math.pow(2, options.bits - 1);\n\t        /**\n\t\t\t *  Subtract the input signal and the modulus of the input signal\n\t\t\t *  @type {Tone.Subtract}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subtract = new Tone.Subtract();\n\t        /**\n\t\t\t *  The mod function\n\t\t\t *  @type  {Tone.Modulo}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulo = new Tone.Modulo(invStepSize);\n\t        /**\n\t\t\t *  keeps track of the bits\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._bits = options.bits;\n\t        //connect it up\n\t        this.effectSend.fan(this._subtract, this._modulo);\n\t        this._modulo.connect(this._subtract, 0, 1);\n\t        this._subtract.connect(this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.BitCrusher, Tone.Effect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.BitCrusher.defaults = { 'bits': 4 };\n\t    /**\n\t\t * The bit depth of the effect. Nominal range of 1-8. \n\t\t * @memberOf Tone.BitCrusher#\n\t\t * @type {number}\n\t\t * @name bits\n\t\t */\n\t    Object.defineProperty(Tone.BitCrusher.prototype, 'bits', {\n\t        get: function () {\n\t            return this._bits;\n\t        },\n\t        set: function (bits) {\n\t            this._bits = bits;\n\t            var invStepSize = 1 / Math.pow(2, bits - 1);\n\t            this._modulo.value = invStepSize;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.BitCrusher} this\n\t\t */\n\t    Tone.BitCrusher.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._subtract.dispose();\n\t        this._subtract = null;\n\t        this._modulo.dispose();\n\t        this._modulo = null;\n\t        return this;\n\t    };\n\t    return Tone.BitCrusher;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.ChebyShev is a Chebyshev waveshaper, an effect which is good \n\t\t *         for making different types of distortion sounds.\n\t\t *         Note that odd orders sound very different from even ones, \n\t\t *         and order = 1 is no change. \n\t\t *         Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {Positive|Object} [order] The order of the chebyshev polynomial. Normal range between 1-100. \n\t\t *  @example\n\t\t * //create a new cheby\n\t\t * var cheby = new Tone.Chebyshev(50);\n\t\t * //create a monosynth connected to our cheby\n\t\t * synth = new Tone.MonoSynth().connect(cheby);\n\t\t */\n\t    Tone.Chebyshev = function () {\n\t        var options = this.optionsObject(arguments, ['order'], Tone.Chebyshev.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(4096);\n\t        /**\n\t\t\t * holds onto the order of the filter\n\t\t\t * @type {number}\n\t\t\t * @private\n\t\t\t */\n\t        this._order = options.order;\n\t        this.connectEffect(this._shaper);\n\t        this.order = options.order;\n\t        this.oversample = options.oversample;\n\t    };\n\t    Tone.extend(Tone.Chebyshev, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Chebyshev.defaults = {\n\t        'order': 1,\n\t        'oversample': 'none'\n\t    };\n\t    /**\n\t\t *  get the coefficient for that degree\n\t\t *  @param {number} x the x value\n\t\t *  @param   {number} degree \n\t\t *  @param {Object} memo memoize the computed value. \n\t\t *                       this speeds up computation greatly. \n\t\t *  @return  {number}       the coefficient \n\t\t *  @private\n\t\t */\n\t    Tone.Chebyshev.prototype._getCoefficient = function (x, degree, memo) {\n\t        if (memo.hasOwnProperty(degree)) {\n\t            return memo[degree];\n\t        } else if (degree === 0) {\n\t            memo[degree] = 0;\n\t        } else if (degree === 1) {\n\t            memo[degree] = x;\n\t        } else {\n\t            memo[degree] = 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo);\n\t        }\n\t        return memo[degree];\n\t    };\n\t    /**\n\t\t * The order of the Chebyshev polynomial which creates\n\t\t * the equation which is applied to the incoming \n\t\t * signal through a Tone.WaveShaper. The equations\n\t\t * are in the form:<br>\n\t\t * order 2: 2x^2 + 1<br>\n\t\t * order 3: 4x^3 + 3x <br>\n\t\t * @memberOf Tone.Chebyshev#\n\t\t * @type {Positive}\n\t\t * @name order\n\t\t */\n\t    Object.defineProperty(Tone.Chebyshev.prototype, 'order', {\n\t        get: function () {\n\t            return this._order;\n\t        },\n\t        set: function (order) {\n\t            this._order = order;\n\t            var curve = new Array(4096);\n\t            var len = curve.length;\n\t            for (var i = 0; i < len; ++i) {\n\t                var x = i * 2 / len - 1;\n\t                if (x === 0) {\n\t                    //should output 0 when input is 0\n\t                    curve[i] = 0;\n\t                } else {\n\t                    curve[i] = this._getCoefficient(x, order, {});\n\t                }\n\t            }\n\t            this._shaper.curve = curve;\n\t        }\n\t    });\n\t    /**\n\t\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t\t * @memberOf Tone.Chebyshev#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.Chebyshev.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            this._shaper.oversample = oversampling;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Chebyshev} this\n\t\t */\n\t    Tone.Chebyshev.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        return this;\n\t    };\n\t    return Tone.Chebyshev;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Base class for Stereo effects. Provides effectSendL/R and effectReturnL/R. \n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.Effect}\n\t\t */\n\t    Tone.StereoEffect = function () {\n\t        this.createInsOuts(1, 1);\n\t        //get the defaults\n\t        var options = this.optionsObject(arguments, ['wet'], Tone.Effect.defaults);\n\t        /**\n\t\t\t *  the drywet knob to control the amount of effect\n\t\t\t *  @type {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._dryWet = new Tone.CrossFade(options.wet);\n\t        /**\n\t\t\t *  The wet control, i.e. how much of the effected\n\t\t\t *  will pass through to the output. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.wet = this._dryWet.fade;\n\t        /**\n\t\t\t *  then split it\n\t\t\t *  @type {Tone.Split}\n\t\t\t *  @private\n\t\t\t */\n\t        this._split = new Tone.Split();\n\t        /**\n\t\t\t *  the effects send LEFT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSendL = this._split.left;\n\t        /**\n\t\t\t *  the effects send RIGHT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectSendR = this._split.right;\n\t        /**\n\t\t\t *  the stereo effect merger\n\t\t\t *  @type {Tone.Merge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._merge = new Tone.Merge();\n\t        /**\n\t\t\t *  the effect return LEFT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturnL = this._merge.left;\n\t        /**\n\t\t\t *  the effect return RIGHT\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.effectReturnR = this._merge.right;\n\t        //connections\n\t        this.input.connect(this._split);\n\t        //dry wet connections\n\t        this.input.connect(this._dryWet, 0, 0);\n\t        this._merge.connect(this._dryWet, 0, 1);\n\t        this._dryWet.connect(this.output);\n\t        this._readOnly(['wet']);\n\t    };\n\t    Tone.extend(Tone.StereoEffect, Tone.Effect);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.StereoEffect} this\n\t\t */\n\t    Tone.StereoEffect.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._dryWet.dispose();\n\t        this._dryWet = null;\n\t        this._split.dispose();\n\t        this._split = null;\n\t        this._merge.dispose();\n\t        this._merge = null;\n\t        this.effectSendL = null;\n\t        this.effectSendR = null;\n\t        this.effectReturnL = null;\n\t        this.effectReturnR = null;\n\t        this._writable(['wet']);\n\t        this.wet = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t * \t@class  Tone.FeedbackEffect provides a loop between an \n\t\t * \t        audio source and its own output. This is a base-class\n\t\t * \t        for feedback effects. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {NormalRange|Object} [feedback] The initial feedback value.\n\t\t */\n\t    Tone.FeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback']);\n\t        options = this.defaultArg(options, Tone.FeedbackEffect.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  the gain which controls the feedback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackGain = new Tone.Gain(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of signal which is fed back into the effect input. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = this._feedbackGain.gain;\n\t        //the feedback loop\n\t        this.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.FeedbackEffect, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackEffect.defaults = { 'feedback': 0.125 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.FeedbackEffect} this\n\t\t */\n\t    Tone.FeedbackEffect.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this._feedbackGain.dispose();\n\t        this._feedbackGain = null;\n\t        this.feedback = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Just like a stereo feedback effect, but the feedback is routed from left to right\n\t\t *         and right to left instead of on the same channel.\n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.FeedbackEffect}\n\t\t */\n\t    Tone.StereoXFeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The amount of feedback from the output\n\t\t\t *  back into the input of the effect (routed\n\t\t\t *  across left and right channels).\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  the left side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackLR = new Tone.Gain();\n\t        /**\n\t\t\t *  the right side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackRL = new Tone.Gain();\n\t        //connect it up\n\t        this.effectReturnL.chain(this._feedbackLR, this.effectSendR);\n\t        this.effectReturnR.chain(this._feedbackRL, this.effectSendL);\n\t        this.feedback.fan(this._feedbackLR.gain, this._feedbackRL.gain);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.StereoXFeedbackEffect, Tone.FeedbackEffect);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.StereoXFeedbackEffect} this\n\t\t */\n\t    Tone.StereoXFeedbackEffect.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this.feedback.dispose();\n\t        this.feedback = null;\n\t        this._feedbackLR.dispose();\n\t        this._feedbackLR = null;\n\t        this._feedbackRL.dispose();\n\t        this._feedbackRL = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoXFeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Chorus is a stereo chorus effect with feedback composed of \n\t\t *         a left and right delay with a Tone.LFO applied to the delayTime of each channel. \n\t\t *         Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n\t\t *         Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.StereoXFeedbackEffect}\n\t\t *\t@param {Frequency|Object} [frequency] The frequency of the LFO.\n\t\t *\t@param {Milliseconds} [delayTime] The delay of the chorus effect in ms. \n\t\t *\t@param {NormalRange} [depth] The depth of the chorus.\n\t\t *\t@example\n\t\t * var chorus = new Tone.Chorus(4, 2.5, 0.5);\n\t\t * var synth = new Tone.PolySynth(4, Tone.MonoSynth).connect(chorus);\n\t\t * synth.triggerAttackRelease([\"C3\",\"E3\",\"G3\"], \"8n\");\n\t\t */\n\t    Tone.Chorus = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'delayTime',\n\t            'depth'\n\t        ], Tone.Chorus.defaults);\n\t        Tone.StereoXFeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the depth of the chorus\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._depth = options.depth;\n\t        /**\n\t\t\t *  the delayTime\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayTime = options.delayTime / 1000;\n\t        /**\n\t\t\t *  the lfo which controls the delayTime\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'min': 0,\n\t            'max': 1\n\t        });\n\t        /**\n\t\t\t *  another LFO for the right side with a 180 degree phase diff\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO({\n\t            'frequency': options.frequency,\n\t            'min': 0,\n\t            'max': 1,\n\t            'phase': 180\n\t        });\n\t        /**\n\t\t\t *  delay for left\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNodeL = new Tone.Delay();\n\t        /**\n\t\t\t *  delay for right\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNodeR = new Tone.Delay();\n\t        /**\n\t\t\t * The frequency of the LFO which modulates the delayTime. \n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.frequency = this._lfoL.frequency;\n\t        //connections\n\t        this.effectSendL.chain(this._delayNodeL, this.effectReturnL);\n\t        this.effectSendR.chain(this._delayNodeR, this.effectReturnR);\n\t        //and pass through to make the detune apparent\n\t        this.effectSendL.connect(this.effectReturnL);\n\t        this.effectSendR.connect(this.effectReturnR);\n\t        //lfo setup\n\t        this._lfoL.connect(this._delayNodeL.delayTime);\n\t        this._lfoR.connect(this._delayNodeR.delayTime);\n\t        //start the lfo\n\t        this._lfoL.start();\n\t        this._lfoR.start();\n\t        //have one LFO frequency control the other\n\t        this._lfoL.frequency.connect(this._lfoR.frequency);\n\t        //set the initial values\n\t        this.depth = this._depth;\n\t        this.frequency.value = options.frequency;\n\t        this.type = options.type;\n\t        this._readOnly(['frequency']);\n\t        this.spread = options.spread;\n\t    };\n\t    Tone.extend(Tone.Chorus, Tone.StereoXFeedbackEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Chorus.defaults = {\n\t        'frequency': 1.5,\n\t        'delayTime': 3.5,\n\t        'depth': 0.7,\n\t        'feedback': 0.1,\n\t        'type': 'sine',\n\t        'spread': 180\n\t    };\n\t    /**\n\t\t * The depth of the effect. A depth of 1 makes the delayTime\n\t\t * modulate between 0 and 2*delayTime (centered around the delayTime). \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {NormalRange}\n\t\t * @name depth\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'depth', {\n\t        get: function () {\n\t            return this._depth;\n\t        },\n\t        set: function (depth) {\n\t            this._depth = depth;\n\t            var deviation = this._delayTime * depth;\n\t            this._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t            this._lfoL.max = this._delayTime + deviation;\n\t            this._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t            this._lfoR.max = this._delayTime + deviation;\n\t        }\n\t    });\n\t    /**\n\t\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t\t * will give a more pronounced effect. Nominal range a delayTime\n\t\t * is between 2 and 20ms. \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {Milliseconds}\n\t\t * @name delayTime\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'delayTime', {\n\t        get: function () {\n\t            return this._delayTime * 1000;\n\t        },\n\t        set: function (delayTime) {\n\t            this._delayTime = delayTime / 1000;\n\t            this.depth = this._depth;\n\t        }\n\t    });\n\t    /**\n\t\t * The oscillator type of the LFO. \n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfoL.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfoL.type = type;\n\t            this._lfoR.type = type;\n\t        }\n\t    });\n\t    /** \n\t\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t\t * @memberOf Tone.Chorus#\n\t\t * @type {Degrees}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.Chorus.prototype, 'spread', {\n\t        get: function () {\n\t            return this._lfoR.phase - this._lfoL.phase;    //180\n\t        },\n\t        set: function (spread) {\n\t            this._lfoL.phase = 90 - spread / 2;\n\t            this._lfoR.phase = spread / 2 + 90;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Chorus} this\n\t\t */\n\t    Tone.Chorus.prototype.dispose = function () {\n\t        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        this._delayNodeL.dispose();\n\t        this._delayNodeL = null;\n\t        this._delayNodeR.dispose();\n\t        this._delayNodeR = null;\n\t        this._writable('frequency');\n\t        this.frequency = null;\n\t        return this;\n\t    };\n\t    return Tone.Chorus;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Convolver is a wrapper around the Native Web Audio \n\t\t *          [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n\t\t *          Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n\t\t *          [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {string|Tone.Buffer|Object} [url] The URL of the impulse response or the Tone.Buffer\n\t\t *                                           contianing the impulse response. \n\t\t *  @param {Function} onload The callback to invoke when the url is loaded.\n\t\t *  @example\n\t\t * //initializing the convolver with an impulse response\n\t\t * var convolver = new Tone.Convolver(\"./path/to/ir.wav\").toMaster();\n\t\t */\n\t    Tone.Convolver = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.Convolver.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  convolver node\n\t\t\t *  @type {ConvolverNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._convolver = this.context.createConvolver();\n\t        /**\n\t\t\t *  the convolution buffer\n\t\t\t *  @type {Tone.Buffer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._buffer = new Tone.Buffer();\n\t        if (this.isString(options.url)) {\n\t            this._buffer.load(options.url, function (buffer) {\n\t                this.buffer = buffer;\n\t                options.onload();\n\t            }.bind(this));\n\t        } else if (options.url) {\n\t            this.buffer = options.url;\n\t            options.onload();\n\t        }\n\t        this.connectEffect(this._convolver);\n\t    };\n\t    Tone.extend(Tone.Convolver, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Convolver.defaults = { 'onload': Tone.noOp };\n\t    /**\n\t\t *  The convolver's buffer\n\t\t *  @memberOf Tone.Convolver#\n\t\t *  @type {AudioBuffer}\n\t\t *  @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Convolver.prototype, 'buffer', {\n\t        get: function () {\n\t            return this._buffer.get();\n\t        },\n\t        set: function (buffer) {\n\t            this._buffer.set(buffer);\n\t            this._convolver.buffer = this._buffer.get();\n\t        }\n\t    });\n\t    /**\n\t\t *  Load an impulse response url as an audio buffer.\n\t\t *  Decodes the audio asynchronously and invokes\n\t\t *  the callback once the audio buffer loads.\n\t\t *  @param {string} url The url of the buffer to load.\n\t\t *                      filetype support depends on the\n\t\t *                      browser.\n\t\t *  @param  {function=} callback\n\t\t *  @returns {Promise}\n\t\t */\n\t    Tone.Convolver.prototype.load = function (url, callback) {\n\t        return this._buffer.load(url, function (buff) {\n\t            this.buffer = buff;\n\t            if (callback) {\n\t                callback();\n\t            }\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Convolver} this\n\t\t */\n\t    Tone.Convolver.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._convolver.disconnect();\n\t        this._convolver = null;\n\t        this._buffer.dispose();\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    return Tone.Convolver;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Distortion is a simple distortion effect using Tone.WaveShaper.\n\t\t *         Algorithm from [a stackoverflow answer](http://stackoverflow.com/a/22313408).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {Number|Object} [distortion] The amount of distortion (nominal range of 0-1)\n\t\t *  @example\n\t\t * var dist = new Tone.Distortion(0.8).toMaster();\n\t\t * var fm = new Tone.SimpleFM().connect(dist);\n\t\t * //this sounds good on bass notes\n\t\t * fm.triggerAttackRelease(\"A1\", \"8n\");\n\t\t */\n\t    Tone.Distortion = function () {\n\t        var options = this.optionsObject(arguments, ['distortion'], Tone.Distortion.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._shaper = new Tone.WaveShaper(4096);\n\t        /**\n\t\t\t * holds the distortion amount\n\t\t\t * @type {number}\n\t\t\t * @private\n\t\t\t */\n\t        this._distortion = options.distortion;\n\t        this.connectEffect(this._shaper);\n\t        this.distortion = options.distortion;\n\t        this.oversample = options.oversample;\n\t    };\n\t    Tone.extend(Tone.Distortion, Tone.Effect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Distortion.defaults = {\n\t        'distortion': 0.4,\n\t        'oversample': 'none'\n\t    };\n\t    /**\n\t\t * The amount of distortion.\n\t\t * @memberOf Tone.Distortion#\n\t\t * @type {NormalRange}\n\t\t * @name distortion\n\t\t */\n\t    Object.defineProperty(Tone.Distortion.prototype, 'distortion', {\n\t        get: function () {\n\t            return this._distortion;\n\t        },\n\t        set: function (amount) {\n\t            this._distortion = amount;\n\t            var k = amount * 100;\n\t            var deg = Math.PI / 180;\n\t            this._shaper.setMap(function (x) {\n\t                if (Math.abs(x) < 0.001) {\n\t                    //should output 0 when input is 0\n\t                    return 0;\n\t                } else {\n\t                    return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t                }\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t\t * @memberOf Tone.Distortion#\n\t\t * @type {string}\n\t\t * @name oversample\n\t\t */\n\t    Object.defineProperty(Tone.Distortion.prototype, 'oversample', {\n\t        get: function () {\n\t            return this._shaper.oversample;\n\t        },\n\t        set: function (oversampling) {\n\t            this._shaper.oversample = oversampling;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Distortion} this\n\t\t */\n\t    Tone.Distortion.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._shaper.dispose();\n\t        this._shaper = null;\n\t        return this;\n\t    };\n\t    return Tone.Distortion;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.FeedbackDelay is a DelayNode in which part of output\n\t\t *          signal is fed back into the delay. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.FeedbackEffect}\n\t\t *  @param {Time|Object} [delayTime] The delay applied to the incoming signal. \n\t\t *  @param {NormalRange=} feedback The amount of the effected signal which \n\t\t *                            is fed back through the delay.\n\t\t *  @example\n\t\t * var feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toMaster();\n\t\t * var tom = new Tone.DrumSynth({\n\t\t * \t\"octaves\" : 4,\n\t\t * \t\"pitchDecay\" : 0.1\n\t\t * }).connect(feedbackDelay);\n\t\t * tom.triggerAttackRelease(\"A2\",\"32n\");\n\t\t */\n\t    Tone.FeedbackDelay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'feedback'\n\t        ], Tone.FeedbackDelay.defaults);\n\t        Tone.FeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the delay node\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The delayTime of the DelayNode. \n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._delayNode.delayTime;\n\t        // connect it up\n\t        this.connectEffect(this._delayNode);\n\t        this._readOnly(['delayTime']);\n\t    };\n\t    Tone.extend(Tone.FeedbackDelay, Tone.FeedbackEffect);\n\t    /**\n\t\t *  The default values. \n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FeedbackDelay.defaults = { 'delayTime': 0.25 };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FeedbackDelay} this\n\t\t */\n\t    Tone.FeedbackDelay.prototype.dispose = function () {\n\t        Tone.FeedbackEffect.prototype.dispose.call(this);\n\t        this._delayNode.dispose();\n\t        this._delayNode = null;\n\t        this._writable(['delayTime']);\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.FeedbackDelay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  an array of comb filter delay values from Freeverb implementation\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterTunings = [\n\t        1557 / 44100,\n\t        1617 / 44100,\n\t        1491 / 44100,\n\t        1422 / 44100,\n\t        1277 / 44100,\n\t        1356 / 44100,\n\t        1188 / 44100,\n\t        1116 / 44100\n\t    ];\n\t    /**\n\t\t *  an array of allpass filter frequency values from Freeverb implementation\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var allpassFilterFrequencies = [\n\t        225,\n\t        556,\n\t        441,\n\t        341\n\t    ];\n\t    /**\n\t\t *  @class Tone.Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n\t\t *         Read more on reverb on [SoundOnSound](http://www.soundonsound.com/sos/may00/articles/reverb.htm).\n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [roomSize] Correlated to the decay time. \n\t\t *  @param {Frequency} [dampening] The cutoff frequency of a lowpass filter as part \n\t\t *                                 of the reverb. \n\t\t *  @example\n\t\t * var freeverb = new Tone.Freeverb().toMaster();\n\t\t * freeverb.dampening.value = 1000;\n\t\t * //routing synth through the reverb\n\t\t * var synth = new Tone.AMSynth().connect(freeverb);\n\t\t */\n\t    Tone.Freeverb = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'roomSize',\n\t            'dampening'\n\t        ], Tone.Freeverb.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The roomSize value between. A larger roomSize\n\t\t\t *  will result in a longer decay. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  The amount of dampening of the reverberant signal. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = new Tone.Signal(options.dampening, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  the comb filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._combFilters = [];\n\t        /**\n\t\t\t *  the allpass filters on the left\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFiltersL = [];\n\t        /**\n\t\t\t *  the allpass filters on the right\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFiltersR = [];\n\t        //make the allpass filters on the right\n\t        for (var l = 0; l < allpassFilterFrequencies.length; l++) {\n\t            var allpassL = this.context.createBiquadFilter();\n\t            allpassL.type = 'allpass';\n\t            allpassL.frequency.value = allpassFilterFrequencies[l];\n\t            this._allpassFiltersL.push(allpassL);\n\t        }\n\t        //make the allpass filters on the left\n\t        for (var r = 0; r < allpassFilterFrequencies.length; r++) {\n\t            var allpassR = this.context.createBiquadFilter();\n\t            allpassR.type = 'allpass';\n\t            allpassR.frequency.value = allpassFilterFrequencies[r];\n\t            this._allpassFiltersR.push(allpassR);\n\t        }\n\t        //make the comb filters\n\t        for (var c = 0; c < combFilterTunings.length; c++) {\n\t            var lfpf = new Tone.LowpassCombFilter(combFilterTunings[c]);\n\t            if (c < combFilterTunings.length / 2) {\n\t                this.effectSendL.chain(lfpf, this._allpassFiltersL[0]);\n\t            } else {\n\t                this.effectSendR.chain(lfpf, this._allpassFiltersR[0]);\n\t            }\n\t            this.roomSize.connect(lfpf.resonance);\n\t            this.dampening.connect(lfpf.dampening);\n\t            this._combFilters.push(lfpf);\n\t        }\n\t        //chain the allpass filters togetehr\n\t        this.connectSeries.apply(this, this._allpassFiltersL);\n\t        this.connectSeries.apply(this, this._allpassFiltersR);\n\t        this._allpassFiltersL[this._allpassFiltersL.length - 1].connect(this.effectReturnL);\n\t        this._allpassFiltersR[this._allpassFiltersR.length - 1].connect(this.effectReturnR);\n\t        this._readOnly([\n\t            'roomSize',\n\t            'dampening'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Freeverb, Tone.StereoEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Freeverb.defaults = {\n\t        'roomSize': 0.7,\n\t        'dampening': 3000\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.Freeverb} this\n\t\t */\n\t    Tone.Freeverb.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        for (var al = 0; al < this._allpassFiltersL.length; al++) {\n\t            this._allpassFiltersL[al].disconnect();\n\t            this._allpassFiltersL[al] = null;\n\t        }\n\t        this._allpassFiltersL = null;\n\t        for (var ar = 0; ar < this._allpassFiltersR.length; ar++) {\n\t            this._allpassFiltersR[ar].disconnect();\n\t            this._allpassFiltersR[ar] = null;\n\t        }\n\t        this._allpassFiltersR = null;\n\t        for (var cf = 0; cf < this._combFilters.length; cf++) {\n\t            this._combFilters[cf].dispose();\n\t            this._combFilters[cf] = null;\n\t        }\n\t        this._combFilters = null;\n\t        this._writable([\n\t            'roomSize',\n\t            'dampening'\n\t        ]);\n\t        this.roomSize.dispose();\n\t        this.roomSize = null;\n\t        this.dampening.dispose();\n\t        this.dampening = null;\n\t        return this;\n\t    };\n\t    return Tone.Freeverb;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  an array of the comb filter delay time values\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterDelayTimes = [\n\t        1687 / 25000,\n\t        1601 / 25000,\n\t        2053 / 25000,\n\t        2251 / 25000\n\t    ];\n\t    /**\n\t\t *  the resonances of each of the comb filters\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var combFilterResonances = [\n\t        0.773,\n\t        0.802,\n\t        0.753,\n\t        0.733\n\t    ];\n\t    /**\n\t\t *  the allpass filter frequencies\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var allpassFilterFreqs = [\n\t        347,\n\t        113,\n\t        37\n\t    ];\n\t    /**\n\t\t *  @class Tone.JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n\t\t *         tuned by John Chowning in 1970.\n\t\t *         It is made up of three allpass filters and four Tone.FeedbackCombFilter. \n\t\t *         \n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [roomSize] Coorelates to the decay time.\n\t\t *  @example\n\t\t * var reverb = new Tone.JCReverb(0.4).connect(Tone.Master);\n\t\t * var delay = new Tone.FeedbackDelay(0.5); \n\t\t * //connecting the synth to reverb through delay\n\t\t * var synth = new Tone.DuoSynth().chain(delay, reverb);\n\t\t * synth.triggerAttackRelease(\"A4\",\"8n\");\n\t\t */\n\t    Tone.JCReverb = function () {\n\t        var options = this.optionsObject(arguments, ['roomSize'], Tone.JCReverb.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  room size control values between [0,1]\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.roomSize = new Tone.Signal(options.roomSize, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  scale the room size\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scaleRoomSize = new Tone.Scale(-0.733, 0.197);\n\t        /**\n\t\t\t *  a series of allpass filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._allpassFilters = [];\n\t        /**\n\t\t\t *  parallel feedback comb filters\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackCombFilters = [];\n\t        //make the allpass filters\n\t        for (var af = 0; af < allpassFilterFreqs.length; af++) {\n\t            var allpass = this.context.createBiquadFilter();\n\t            allpass.type = 'allpass';\n\t            allpass.frequency.value = allpassFilterFreqs[af];\n\t            this._allpassFilters.push(allpass);\n\t        }\n\t        //and the comb filters\n\t        for (var cf = 0; cf < combFilterDelayTimes.length; cf++) {\n\t            var fbcf = new Tone.FeedbackCombFilter(combFilterDelayTimes[cf], 0.1);\n\t            this._scaleRoomSize.connect(fbcf.resonance);\n\t            fbcf.resonance.value = combFilterResonances[cf];\n\t            this._allpassFilters[this._allpassFilters.length - 1].connect(fbcf);\n\t            if (cf < combFilterDelayTimes.length / 2) {\n\t                fbcf.connect(this.effectReturnL);\n\t            } else {\n\t                fbcf.connect(this.effectReturnR);\n\t            }\n\t            this._feedbackCombFilters.push(fbcf);\n\t        }\n\t        //chain the allpass filters together\n\t        this.roomSize.connect(this._scaleRoomSize);\n\t        this.connectSeries.apply(this, this._allpassFilters);\n\t        this.effectSendL.connect(this._allpassFilters[0]);\n\t        this.effectSendR.connect(this._allpassFilters[0]);\n\t        this._readOnly(['roomSize']);\n\t    };\n\t    Tone.extend(Tone.JCReverb, Tone.StereoEffect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.JCReverb.defaults = { 'roomSize': 0.5 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.JCReverb} this\n\t\t */\n\t    Tone.JCReverb.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        for (var apf = 0; apf < this._allpassFilters.length; apf++) {\n\t            this._allpassFilters[apf].disconnect();\n\t            this._allpassFilters[apf] = null;\n\t        }\n\t        this._allpassFilters = null;\n\t        for (var fbcf = 0; fbcf < this._feedbackCombFilters.length; fbcf++) {\n\t            this._feedbackCombFilters[fbcf].dispose();\n\t            this._feedbackCombFilters[fbcf] = null;\n\t        }\n\t        this._feedbackCombFilters = null;\n\t        this._writable(['roomSize']);\n\t        this.roomSize.dispose();\n\t        this.roomSize = null;\n\t        this._scaleRoomSize.dispose();\n\t        this._scaleRoomSize = null;\n\t        return this;\n\t    };\n\t    return Tone.JCReverb;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Mid/Side processing separates the the 'mid' signal \n\t\t *         (which comes out of both the left and the right channel) \n\t\t *         and the 'side' (which only comes out of the the side channels) \n\t\t *         and effects them separately before being recombined.\n\t\t *         Applies a Mid/Side seperation and recombination.\n\t\t *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n\t\t *         <br><br>\n\t\t *         This is a base-class for Mid/Side Effects. \n\t\t *\n\t\t *  @extends {Tone.Effect}\n\t\t *  @constructor\n\t\t */\n\t    Tone.MidSideEffect = function () {\n\t        Tone.Effect.apply(this, arguments);\n\t        /**\n\t\t\t *  The mid/side split\n\t\t\t *  @type  {Tone.MidSideSplit}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideSplit = new Tone.MidSideSplit();\n\t        /**\n\t\t\t *  The mid/side merge\n\t\t\t *  @type  {Tone.MidSideMerge}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midSideMerge = new Tone.MidSideMerge();\n\t        /**\n\t\t\t *  The mid send. Connect to mid processing\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this.midSend = this._midSideSplit.mid;\n\t        /**\n\t\t\t *  The side send. Connect to side processing\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this.sideSend = this._midSideSplit.side;\n\t        /**\n\t\t\t *  The mid return connection\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.midReturn = this._midSideMerge.mid;\n\t        /**\n\t\t\t *  The side return connection\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this.sideReturn = this._midSideMerge.side;\n\t        //the connections\n\t        this.effectSend.connect(this._midSideSplit);\n\t        this._midSideMerge.connect(this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.MidSideEffect, Tone.Effect);\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.MidSideEffect} this\n\t\t */\n\t    Tone.MidSideEffect.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._midSideSplit.dispose();\n\t        this._midSideSplit = null;\n\t        this._midSideMerge.dispose();\n\t        this._midSideMerge = null;\n\t        this.midSend = null;\n\t        this.sideSend = null;\n\t        this.midReturn = null;\n\t        this.sideReturn = null;\n\t        return this;\n\t    };\n\t    return Tone.MidSideEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Phaser is a phaser effect. Phasers work by changing the phase\n\t\t *         of different frequency components of an incoming signal. Read more on \n\t\t *         [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)). \n\t\t *         Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n\t\t *\n\t\t *\t@extends {Tone.StereoEffect}\n\t\t *\t@constructor\n\t\t *\t@param {Frequency|Object} [frequency] The speed of the phasing. \n\t\t *\t@param {number} [octaves] The octaves of the effect. \n\t\t *\t@param {Frequency} [baseFrequency] The base frequency of the filters. \n\t\t *\t@example\n\t\t * var phaser = new Tone.Phaser({\n\t\t * \t\"frequency\" : 15, \n\t\t * \t\"octaves\" : 5, \n\t\t * \t\"baseFrequency\" : 1000\n\t\t * }).toMaster();\n\t\t * var synth = new Tone.FMSynth().connect(phaser);\n\t\t * synth.triggerAttackRelease(\"E3\", \"2n\");\n\t\t */\n\t    Tone.Phaser = function () {\n\t        //set the defaults\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'octaves',\n\t            'baseFrequency'\n\t        ], Tone.Phaser.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  the lfo which controls the frequency on the left side\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO(options.frequency, 0, 1);\n\t        /**\n\t\t\t *  the lfo which controls the frequency on the right side\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO(options.frequency, 0, 1);\n\t        this._lfoR.phase = 180;\n\t        /**\n\t\t\t *  the base modulation frequency\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._baseFrequency = options.baseFrequency;\n\t        /**\n\t\t\t *  the octaves of the phasing\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  The quality factor of the filters\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.Q = new Tone.Signal(options.Q, Tone.Type.Positive);\n\t        /**\n\t\t\t *  the array of filters for the left side\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filtersL = this._makeFilters(options.stages, this._lfoL, this.Q);\n\t        /**\n\t\t\t *  the array of filters for the left side\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filtersR = this._makeFilters(options.stages, this._lfoR, this.Q);\n\t        /**\n\t\t\t * the frequency of the effect\n\t\t\t * @type {Tone.Signal}\n\t\t\t */\n\t        this.frequency = this._lfoL.frequency;\n\t        this.frequency.value = options.frequency;\n\t        //connect them up\n\t        this.effectSendL.connect(this._filtersL[0]);\n\t        this.effectSendR.connect(this._filtersR[0]);\n\t        this._filtersL[options.stages - 1].connect(this.effectReturnL);\n\t        this._filtersR[options.stages - 1].connect(this.effectReturnR);\n\t        //control the frequency with one LFO\n\t        this._lfoL.frequency.connect(this._lfoR.frequency);\n\t        //set the options\n\t        this.baseFrequency = options.baseFrequency;\n\t        this.octaves = options.octaves;\n\t        //start the lfo\n\t        this._lfoL.start();\n\t        this._lfoR.start();\n\t        this._readOnly([\n\t            'frequency',\n\t            'Q'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Phaser, Tone.StereoEffect);\n\t    /**\n\t\t *  defaults\n\t\t *  @static\n\t\t *  @type {object}\n\t\t */\n\t    Tone.Phaser.defaults = {\n\t        'frequency': 0.5,\n\t        'octaves': 3,\n\t        'stages': 10,\n\t        'Q': 10,\n\t        'baseFrequency': 350\n\t    };\n\t    /**\n\t\t *  @param {number} stages\n\t\t *  @returns {Array} the number of filters all connected together\n\t\t *  @private\n\t\t */\n\t    Tone.Phaser.prototype._makeFilters = function (stages, connectToFreq, Q) {\n\t        var filters = new Array(stages);\n\t        //make all the filters\n\t        for (var i = 0; i < stages; i++) {\n\t            var filter = this.context.createBiquadFilter();\n\t            filter.type = 'allpass';\n\t            Q.connect(filter.Q);\n\t            connectToFreq.connect(filter.frequency);\n\t            filters[i] = filter;\n\t        }\n\t        this.connectSeries.apply(this, filters);\n\t        return filters;\n\t    };\n\t    /**\n\t\t * The number of octaves the phase goes above\n\t\t * the baseFrequency\n\t\t * @memberOf Tone.Phaser#\n\t\t * @type {Positive}\n\t\t * @name octaves\n\t\t */\n\t    Object.defineProperty(Tone.Phaser.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octaves) {\n\t            this._octaves = octaves;\n\t            var max = this._baseFrequency * Math.pow(2, octaves);\n\t            this._lfoL.max = max;\n\t            this._lfoR.max = max;\n\t        }\n\t    });\n\t    /**\n\t\t * The the base frequency of the filters. \n\t\t * @memberOf Tone.Phaser#\n\t\t * @type {number}\n\t\t * @name baseFrequency\n\t\t */\n\t    Object.defineProperty(Tone.Phaser.prototype, 'baseFrequency', {\n\t        get: function () {\n\t            return this._baseFrequency;\n\t        },\n\t        set: function (freq) {\n\t            this._baseFrequency = freq;\n\t            this._lfoL.min = freq;\n\t            this._lfoR.min = freq;\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Phaser} this\n\t\t */\n\t    Tone.Phaser.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'Q'\n\t        ]);\n\t        this.Q.dispose();\n\t        this.Q = null;\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        for (var i = 0; i < this._filtersL.length; i++) {\n\t            this._filtersL[i].disconnect();\n\t            this._filtersL[i] = null;\n\t        }\n\t        this._filtersL = null;\n\t        for (var j = 0; j < this._filtersR.length; j++) {\n\t            this._filtersR[j].disconnect();\n\t            this._filtersR[j] = null;\n\t        }\n\t        this._filtersR = null;\n\t        this.frequency = null;\n\t        return this;\n\t    };\n\t    return Tone.Phaser;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.PingPongDelay is a feedback delay effect where the echo is heard\n\t\t *          first in one channel and next in the opposite channel. In a stereo\n\t\t *          system these are the right and left channels.\n\t\t *          PingPongDelay in more simplified terms is two Tone.FeedbackDelays \n\t\t *          with independent delay values. Each delay is routed to one channel\n\t\t *          (left or right), and the channel triggered second will always \n\t\t *          trigger at the same interval after the first.\n\t\t *\n\t\t * \t@constructor\n\t\t * \t@extends {Tone.StereoXFeedbackEffect}\n\t\t *  @param {Time|Object} [delayTime] The delayTime between consecutive echos.\n\t\t *  @param {NormalRange=} feedback The amount of the effected signal which \n\t\t *                                 is fed back through the delay.\n\t\t *  @example\n\t\t * var pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toMaster();\n\t\t * var drum = new Tone.DrumSynth().connect(pingPong);\n\t\t * drum.triggerAttackRelease(\"C4\", \"32n\");\n\t\t */\n\t    Tone.PingPongDelay = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'delayTime',\n\t            'feedback'\n\t        ], Tone.PingPongDelay.defaults);\n\t        Tone.StereoXFeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  the delay node on the left side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._leftDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the delay node on the right side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rightDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the predelay on the right side\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._rightPreDelay = new Tone.Delay(0, options.maxDelayTime);\n\t        /**\n\t\t\t *  the delay time signal\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = new Tone.Signal(options.delayTime, Tone.Type.Time);\n\t        //connect it up\n\t        this.effectSendL.chain(this._leftDelay, this.effectReturnL);\n\t        this.effectSendR.chain(this._rightPreDelay, this._rightDelay, this.effectReturnR);\n\t        this.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n\t        //rearranged the feedback to be after the rightPreDelay\n\t        this._feedbackLR.disconnect();\n\t        this._feedbackLR.connect(this._rightDelay);\n\t        this._readOnly(['delayTime']);\n\t    };\n\t    Tone.extend(Tone.PingPongDelay, Tone.StereoXFeedbackEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PingPongDelay.defaults = {\n\t        'delayTime': 0.25,\n\t        'maxDelayTime': 1\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.PingPongDelay} this\n\t\t */\n\t    Tone.PingPongDelay.prototype.dispose = function () {\n\t        Tone.StereoXFeedbackEffect.prototype.dispose.call(this);\n\t        this._leftDelay.dispose();\n\t        this._leftDelay = null;\n\t        this._rightDelay.dispose();\n\t        this._rightDelay = null;\n\t        this._rightPreDelay.dispose();\n\t        this._rightPreDelay = null;\n\t        this._writable(['delayTime']);\n\t        this.delayTime.dispose();\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.PingPongDelay;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PitchShift does near-realtime pitch shifting to the incoming signal. \n\t\t *         The effect is achieved by speeding up or slowing down the delayTime\n\t\t *         of a DelayNode using a sawtooth wave. \n\t\t *         Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n\t\t *         Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n\t\t *         \n\t\t *  @extends {Tone.FeedbackEffect}\n\t\t *  @param {Interval=} pitch The interval to transpose the incoming signal by. \n\t\t */\n\t    Tone.PitchShift = function () {\n\t        var options = this.optionsObject(arguments, ['pitch'], Tone.PitchShift.defaults);\n\t        Tone.FeedbackEffect.call(this, options);\n\t        /**\n\t\t\t *  The pitch signal\n\t\t\t *  @type  {Tone.Signal}\n\t\t\t *  @private\n\t\t\t */\n\t        this._frequency = new Tone.Signal(0);\n\t        /**\n\t\t\t *  Uses two DelayNodes to cover up the jump in\n\t\t\t *  the sawtooth wave. \n\t\t\t *  @type  {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayA = new Tone.Delay(0, 1);\n\t        /**\n\t\t\t *  The first LFO.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoA = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 0.1,\n\t            'type': 'sawtooth'\n\t        }).connect(this._delayA.delayTime);\n\t        /**\n\t\t\t *  The second DelayNode\n\t\t\t *  @type  {DelayNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayB = new Tone.Delay(0, 1);\n\t        /**\n\t\t\t *  The first LFO.\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoB = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 0.1,\n\t            'type': 'sawtooth',\n\t            'phase': 180\n\t        }).connect(this._delayB.delayTime);\n\t        /**\n\t\t\t *  Crossfade quickly between the two delay lines\n\t\t\t *  to cover up the jump in the sawtooth wave\n\t\t\t *  @type  {Tone.CrossFade}\n\t\t\t *  @private\n\t\t\t */\n\t        this._crossFade = new Tone.CrossFade();\n\t        /**\n\t\t\t *  LFO which alternates between the two\n\t\t\t *  delay lines to cover up the disparity in the\n\t\t\t *  sawtooth wave. \n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._crossFadeLFO = new Tone.LFO({\n\t            'min': 0,\n\t            'max': 1,\n\t            'type': 'triangle',\n\t            'phase': 90\n\t        }).connect(this._crossFade.fade);\n\t        /**\n\t\t\t *  The delay node\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackDelay = new Tone.Delay(options.delayTime);\n\t        /**\n\t\t\t *  The amount of delay on the input signal\n\t\t\t *  @type {Time}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.delayTime = this._feedbackDelay.delayTime;\n\t        this._readOnly('delayTime');\n\t        /**\n\t\t\t *  Hold the current pitch\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pitch = options.pitch;\n\t        /**\n\t\t\t *  Hold the current windowSize\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._windowSize = options.windowSize;\n\t        //connect the two delay lines up\n\t        this._delayA.connect(this._crossFade.a);\n\t        this._delayB.connect(this._crossFade.b);\n\t        //connect the frequency\n\t        this._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);\n\t        //route the input\n\t        this.effectSend.fan(this._delayA, this._delayB);\n\t        this._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t        //start the LFOs at the same time\n\t        var now = this.now();\n\t        this._lfoA.start(now);\n\t        this._lfoB.start(now);\n\t        this._crossFadeLFO.start(now);\n\t        //set the initial value\n\t        this.windowSize = this._windowSize;\n\t    };\n\t    Tone.extend(Tone.PitchShift, Tone.FeedbackEffect);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.PitchShift.defaults = {\n\t        'pitch': 0,\n\t        'windowSize': 0.1,\n\t        'delayTime': 0,\n\t        'feedback': 0\n\t    };\n\t    /**\n\t\t * Repitch the incoming signal by some interval (measured\n\t\t * in semi-tones). \n\t\t * @memberOf Tone.PitchShift#\n\t\t * @type {Interval}\n\t\t * @name pitch\n\t\t * @example\n\t\t * pitchShift.pitch = -12; //down one octave\n\t\t * pitchShift.pitch = 7; //up a fifth\n\t\t */\n\t    Object.defineProperty(Tone.PitchShift.prototype, 'pitch', {\n\t        get: function () {\n\t            return this._pitch;\n\t        },\n\t        set: function (interval) {\n\t            this._pitch = interval;\n\t            var factor = 0;\n\t            if (interval < 0) {\n\t                this._lfoA.min = 0;\n\t                this._lfoA.max = this._windowSize;\n\t                this._lfoB.min = 0;\n\t                this._lfoB.max = this._windowSize;\n\t                factor = this.intervalToFrequencyRatio(interval - 1) + 1;\n\t            } else {\n\t                this._lfoA.min = this._windowSize;\n\t                this._lfoA.max = 0;\n\t                this._lfoB.min = this._windowSize;\n\t                this._lfoB.max = 0;\n\t                factor = this.intervalToFrequencyRatio(interval) - 1;\n\t            }\n\t            this._frequency.value = factor * (1.2 / this._windowSize);\n\t        }\n\t    });\n\t    /**\n\t\t * The window size corresponds roughly to the sample length in a looping sampler. \n\t\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t\t * signal, but larger values will result in smoother pitch shifting for larger intervals. \n\t\t * A nominal range of 0.03 to 0.1 is recommended. \n\t\t * @memberOf Tone.PitchShift#\n\t\t * @type {Time}\n\t\t * @name windowSize\n\t\t * @example\n\t\t * pitchShift.windowSize = 0.1;\n\t\t */\n\t    Object.defineProperty(Tone.PitchShift.prototype, 'windowSize', {\n\t        get: function () {\n\t            return this._windowSize;\n\t        },\n\t        set: function (size) {\n\t            this._windowSize = this.toSeconds(size);\n\t            this.pitch = this._pitch;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.PitchShift}  this\n\t\t */\n\t    Tone.PitchShift.prototype.dispose = function () {\n\t        Tone.FeedbackEffect.prototype.dispose.call(this);\n\t        this._frequency.dispose();\n\t        this._frequency = null;\n\t        this._delayA.disconnect();\n\t        this._delayA = null;\n\t        this._delayB.disconnect();\n\t        this._delayB = null;\n\t        this._lfoA.dispose();\n\t        this._lfoA = null;\n\t        this._lfoB.dispose();\n\t        this._lfoB = null;\n\t        this._crossFade.dispose();\n\t        this._crossFade = null;\n\t        this._crossFadeLFO.dispose();\n\t        this._crossFadeLFO = null;\n\t        this._writable('delayTime');\n\t        this._feedbackDelay.dispose();\n\t        this._feedbackDelay = null;\n\t        this.delayTime = null;\n\t        return this;\n\t    };\n\t    return Tone.PitchShift;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Base class for stereo feedback effects where the effectReturn\n\t\t *         is fed back into the same channel. \n\t\t *\n\t\t *\t@constructor\n\t\t *\t@extends {Tone.FeedbackEffect}\n\t\t */\n\t    Tone.StereoFeedbackEffect = function () {\n\t        var options = this.optionsObject(arguments, ['feedback'], Tone.FeedbackEffect.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  controls the amount of feedback\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.feedback = new Tone.Signal(options.feedback, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  the left side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackL = new Tone.Gain();\n\t        /**\n\t\t\t *  the right side feeback\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._feedbackR = new Tone.Gain();\n\t        //connect it up\n\t        this.effectReturnL.chain(this._feedbackL, this.effectSendL);\n\t        this.effectReturnR.chain(this._feedbackR, this.effectSendR);\n\t        this.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t        this._readOnly(['feedback']);\n\t    };\n\t    Tone.extend(Tone.StereoFeedbackEffect, Tone.FeedbackEffect);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.StereoFeedbackEffect} this\n\t\t */\n\t    Tone.StereoFeedbackEffect.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable(['feedback']);\n\t        this.feedback.dispose();\n\t        this.feedback = null;\n\t        this._feedbackL.dispose();\n\t        this._feedbackL = null;\n\t        this._feedbackR.dispose();\n\t        this._feedbackR = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoFeedbackEffect;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Applies a width factor to the mid/side seperation. \n\t\t *         0 is all mid and 1 is all side.\n\t\t *         Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n\t\t *         <br><br>\n\t\t *         <code>\n\t\t *         Mid *= 2*(1-width)<br>\n\t\t *         Side *= 2*width\n\t\t *         </code>\n\t\t *\n\t\t *  @extends {Tone.MidSideEffect}\n\t\t *  @constructor\n\t\t *  @param {NormalRange|Object} [width] The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t\t */\n\t    Tone.StereoWidener = function () {\n\t        var options = this.optionsObject(arguments, ['width'], Tone.StereoWidener.defaults);\n\t        Tone.MidSideEffect.call(this, options);\n\t        /**\n\t\t\t *  The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  Mid multiplier\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._midMult = new Tone.Expr('$0 * ($1 * (1 - $2))');\n\t        /**\n\t\t\t *  Side multiplier\n\t\t\t *  @type {Tone.Expr}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sideMult = new Tone.Expr('$0 * ($1 * $2)');\n\t        /**\n\t\t\t *  constant output of 2\n\t\t\t *  @type {Tone}\n\t\t\t *  @private\n\t\t\t */\n\t        this._two = new Tone.Signal(2);\n\t        //the mid chain\n\t        this._two.connect(this._midMult, 0, 1);\n\t        this.width.connect(this._midMult, 0, 2);\n\t        //the side chain\n\t        this._two.connect(this._sideMult, 0, 1);\n\t        this.width.connect(this._sideMult, 0, 2);\n\t        //connect it to the effect send/return\n\t        this.midSend.chain(this._midMult, this.midReturn);\n\t        this.sideSend.chain(this._sideMult, this.sideReturn);\n\t        this._readOnly(['width']);\n\t    };\n\t    Tone.extend(Tone.StereoWidener, Tone.MidSideEffect);\n\t    /**\n\t\t *  the default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.StereoWidener.defaults = { 'width': 0.5 };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.StereoWidener} this\n\t\t */\n\t    Tone.StereoWidener.prototype.dispose = function () {\n\t        Tone.MidSideEffect.prototype.dispose.call(this);\n\t        this._writable(['width']);\n\t        this.width.dispose();\n\t        this.width = null;\n\t        this._midMult.dispose();\n\t        this._midMult = null;\n\t        this._sideMult.dispose();\n\t        this._sideMult = null;\n\t        this._two.dispose();\n\t        this._two = null;\n\t        return this;\n\t    };\n\t    return Tone.StereoWidener;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Tremolo modulates the amplitude of an incoming signal using a Tone.LFO.\n\t\t *         The type, frequency, and depth of the LFO is controllable.\n\t\t *\n\t\t *  @extends {Tone.StereoEffect}\n\t\t *  @constructor\n\t\t *  @param {Frequency} [frequency] The rate of the effect.\n\t\t *  @param {NormalRange} [depth] The depth of the effect.\n\t\t *  @example\n\t\t * //create a tremolo and start it's LFO\n\t\t * var tremolo = new Tone.Tremolo(9, 0.75).toMaster().start();\n\t\t * //route an oscillator through the tremolo and start it\n\t\t * var oscillator = new Tone.Oscillator().connect(tremolo).start();\n\t\t */\n\t    Tone.Tremolo = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'depth'\n\t        ], Tone.Tremolo.defaults);\n\t        Tone.StereoEffect.call(this, options);\n\t        /**\n\t\t\t *  The tremelo LFO in the left channel\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoL = new Tone.LFO({\n\t            'phase': options.spread,\n\t            'min': 1,\n\t            'max': 0\n\t        });\n\t        /**\n\t\t\t *  The tremelo LFO in the left channel\n\t\t\t *  @type  {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfoR = new Tone.LFO({\n\t            'phase': options.spread,\n\t            'min': 1,\n\t            'max': 0\n\t        });\n\t        /**\n\t\t\t *  Where the gain is multiplied\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitudeL = new Tone.Gain();\n\t        /**\n\t\t\t *  Where the gain is multiplied\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitudeR = new Tone.Gain();\n\t        /**\n\t\t\t *  The frequency of the tremolo.\n\t\t\t *  @type  {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The depth of the effect. A depth of 0, has no effect\n\t\t\t *  on the amplitude, and a depth of 1 makes the amplitude\n\t\t\t *  modulate fully between 0 and 1.\n\t\t\t *  @type  {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.depth = new Tone.Signal(options.depth, Tone.Type.NormalRange);\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.effectSendL.chain(this._amplitudeL, this.effectReturnL);\n\t        this.effectSendR.chain(this._amplitudeR, this.effectReturnR);\n\t        this._lfoL.connect(this._amplitudeL.gain);\n\t        this._lfoR.connect(this._amplitudeR.gain);\n\t        this.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t        this.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t        this.type = options.type;\n\t        this.spread = options.spread;\n\t    };\n\t    Tone.extend(Tone.Tremolo, Tone.StereoEffect);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Tremolo.defaults = {\n\t        'frequency': 10,\n\t        'type': 'sine',\n\t        'depth': 0.5,\n\t        'spread': 180\n\t    };\n\t    /**\n\t\t * Start the tremolo.\n\t\t * @param {Time} [time=now] When the tremolo begins.\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.start = function (time) {\n\t        this._lfoL.start(time);\n\t        this._lfoR.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Stop the tremolo.\n\t\t * @param {Time} [time=now] When the tremolo stops.\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.stop = function (time) {\n\t        this._lfoL.stop(time);\n\t        this._lfoR.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Sync the effect to the transport.\n\t\t * @param {Time} [delay=0] Delay time before starting the effect after the\n\t\t *                              Transport has started.\n\t\t * @returns {Tone.AutoFilter} this\n\t\t */\n\t    Tone.Tremolo.prototype.sync = function (delay) {\n\t        this._lfoL.sync(delay);\n\t        this._lfoR.sync(delay);\n\t        return this;\n\t    };\n\t    /**\n\t\t * Unsync the filter from the transport\n\t\t * @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.unsync = function () {\n\t        this._lfoL.unsync();\n\t        this._lfoR.unsync();\n\t        return this;\n\t    };\n\t    /**\n\t\t * The Tremolo's oscillator type.\n\t\t * @memberOf Tone.Tremolo#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Tremolo.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfoL.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfoL.type = type;\n\t            this._lfoR.type = type;\n\t        }\n\t    });\n\t    /** \n\t\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t\t * @memberOf Tone.Tremolo#\n\t\t * @type {Degrees}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.Tremolo.prototype, 'spread', {\n\t        get: function () {\n\t            return this._lfoR.phase - this._lfoL.phase;    //180\n\t        },\n\t        set: function (spread) {\n\t            this._lfoL.phase = 90 - spread / 2;\n\t            this._lfoR.phase = spread / 2 + 90;\n\t        }\n\t    });\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Tremolo} this\n\t\t */\n\t    Tone.Tremolo.prototype.dispose = function () {\n\t        Tone.StereoEffect.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this._lfoL.dispose();\n\t        this._lfoL = null;\n\t        this._lfoR.dispose();\n\t        this._lfoR = null;\n\t        this._amplitudeL.dispose();\n\t        this._amplitudeL = null;\n\t        this._amplitudeR.dispose();\n\t        this._amplitudeR = null;\n\t        this.frequency = null;\n\t        this.depth = null;\n\t        return this;\n\t    };\n\t    return Tone.Tremolo;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n\t\t *         modulates the delayTime of the delay, causing the pitch to rise\n\t\t *         and fall. \n\t\t *  @extends {Tone.Effect}\n\t\t *  @param {Frequency} frequency The frequency of the vibrato.\n\t\t *  @param {NormalRange} depth The amount the pitch is modulated.\n\t\t */\n\t    Tone.Vibrato = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'depth'\n\t        ], Tone.Vibrato.defaults);\n\t        Tone.Effect.call(this, options);\n\t        /**\n\t\t\t *  The delay node used for the vibrato effect\n\t\t\t *  @type {Tone.Delay}\n\t\t\t *  @private\n\t\t\t */\n\t        this._delayNode = new Tone.Delay(0, options.maxDelay);\n\t        /**\n\t\t\t *  The LFO used to control the vibrato\n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfo = new Tone.LFO({\n\t            'type': options.type,\n\t            'min': 0,\n\t            'max': options.maxDelay,\n\t            'frequency': options.frequency,\n\t            'phase': -90    //offse the phase so the resting position is in the center\n\t        }).start().connect(this._delayNode.delayTime);\n\t        /**\n\t\t\t *  The frequency of the vibrato\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._lfo.frequency;\n\t        /**\n\t\t\t *  The depth of the vibrato. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.depth = this._lfo.amplitude;\n\t        this.depth.value = options.depth;\n\t        this._readOnly([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.effectSend.chain(this._delayNode, this.effectReturn);\n\t    };\n\t    Tone.extend(Tone.Vibrato, Tone.Effect);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Vibrato.defaults = {\n\t        'maxDelay': 0.005,\n\t        'frequency': 5,\n\t        'depth': 0.1,\n\t        'type': 'sine'\n\t    };\n\t    /**\n\t\t * Type of oscillator attached to the Vibrato.\n\t\t * @memberOf Tone.Vibrato#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.Vibrato.prototype, 'type', {\n\t        get: function () {\n\t            return this._lfo.type;\n\t        },\n\t        set: function (type) {\n\t            this._lfo.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Vibrato} this\n\t\t */\n\t    Tone.Vibrato.prototype.dispose = function () {\n\t        Tone.Effect.prototype.dispose.call(this);\n\t        this._delayNode.dispose();\n\t        this._delayNode = null;\n\t        this._lfo.dispose();\n\t        this._lfo = null;\n\t        this._writable([\n\t            'frequency',\n\t            'depth'\n\t        ]);\n\t        this.frequency = null;\n\t        this.depth = null;\n\t    };\n\t    return Tone.Vibrato;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Event abstracts away Tone.Transport.schedule and provides a schedulable\n\t\t *          callback for a single or repeatable events along the timeline. \n\t\t *\n\t\t *  @extends {Tone}\n\t\t *  @param {function} callback The callback to invoke at the time. \n\t\t *  @param {*} value The value or values which should be passed to\n\t\t *                      the callback function on invocation.  \n\t\t *  @example\n\t\t * var chord = new Tone.Event(function(time, chord){\n\t\t * \t//the chord as well as the exact time of the event\n\t\t * \t//are passed in as arguments to the callback function\n\t\t * }, [\"D4\", \"E4\", \"F4\"]);\n\t\t * //start the chord at the beginning of the transport timeline\n\t\t * chord.start();\n\t\t * //loop it every measure for 8 measures\n\t\t * chord.loop = 8;\n\t\t * chord.loopEnd = \"1m\";\n\t\t */\n\t    Tone.Event = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'value'\n\t        ], Tone.Event.defaults);\n\t        /**\n\t\t\t *  Loop value\n\t\t\t *  @type  {Boolean|Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  The callback to invoke. \n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  The value which is passed to the\n\t\t\t *  callback function.\n\t\t\t *  @type  {*}\n\t\t\t *  @private\n\t\t\t */\n\t        this.value = options.value;\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = this.toTicks(options.loopStart);\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = this.toTicks(options.loopEnd);\n\t        /**\n\t\t\t *  Tracks the scheduled events\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  The playback speed of the note. A speed of 1\n\t\t\t *  is no change. \n\t\t\t *  @private\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this._playbackRate = 1;\n\t        /**\n\t\t\t *  A delay time from when the event is scheduled to start\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startOffset = 0;\n\t        /**\n\t\t\t *  The probability that the callback will be invoked\n\t\t\t *  at the scheduled time. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @example\n\t\t\t * //the callback will be invoked 50% of the time\n\t\t\t * event.probability = 0.5;\n\t\t\t */\n\t        this.probability = options.probability;\n\t        /**\n\t\t\t *  If set to true, will apply small (+/-0.02 seconds) random variation\n\t\t\t *  to the callback time. If the value is given as a time, it will randomize\n\t\t\t *  by that amount.\n\t\t\t *  @example\n\t\t\t * event.humanize = true;\n\t\t\t *  @type {Boolean|Time}\n\t\t\t */\n\t        this.humanize = options.humanize;\n\t        /**\n\t\t\t *  If mute is true, the callback won't be\n\t\t\t *  invoked.\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.mute = options.mute;\n\t        //set the initial values\n\t        this.playbackRate = options.playbackRate;\n\t    };\n\t    Tone.extend(Tone.Event);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Event.defaults = {\n\t        'callback': Tone.noOp,\n\t        'loop': false,\n\t        'loopEnd': '1m',\n\t        'loopStart': 0,\n\t        'playbackRate': 1,\n\t        'value': null,\n\t        'probability': 1,\n\t        'mute': false,\n\t        'humanize': false\n\t    };\n\t    /**\n\t\t *  Reschedule all of the events along the timeline\n\t\t *  with the updated values.\n\t\t *  @param {Time} after Only reschedules events after the given time.\n\t\t *  @return  {Tone.Event}  this\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._rescheduleEvents = function (after) {\n\t        //if no argument is given, schedules all of the events\n\t        after = this.defaultArg(after, -1);\n\t        this._state.forEachFrom(after, function (event) {\n\t            var duration;\n\t            if (event.state === Tone.State.Started) {\n\t                if (!this.isUndef(event.id)) {\n\t                    Tone.Transport.clear(event.id);\n\t                }\n\t                var startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t                if (this._loop) {\n\t                    duration = Infinity;\n\t                    if (this.isNumber(this._loop)) {\n\t                        duration = this._loop * this._getLoopDuration();\n\t                    }\n\t                    var nextEvent = this._state.getAfter(startTick);\n\t                    if (nextEvent !== null) {\n\t                        duration = Math.min(duration, nextEvent.time - startTick);\n\t                    }\n\t                    if (duration !== Infinity) {\n\t                        //schedule a stop since it's finite duration\n\t                        this._state.setStateAtTime(Tone.State.Stopped, startTick + duration + 1);\n\t                        duration = Tone.Time(duration, 'i');\n\t                    }\n\t                    var interval = Tone.Time(this._getLoopDuration(), 'i');\n\t                    event.id = Tone.Transport.scheduleRepeat(this._tick.bind(this), interval, Tone.TransportTime(startTick, 'i'), duration);\n\t                } else {\n\t                    event.id = Tone.Transport.schedule(this._tick.bind(this), startTick + 'i');\n\t                }\n\t            }\n\t        }.bind(this));\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the note, either \"started\" or \"stopped\".\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.Event#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'state', {\n\t        get: function () {\n\t            return this._state.getValueAtTime(Tone.Transport.ticks);\n\t        }\n\t    });\n\t    /**\n\t\t *  The start from the scheduled start time\n\t\t *  @type {Ticks}\n\t\t *  @memberOf Tone.Event#\n\t\t *  @name startOffset\n\t\t *  @private\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'startOffset', {\n\t        get: function () {\n\t            return this._startOffset;\n\t        },\n\t        set: function (offset) {\n\t            this._startOffset = offset;\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the note at the given time. \n\t\t *  @param  {TimelinePosition}  time  When the note should start.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.start = function (time) {\n\t        time = this.toTicks(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Stopped) {\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': time,\n\t                'id': undefined\n\t            });\n\t            this._rescheduleEvents(time);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the Event at the given time.\n\t\t *  @param  {TimelinePosition}  time  When the note should stop.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.stop = function (time) {\n\t        this.cancel(time);\n\t        time = this.toTicks(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            this._state.setStateAtTime(Tone.State.Stopped, time);\n\t            var previousEvent = this._state.getBefore(time);\n\t            var reschedulTime = time;\n\t            if (previousEvent !== null) {\n\t                reschedulTime = previousEvent.time;\n\t            }\n\t            this._rescheduleEvents(reschedulTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel all scheduled events greater than or equal to the given time\n\t\t *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.cancel = function (time) {\n\t        time = this.defaultArg(time, -Infinity);\n\t        time = this.toTicks(time);\n\t        this._state.forEachFrom(time, function (event) {\n\t            Tone.Transport.clear(event.id);\n\t        });\n\t        this._state.cancel(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The callback function invoker. Also \n\t\t *  checks if the Event is done playing\n\t\t *  @param  {Number}  time  The time of the event in seconds\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._tick = function (time) {\n\t        if (!this.mute && this._state.getValueAtTime(Tone.Transport.ticks) === Tone.State.Started) {\n\t            if (this.probability < 1 && Math.random() > this.probability) {\n\t                return;\n\t            }\n\t            if (this.humanize) {\n\t                var variation = 0.02;\n\t                if (!this.isBoolean(this.humanize)) {\n\t                    variation = this.toSeconds(this.humanize);\n\t                }\n\t                time += (Math.random() * 2 - 1) * variation;\n\t            }\n\t            this.callback(time, this.value);\n\t        }\n\t    };\n\t    /**\n\t\t *  Get the duration of the loop.\n\t\t *  @return  {Ticks}\n\t\t *  @private\n\t\t */\n\t    Tone.Event.prototype._getLoopDuration = function () {\n\t        return Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t    };\n\t    /**\n\t\t *  If the note should loop or not\n\t\t *  between Tone.Event.loopStart and \n\t\t *  Tone.Event.loopEnd. An integer\n\t\t *  value corresponds to the number of\n\t\t *  loops the Event does after it starts.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {Boolean|Positive}\n\t\t *  @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            this._rescheduleEvents();\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe playback rate of the note. Defaults to 1.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {Positive}\n\t\t *  @name playbackRate\n\t\t *  @example\n\t\t * note.loop = true;\n\t\t * //repeat the note twice as fast\n\t\t * note.playbackRate = 2;\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this._rescheduleEvents();\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopEnd point is the time the event will loop\n\t\t *  if Tone.Event.loop is true.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toNotation();\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = this.toTicks(loopEnd);\n\t            if (this._loop) {\n\t                this._rescheduleEvents();\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The time when the loop should start. \n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toNotation();\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = this.toTicks(loopStart);\n\t            if (this._loop) {\n\t                this._rescheduleEvents();\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The current progress of the loop interval.\n\t\t *  Returns 0 if the event is not started yet or\n\t\t *  it is not set to loop.\n\t\t *  @memberOf Tone.Event#\n\t\t *  @type {NormalRange}\n\t\t *  @name progress\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Event.prototype, 'progress', {\n\t        get: function () {\n\t            if (this._loop) {\n\t                var ticks = Tone.Transport.ticks;\n\t                var lastEvent = this._state.get(ticks);\n\t                if (lastEvent !== null && lastEvent.state === Tone.State.Started) {\n\t                    var loopDuration = this._getLoopDuration();\n\t                    var progress = (ticks - lastEvent.time) % loopDuration;\n\t                    return progress / loopDuration;\n\t                } else {\n\t                    return 0;\n\t                }\n\t            } else {\n\t                return 0;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Event}  this\n\t\t */\n\t    Tone.Event.prototype.dispose = function () {\n\t        this.cancel();\n\t        this._state.dispose();\n\t        this._state = null;\n\t        this.callback = null;\n\t        this.value = null;\n\t    };\n\t    return Tone.Event;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Loop creates a looped callback at the \n\t\t *         specified interval. The callback can be \n\t\t *         started, stopped and scheduled along\n\t\t *         the Transport's timeline. \n\t\t *  @example\n\t\t * var loop = new Tone.Loop(function(time){\n\t\t * \t//triggered every eighth note. \n\t\t * \tconsole.log(time);\n\t\t * }, \"8n\").start(0);\n\t\t * Tone.Transport.start();\n\t\t *  @extends {Tone}\n\t\t *  @param {Function} callback The callback to invoke with the event.\n\t\t *  @param {Time} interval The time between successive callback calls. \n\t\t */\n\t    Tone.Loop = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'interval'\n\t        ], Tone.Loop.defaults);\n\t        /**\n\t\t\t *  The event which produces the callbacks\n\t\t\t */\n\t        this._event = new Tone.Event({\n\t            'callback': this._tick.bind(this),\n\t            'loop': true,\n\t            'loopEnd': options.interval,\n\t            'playbackRate': options.playbackRate,\n\t            'probability': options.probability\n\t        });\n\t        /**\n\t\t\t *  The callback to invoke with the next event in the pattern\n\t\t\t *  @type {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        //set the iterations\n\t        this.iterations = options.iterations;\n\t    };\n\t    Tone.extend(Tone.Loop);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Loop.defaults = {\n\t        'interval': '4n',\n\t        'callback': Tone.noOp,\n\t        'playbackRate': 1,\n\t        'iterations': Infinity,\n\t        'probability': true,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Start the loop at the specified time along the Transport's\n\t\t *  timeline.\n\t\t *  @param  {TimelinePosition=}  time  When to start the Loop.\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.start = function (time) {\n\t        this._event.start(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the loop at the given time.\n\t\t *  @param  {TimelinePosition=}  time  When to stop the Arpeggio\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.stop = function (time) {\n\t        this._event.stop(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel all scheduled events greater than or equal to the given time\n\t\t *  @param  {TimelinePosition}  [time=0]  The time after which events will be cancel.\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.cancel = function (time) {\n\t        this._event.cancel(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Internal function called when the notes should be called\n\t\t *  @param  {Number}  time  The time the event occurs\n\t\t *  @private\n\t\t */\n\t    Tone.Loop.prototype._tick = function (time) {\n\t        this.callback(time);\n\t    };\n\t    /**\n\t\t *  The state of the Loop, either started or stopped.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {String}\n\t\t *  @name state\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'state', {\n\t        get: function () {\n\t            return this._event.state;\n\t        }\n\t    });\n\t    /**\n\t\t *  The progress of the loop as a value between 0-1. 0, when\n\t\t *  the loop is stopped or done iterating. \n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {NormalRange}\n\t\t *  @name progress\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'progress', {\n\t        get: function () {\n\t            return this._event.progress;\n\t        }\n\t    });\n\t    /**\n\t\t *  The time between successive callbacks. \n\t\t *  @example\n\t\t * loop.interval = \"8n\"; //loop every 8n\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Time}\n\t\t *  @name interval\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'interval', {\n\t        get: function () {\n\t            return this._event.loopEnd;\n\t        },\n\t        set: function (interval) {\n\t            this._event.loopEnd = interval;\n\t        }\n\t    });\n\t    /**\n\t\t *  The playback rate of the loop. The normal playback rate is 1 (no change). \n\t\t *  A `playbackRate` of 2 would be twice as fast. \n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Time}\n\t\t *  @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._event.playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._event.playbackRate = rate;\n\t        }\n\t    });\n\t    /**\n\t\t *  Random variation +/-0.01s to the scheduled time. \n\t\t *  Or give it a time value which it will randomize by.\n\t\t *  @type {Boolean|Time}\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @name humanize\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'humanize', {\n\t        get: function () {\n\t            return this._event.humanize;\n\t        },\n\t        set: function (variation) {\n\t            this._event.humanize = variation;\n\t        }\n\t    });\n\t    /**\n\t\t *  The probably of the callback being invoked.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {NormalRange}\n\t\t *  @name probability\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'probability', {\n\t        get: function () {\n\t            return this._event.probability;\n\t        },\n\t        set: function (prob) {\n\t            this._event.probability = prob;\n\t        }\n\t    });\n\t    /**\n\t\t *  Muting the Loop means that no callbacks are invoked.\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Boolean}\n\t\t *  @name mute\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'mute', {\n\t        get: function () {\n\t            return this._event.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._event.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of iterations of the loop. The default\n\t\t *  value is Infinity (loop forever).\n\t\t *  @memberOf Tone.Loop#\n\t\t *  @type {Positive}\n\t\t *  @name iterations\n\t\t */\n\t    Object.defineProperty(Tone.Loop.prototype, 'iterations', {\n\t        get: function () {\n\t            if (this._event.loop === true) {\n\t                return Infinity;\n\t            } else {\n\t                return this._event.loop;\n\t            }\n\t            return this._pattern.index;\n\t        },\n\t        set: function (iters) {\n\t            if (iters === Infinity) {\n\t                this._event.loop = true;\n\t            } else {\n\t                this._event.loop = iters;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Loop}  this\n\t\t */\n\t    Tone.Loop.prototype.dispose = function () {\n\t        this._event.dispose();\n\t        this._event = null;\n\t        this.callback = null;\n\t    };\n\t    return Tone.Loop;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.Part is a collection Tone.Events which can be\n\t\t *         started/stoped and looped as a single unit.\n\t\t *\n\t\t *  @extends {Tone.Event}\n\t\t *  @param {Function} callback The callback to invoke on each event\n\t\t *  @param {Array} events the array of events\n\t\t *  @example\n\t\t * var part = new Tone.Part(function(time, note){\n\t\t * \t//the notes given as the second element in the array\n\t\t * \t//will be passed in as the second argument\n\t\t * \tsynth.triggerAttackRelease(note, \"8n\", time);\n\t\t * }, [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n\t\t *  @example\n\t\t * //use an array of objects as long as the object has a \"time\" attribute\n\t\t * var part = new Tone.Part(function(time, value){\n\t\t * \t//the value is an object which contains both the note and the velocity\n\t\t * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n\t\t * }, [{\"time\" : 0, \"note\" : \"C3\", \"velocity\": 0.9}, \n\t\t * \t   {\"time\" : \"0:2\", \"note\" : \"C4\", \"velocity\": 0.5}\n\t\t * ]).start(0);\n\t\t */\n\t    Tone.Part = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'events'\n\t        ], Tone.Part.defaults);\n\t        /**\n\t\t\t *  If the part is looping or not\n\t\t\t *  @type  {Boolean|Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = this.toTicks(options.loopStart);\n\t        /**\n\t\t\t *  When the note is scheduled to start.\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = this.toTicks(options.loopEnd);\n\t        /**\n\t\t\t *  The playback rate of the part\n\t\t\t *  @type  {Positive}\n\t\t\t *  @private\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  private holder of probability value\n\t\t\t *  @type {NormalRange}\n\t\t\t *  @private\n\t\t\t */\n\t        this._probability = options.probability;\n\t        /**\n\t\t\t *  the amount of variation from the\n\t\t\t *  given time. \n\t\t\t *  @type {Boolean|Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._humanize = options.humanize;\n\t        /**\n\t\t\t *  The start offset\n\t\t\t *  @type {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startOffset = 0;\n\t        /**\n\t\t\t *  Keeps track of the current state\n\t\t\t *  @type {Tone.TimelineState}\n\t\t\t *  @private\n\t\t\t */\n\t        this._state = new Tone.TimelineState(Tone.State.Stopped);\n\t        /**\n\t\t\t *  An array of Objects. \n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._events = [];\n\t        /**\n\t\t\t *  The callback to invoke at all the scheduled events.\n\t\t\t *  @type {Function}\n\t\t\t */\n\t        this.callback = options.callback;\n\t        /**\n\t\t\t *  If mute is true, the callback won't be\n\t\t\t *  invoked.\n\t\t\t *  @type {Boolean}\n\t\t\t */\n\t        this.mute = options.mute;\n\t        //add the events\n\t        var events = this.defaultArg(options.events, []);\n\t        if (!this.isUndef(options.events)) {\n\t            for (var i = 0; i < events.length; i++) {\n\t                if (Array.isArray(events[i])) {\n\t                    this.add(events[i][0], events[i][1]);\n\t                } else {\n\t                    this.add(events[i]);\n\t                }\n\t            }\n\t        }\n\t    };\n\t    Tone.extend(Tone.Part, Tone.Event);\n\t    /**\n\t\t *  The default values\n\t\t *  @type  {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.Part.defaults = {\n\t        'callback': Tone.noOp,\n\t        'loop': false,\n\t        'loopEnd': '1m',\n\t        'loopStart': 0,\n\t        'playbackRate': 1,\n\t        'probability': 1,\n\t        'humanize': false,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Start the part at the given time. \n\t\t *  @param  {TransportTime}  time    When to start the part.\n\t\t *  @param  {Time=}  offset  The offset from the start of the part\n\t\t *                           to begin playing at.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.start = function (time, offset) {\n\t        var ticks = this.toTicks(time);\n\t        if (this._state.getValueAtTime(ticks) !== Tone.State.Started) {\n\t            if (this._loop) {\n\t                offset = this.defaultArg(offset, this._loopStart);\n\t            } else {\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toTicks(offset);\n\t            this._state.add({\n\t                'state': Tone.State.Started,\n\t                'time': ticks,\n\t                'offset': offset\n\t            });\n\t            this._forEach(function (event) {\n\t                this._startNote(event, ticks, offset);\n\t            });\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the event in the given event at the correct time given\n\t\t *  the ticks and offset and looping.\n\t\t *  @param  {Tone.Event}  event \n\t\t *  @param  {Ticks}  ticks\n\t\t *  @param  {Ticks}  offset\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._startNote = function (event, ticks, offset) {\n\t        ticks -= offset;\n\t        if (this._loop) {\n\t            if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t                if (event.startOffset < offset) {\n\t                    //start it on the next loop\n\t                    ticks += this._getLoopDuration();\n\t                }\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t                event.loop = false;\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            }\n\t        } else {\n\t            if (event.startOffset >= offset) {\n\t                event.start(Tone.TransportTime(ticks, 'i'));\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  The start from the scheduled start time\n\t\t *  @type {Ticks}\n\t\t *  @memberOf Tone.Part#\n\t\t *  @name startOffset\n\t\t *  @private\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'startOffset', {\n\t        get: function () {\n\t            return this._startOffset;\n\t        },\n\t        set: function (offset) {\n\t            this._startOffset = offset;\n\t            this._forEach(function (event) {\n\t                event.startOffset += this._startOffset;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  Stop the part at the given time.\n\t\t *  @param  {TimelinePosition}  time  When to stop the part.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.stop = function (time) {\n\t        var ticks = this.toTicks(time);\n\t        this._state.cancel(ticks);\n\t        this._state.setStateAtTime(Tone.State.Stopped, ticks);\n\t        this._forEach(function (event) {\n\t            event.stop(time);\n\t        });\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get/Set an Event's value at the given time. \n\t\t *  If a value is passed in and no event exists at\n\t\t *  the given time, one will be created with that value. \n\t\t *  If two events are at the same time, the first one will\n\t\t *  be returned.\n\t\t *  @example\n\t\t * part.at(\"1m\"); //returns the part at the first measure\n\t\t *\n\t\t * part.at(\"2m\", \"C2\"); //set the value at \"2m\" to C2. \n\t\t * //if an event didn't exist at that time, it will be created.\n\t\t *  @param {TransportTime} time The time of the event to get or set.\n\t\t *  @param {*=} value If a value is passed in, the value of the\n\t\t *                    event at the given time will be set to it.\n\t\t *  @return {Tone.Event} the event at the time\n\t\t */\n\t    Tone.Part.prototype.at = function (time, value) {\n\t        time = Tone.TransportTime(time);\n\t        var tickTime = Tone.Time(1, 'i').toSeconds();\n\t        for (var i = 0; i < this._events.length; i++) {\n\t            var event = this._events[i];\n\t            if (Math.abs(time.toTicks() - event.startOffset) < tickTime) {\n\t                if (!this.isUndef(value)) {\n\t                    event.value = value;\n\t                }\n\t                return event;\n\t            }\n\t        }\n\t        //if there was no event at that time, create one\n\t        if (!this.isUndef(value)) {\n\t            this.add(time, value);\n\t            //return the new event\n\t            return this._events[this._events.length - 1];\n\t        } else {\n\t            return null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Add a an event to the part. \n\t\t *  @param {Time} time The time the note should start.\n\t\t *                            If an object is passed in, it should\n\t\t *                            have a 'time' attribute and the rest\n\t\t *                            of the object will be used as the 'value'.\n\t\t *  @param  {Tone.Event|*}  value \n\t\t *  @returns {Tone.Part} this\n\t\t *  @example\n\t\t * part.add(\"1m\", \"C#+11\");\n\t\t */\n\t    Tone.Part.prototype.add = function (time, value) {\n\t        //extract the parameters\n\t        if (time.hasOwnProperty('time')) {\n\t            value = time;\n\t            time = value.time;\n\t        }\n\t        time = this.toTicks(time);\n\t        var event;\n\t        if (value instanceof Tone.Event) {\n\t            event = value;\n\t            event.callback = this._tick.bind(this);\n\t        } else {\n\t            event = new Tone.Event({\n\t                'callback': this._tick.bind(this),\n\t                'value': value\n\t            });\n\t        }\n\t        //the start offset\n\t        event.startOffset = time;\n\t        //initialize the values\n\t        event.set({\n\t            'loopEnd': this.loopEnd,\n\t            'loopStart': this.loopStart,\n\t            'loop': this.loop,\n\t            'humanize': this.humanize,\n\t            'playbackRate': this.playbackRate,\n\t            'probability': this.probability\n\t        });\n\t        this._events.push(event);\n\t        //start the note if it should be played right now\n\t        this._restartEvent(event);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Restart the given event\n\t\t *  @param  {Tone.Event}  event \n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._restartEvent = function (event) {\n\t        this._state.forEach(function (stateEvent) {\n\t            if (stateEvent.state === Tone.State.Started) {\n\t                this._startNote(event, stateEvent.time, stateEvent.offset);\n\t            } else {\n\t                //stop the note\n\t                event.stop(Tone.TransportTime(stateEvent.time, 'i'));\n\t            }\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Remove an event from the part. Will recursively iterate\n\t\t *  into nested parts to find the event.\n\t\t *  @param {Time} time The time of the event\n\t\t *  @param {*} value Optionally select only a specific event value\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.remove = function (time, value) {\n\t        //extract the parameters\n\t        if (time.hasOwnProperty('time')) {\n\t            value = time;\n\t            time = value.time;\n\t        }\n\t        time = this.toTicks(time);\n\t        for (var i = this._events.length - 1; i >= 0; i--) {\n\t            var event = this._events[i];\n\t            if (event instanceof Tone.Part) {\n\t                event.remove(time, value);\n\t            } else {\n\t                if (event.startOffset === time) {\n\t                    if (this.isUndef(value) || !this.isUndef(value) && event.value === value) {\n\t                        this._events.splice(i, 1);\n\t                        event.dispose();\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove all of the notes from the group. \n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.removeAll = function () {\n\t        this._forEach(function (event) {\n\t            event.dispose();\n\t        });\n\t        this._events = [];\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t\t *  @param {TimelinePosition} after The time after which to cancel the scheduled events.\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.cancel = function (after) {\n\t        after = this.toTicks(after);\n\t        this._forEach(function (event) {\n\t            event.cancel(after);\n\t        });\n\t        this._state.cancel(after);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Iterate over all of the events\n\t\t *  @param {Function} callback\n\t\t *  @param {Object} ctx The context\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._forEach = function (callback, ctx) {\n\t        ctx = this.defaultArg(ctx, this);\n\t        for (var i = this._events.length - 1; i >= 0; i--) {\n\t            var e = this._events[i];\n\t            if (e instanceof Tone.Part) {\n\t                e._forEach(callback, ctx);\n\t            } else {\n\t                callback.call(ctx, e);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the attribute of all of the events\n\t\t *  @param  {String}  attr  the attribute to set\n\t\t *  @param  {*}  value      The value to set it to\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._setAll = function (attr, value) {\n\t        this._forEach(function (event) {\n\t            event[attr] = value;\n\t        });\n\t    };\n\t    /**\n\t\t *  Internal tick method\n\t\t *  @param  {Number}  time  The time of the event in seconds\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._tick = function (time, value) {\n\t        if (!this.mute) {\n\t            this.callback(time, value);\n\t        }\n\t    };\n\t    /**\n\t\t *  Determine if the event should be currently looping\n\t\t *  given the loop boundries of this Part.\n\t\t *  @param  {Tone.Event}  event  The event to test\n\t\t *  @private\n\t\t */\n\t    Tone.Part.prototype._testLoopBoundries = function (event) {\n\t        if (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd) {\n\t            event.cancel(0);\n\t        } else {\n\t            //reschedule it if it's stopped\n\t            if (event.state === Tone.State.Stopped) {\n\t                this._restartEvent(event);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  The probability of the notes being triggered.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {NormalRange}\n\t\t *  @name probability\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'probability', {\n\t        get: function () {\n\t            return this._probability;\n\t        },\n\t        set: function (prob) {\n\t            this._probability = prob;\n\t            this._setAll('probability', prob);\n\t        }\n\t    });\n\t    /**\n\t\t *  If set to true, will apply small random variation\n\t\t *  to the callback time. If the value is given as a time, it will randomize\n\t\t *  by that amount.\n\t\t *  @example\n\t\t * event.humanize = true;\n\t\t *  @type {Boolean|Time}\n\t\t *  @name humanize\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'humanize', {\n\t        get: function () {\n\t            return this._humanize;\n\t        },\n\t        set: function (variation) {\n\t            this._humanize = variation;\n\t            this._setAll('humanize', variation);\n\t        }\n\t    });\n\t    /**\n\t\t *  If the part should loop or not\n\t\t *  between Tone.Part.loopStart and \n\t\t *  Tone.Part.loopEnd. An integer\n\t\t *  value corresponds to the number of\n\t\t *  loops the Part does after it starts.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Boolean|Positive}\n\t\t *  @name loop\n\t\t *  @example\n\t\t * //loop the part 8 times\n\t\t * part.loop = 8;\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            this._forEach(function (event) {\n\t                event._loopStart = this._loopStart;\n\t                event._loopEnd = this._loopEnd;\n\t                event.loop = loop;\n\t                this._testLoopBoundries(event);\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopEnd point determines when it will \n\t\t *  loop if Tone.Part.loop is true.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopEnd, 'i').toNotation();\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = this.toTicks(loopEnd);\n\t            if (this._loop) {\n\t                this._forEach(function (event) {\n\t                    event.loopEnd = loopEnd;\n\t                    this._testLoopBoundries(event);\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The loopStart point determines when it will \n\t\t *  loop if Tone.Part.loop is true.\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {TransportTime}\n\t\t *  @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'loopStart', {\n\t        get: function () {\n\t            return Tone.TransportTime(this._loopStart, 'i').toNotation();\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = this.toTicks(loopStart);\n\t            if (this._loop) {\n\t                this._forEach(function (event) {\n\t                    event.loopStart = this.loopStart;\n\t                    this._testLoopBoundries(event);\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe playback rate of the part\n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Positive}\n\t\t *  @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this._setAll('playbackRate', rate);\n\t        }\n\t    });\n\t    /**\n\t\t * \tThe number of scheduled notes in the part. \n\t\t *  @memberOf Tone.Part#\n\t\t *  @type {Positive}\n\t\t *  @name length\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Part.prototype, 'length', {\n\t        get: function () {\n\t            return this._events.length;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Part}  this\n\t\t */\n\t    Tone.Part.prototype.dispose = function () {\n\t        this.removeAll();\n\t        this._state.dispose();\n\t        this._state = null;\n\t        this.callback = null;\n\t        this._events = null;\n\t        return this;\n\t    };\n\t    return Tone.Part;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.Pattern arpeggiates between the given notes\n\t\t *         in a number of patterns. See Tone.CtrlPattern for\n\t\t *         a full list of patterns.\n\t\t *  @example\n\t\t * var pattern = new Tone.Pattern(function(time, note){\n\t\t *   //the order of the notes passed in depends on the pattern\n\t\t * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n\t\t *  @extends {Tone.Loop}\n\t\t *  @param {Function} callback The callback to invoke with the\n\t\t *                             event.\n\t\t *  @param {Array} values The values to arpeggiate over.\n\t\t */\n\t    Tone.Pattern = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'values',\n\t            'pattern'\n\t        ], Tone.Pattern.defaults);\n\t        Tone.Loop.call(this, options);\n\t        /**\n\t\t\t *  The pattern manager\n\t\t\t *  @type {Tone.CtrlPattern}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pattern = new Tone.CtrlPattern({\n\t            'values': options.values,\n\t            'type': options.pattern,\n\t            'index': options.index\n\t        });\n\t    };\n\t    Tone.extend(Tone.Pattern, Tone.Loop);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Pattern.defaults = {\n\t        'pattern': Tone.CtrlPattern.Type.Up,\n\t        'values': []\n\t    };\n\t    /**\n\t\t *  Internal function called when the notes should be called\n\t\t *  @param  {Number}  time  The time the event occurs\n\t\t *  @private\n\t\t */\n\t    Tone.Pattern.prototype._tick = function (time) {\n\t        this.callback(time, this._pattern.value);\n\t        this._pattern.next();\n\t    };\n\t    /**\n\t\t *  The current index in the values array.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {Positive}\n\t\t *  @name index\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'index', {\n\t        get: function () {\n\t            return this._pattern.index;\n\t        },\n\t        set: function (i) {\n\t            this._pattern.index = i;\n\t        }\n\t    });\n\t    /**\n\t\t *  The array of events.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {Array}\n\t\t *  @name values\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'values', {\n\t        get: function () {\n\t            return this._pattern.values;\n\t        },\n\t        set: function (vals) {\n\t            this._pattern.values = vals;\n\t        }\n\t    });\n\t    /**\n\t\t *  The current value of the pattern.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {*}\n\t\t *  @name value\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'value', {\n\t        get: function () {\n\t            return this._pattern.value;\n\t        }\n\t    });\n\t    /**\n\t\t *  The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t\t *  @memberOf Tone.Pattern#\n\t\t *  @type {String}\n\t\t *  @name pattern\n\t\t */\n\t    Object.defineProperty(Tone.Pattern.prototype, 'pattern', {\n\t        get: function () {\n\t            return this._pattern.type;\n\t        },\n\t        set: function (pattern) {\n\t            this._pattern.type = pattern;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @return  {Tone.Pattern}  this\n\t\t */\n\t    Tone.Pattern.prototype.dispose = function () {\n\t        Tone.Loop.prototype.dispose.call(this);\n\t        this._pattern.dispose();\n\t        this._pattern = null;\n\t    };\n\t    return Tone.Pattern;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class A sequence is an alternate notation of a part. Instead\n\t\t *         of passing in an array of [time, event] pairs, pass\n\t\t *         in an array of events which will be spaced at the\n\t\t *         given subdivision. Sub-arrays will subdivide that beat\n\t\t *         by the number of items are in the array. \n\t\t *         Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n\t\t *  @param  {Function}  callback  The callback to invoke with every note\n\t\t *  @param  {Array}    events  The sequence\n\t\t *  @param  {Time} subdivision  The subdivision between which events are placed. \n\t\t *  @extends {Tone.Part}\n\t\t *  @example\n\t\t * var seq = new Tone.Sequence(function(time, note){\n\t\t * \tconsole.log(note);\n\t\t * //straight quater notes\n\t\t * }, [\"C4\", \"E4\", \"G4\", \"A4\"], \"4n\");\n\t\t *  @example\n\t\t * var seq = new Tone.Sequence(function(time, note){\n\t\t * \tconsole.log(note);\n\t\t * //subdivisions are given as subarrays\n\t\t * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]);\n\t\t */\n\t    Tone.Sequence = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'callback',\n\t            'events',\n\t            'subdivision'\n\t        ], Tone.Sequence.defaults);\n\t        //remove the events\n\t        var events = options.events;\n\t        delete options.events;\n\t        Tone.Part.call(this, options);\n\t        /**\n\t\t\t *  The subdivison of each note\n\t\t\t *  @type  {Ticks}\n\t\t\t *  @private\n\t\t\t */\n\t        this._subdivision = this.toTicks(options.subdivision);\n\t        //if no time was passed in, the loop end is the end of the cycle\n\t        if (this.isUndef(options.loopEnd) && !this.isUndef(events)) {\n\t            this._loopEnd = events.length * this._subdivision;\n\t        }\n\t        //defaults to looping\n\t        this._loop = true;\n\t        //add all of the events\n\t        if (!this.isUndef(events)) {\n\t            for (var i = 0; i < events.length; i++) {\n\t                this.add(i, events[i]);\n\t            }\n\t        }\n\t    };\n\t    Tone.extend(Tone.Sequence, Tone.Part);\n\t    /**\n\t\t *  The default values.\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.Sequence.defaults = { 'subdivision': '4n' };\n\t    /**\n\t\t *  The subdivision of the sequence. This can only be \n\t\t *  set in the constructor. The subdivision is the \n\t\t *  interval between successive steps. \n\t\t *  @type {Time}\n\t\t *  @memberOf Tone.Sequence#\n\t\t *  @name subdivision\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.Sequence.prototype, 'subdivision', {\n\t        get: function () {\n\t            return Tone.Time(this._subdivision, 'i').toNotation();\n\t        }\n\t    });\n\t    /**\n\t\t *  Get/Set an index of the sequence. If the index contains a subarray, \n\t\t *  a Tone.Sequence representing that sub-array will be returned. \n\t\t *  @example\n\t\t * var sequence = new Tone.Sequence(playNote, [\"E4\", \"C4\", \"F#4\", [\"A4\", \"Bb3\"]])\n\t\t * sequence.at(0)// => returns \"E4\"\n\t\t * //set a value\n\t\t * sequence.at(0, \"G3\");\n\t\t * //get a nested sequence\n\t\t * sequence.at(3).at(1)// => returns \"Bb3\"\n\t\t * @param {Positive} index The index to get or set\n\t\t * @param {*} value Optionally pass in the value to set at the given index.\n\t\t */\n\t    Tone.Sequence.prototype.at = function (index, value) {\n\t        //if the value is an array, \n\t        if (this.isArray(value)) {\n\t            //remove the current event at that index\n\t            this.remove(index);\n\t        }\n\t        //call the parent's method\n\t        return Tone.Part.prototype.at.call(this, this._indexTime(index), value);\n\t    };\n\t    /**\n\t\t *  Add an event at an index, if there's already something\n\t\t *  at that index, overwrite it. If `value` is an array, \n\t\t *  it will be parsed as a subsequence.\n\t\t *  @param {Number} index The index to add the event to\n\t\t *  @param {*} value The value to add at that index\n\t\t *  @returns {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.add = function (index, value) {\n\t        if (value === null) {\n\t            return this;\n\t        }\n\t        if (this.isArray(value)) {\n\t            //make a subsequence and add that to the sequence\n\t            var subSubdivision = Math.round(this._subdivision / value.length);\n\t            value = new Tone.Sequence(this._tick.bind(this), value, Tone.Time(subSubdivision, 'i'));\n\t        }\n\t        Tone.Part.prototype.add.call(this, this._indexTime(index), value);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Remove a value from the sequence by index\n\t\t *  @param {Number} index The index of the event to remove\n\t\t *  @returns {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.remove = function (index, value) {\n\t        Tone.Part.prototype.remove.call(this, this._indexTime(index), value);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the time of the index given the Sequence's subdivision\n\t\t *  @param  {Number}  index \n\t\t *  @return  {Time}  The time of that index\n\t\t *  @private\n\t\t */\n\t    Tone.Sequence.prototype._indexTime = function (index) {\n\t        if (index instanceof Tone.TransportTime) {\n\t            return index;\n\t        } else {\n\t            return Tone.TransportTime(index * this._subdivision + this.startOffset, 'i');\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.Sequence} this\n\t\t */\n\t    Tone.Sequence.prototype.dispose = function () {\n\t        Tone.Part.prototype.dispose.call(this);\n\t        return this;\n\t    };\n\t    return Tone.Sequence;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PulseOscillator is a pulse oscillator with control over pulse width,\n\t\t *         also known as the duty cycle. At 50% duty cycle (width = 0.5) the wave is \n\t\t *         a square and only odd-numbered harmonics are present. At all other widths \n\t\t *         even-numbered harmonics are present. Read more \n\t\t *         [here](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @param {Frequency} [frequency] The frequency of the oscillator\n\t\t *  @param {NormalRange} [width] The width of the pulse\n\t\t *  @example\n\t\t * var pulse = new Tone.PulseOscillator(\"E5\", 0.4).toMaster().start();\n\t\t */\n\t    Tone.PulseOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'width'\n\t        ], Tone.Oscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The width of the pulse. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.width = new Tone.Signal(options.width, Tone.Type.NormalRange);\n\t        /**\n\t\t\t *  gate the width amount\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._widthGate = new Tone.Gain();\n\t        /**\n\t\t\t *  the sawtooth oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sawtooth = new Tone.Oscillator({\n\t            frequency: options.frequency,\n\t            detune: options.detune,\n\t            type: 'sawtooth',\n\t            phase: options.phase\n\t        });\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._sawtooth.frequency;\n\t        /**\n\t\t\t *  The detune in cents. \n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._sawtooth.detune;\n\t        /**\n\t\t\t *  Threshold the signal to turn it into a square\n\t\t\t *  @type {Tone.WaveShaper}\n\t\t\t *  @private\n\t\t\t */\n\t        this._thresh = new Tone.WaveShaper(function (val) {\n\t            if (val < 0) {\n\t                return -1;\n\t            } else {\n\t                return 1;\n\t            }\n\t        });\n\t        //connections\n\t        this._sawtooth.chain(this._thresh, this.output);\n\t        this.width.chain(this._widthGate, this._thresh);\n\t        this._readOnly([\n\t            'width',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PulseOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  The default parameters.\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PulseOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'width': 0.2\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} time \n\t\t *  @private\n\t\t */\n\t    Tone.PulseOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._sawtooth.start(time);\n\t        this._widthGate.gain.setValueAtTime(1, time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time \n\t\t *  @private\n\t\t */\n\t    Tone.PulseOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._sawtooth.stop(time);\n\t        //the width is still connected to the output. \n\t        //that needs to be stopped also\n\t        this._widthGate.gain.setValueAtTime(0, time);\n\t    };\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._sawtooth.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._sawtooth.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the oscillator. Always returns \"pulse\".\n\t\t * @readOnly\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return 'pulse';\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. Cannot set partials for this waveform type\n\t\t * @memberOf Tone.PulseOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @private\n\t\t */\n\t    Object.defineProperty(Tone.PulseOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return [];\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up method.\n\t\t *  @return {Tone.PulseOscillator} this\n\t\t */\n\t    Tone.PulseOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._sawtooth.dispose();\n\t        this._sawtooth = null;\n\t        this._writable([\n\t            'width',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.width.dispose();\n\t        this.width = null;\n\t        this._widthGate.dispose();\n\t        this._widthGate = null;\n\t        this._thresh.dispose();\n\t        this._thresh = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.PulseOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.PWMOscillator modulates the width of a Tone.PulseOscillator \n\t\t *         at the modulationFrequency. This has the effect of continuously\n\t\t *         changing the timbre of the oscillator by altering the harmonics \n\t\t *         generated.\n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse. \n\t\t *  @example\n\t\t *  var pwm = new Tone.PWMOscillator(\"Ab3\", 0.3).toMaster().start();\n\t\t */\n\t    Tone.PWMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'modulationFrequency'\n\t        ], Tone.PWMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  the pulse oscillator\n\t\t\t *  @type {Tone.PulseOscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._pulse = new Tone.PulseOscillator(options.modulationFrequency);\n\t        //change the pulse oscillator type\n\t        this._pulse._sawtooth.type = 'sine';\n\t        /**\n\t\t\t *  the modulator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator({\n\t            'frequency': options.frequency,\n\t            'detune': options.detune,\n\t            'phase': options.phase\n\t        });\n\t        /**\n\t\t\t *  Scale the oscillator so it doesn't go silent \n\t\t\t *  at the extreme values.\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._scale = new Tone.Multiply(2);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._modulator.frequency;\n\t        /**\n\t\t\t *  The detune of the oscillator.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._modulator.detune;\n\t        /**\n\t\t\t *  The modulation rate of the oscillator. \n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.modulationFrequency = this._pulse.frequency;\n\t        //connections\n\t        this._modulator.chain(this._scale, this._pulse.width);\n\t        this._pulse.connect(this.output);\n\t        this._readOnly([\n\t            'modulationFrequency',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PWMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.PWMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationFrequency': 0.4\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.PWMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._pulse.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.PWMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._pulse.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the oscillator. Always returns \"pwm\".\n\t\t * @readOnly\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return 'pwm';\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. Cannot set partials for this waveform type\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @private\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return [];\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.PWMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.PWMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._modulator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.PWMOscillator} this\n\t\t */\n\t    Tone.PWMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._pulse.dispose();\n\t        this._pulse = null;\n\t        this._scale.dispose();\n\t        this._scale = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._writable([\n\t            'modulationFrequency',\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.modulationFrequency = null;\n\t        return this;\n\t    };\n\t    return Tone.PWMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FMOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.FMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.FMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'modulationType'\n\t        ], Tone.FMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The carrier oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Oscillator(options.frequency, options.type);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._carrier.detune;\n\t        this.detune.value = options.detune;\n\t        /**\n\t\t\t *  The modulation index which is in essence the depth or amount of the modulation. In other terms it is the \n\t\t\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t\t *  modulating signal (ma) -- as in ma/mf. \n\t\t\t *\t@type {Positive}\n\t\t\t *\t@signal\n\t\t\t */\n\t        this.modulationIndex = new Tone.Multiply(options.modulationIndex);\n\t        this.modulationIndex.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  The modulating oscillator\n\t\t\t *  @type  {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);\n\t        /**\n\t\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t\t *  Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch the modulator an octave below carrier\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //connections\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.frequency.chain(this.modulationIndex, this._modulationNode);\n\t        this._modulator.connect(this._modulationNode.gain);\n\t        this._modulationNode.connect(this._carrier.frequency);\n\t        this._carrier.connect(this.output);\n\t        this.detune.connect(this._modulator.detune);\n\t        this.phase = options.phase;\n\t        this._readOnly([\n\t            'modulationIndex',\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.FMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationIndex': 2,\n\t        'modulationType': 'square',\n\t        'harmonicity': 1\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.FMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._carrier.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.FMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._carrier.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._carrier.type;\n\t        },\n\t        set: function (type) {\n\t            this._carrier.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {String}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            return this._modulator.type;\n\t        },\n\t        set: function (type) {\n\t            this._modulator.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._carrier.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._carrier.phase = phase;\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.FMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.FMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._carrier.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._carrier.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.FMOscillator} this\n\t\t */\n\t    Tone.FMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'modulationIndex',\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.modulationIndex.dispose();\n\t        this.modulationIndex = null;\n\t        return this;\n\t    };\n\t    return Tone.FMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.AMOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.AMOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.AMOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'modulationType'\n\t        ], Tone.AMOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The carrier oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Oscillator(options.frequency, options.type);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this._carrier.frequency;\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this._carrier.detune;\n\t        this.detune.value = options.detune;\n\t        /**\n\t\t\t *  The modulating oscillator\n\t\t\t *  @type  {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Oscillator(options.frequency, options.modulationType);\n\t        /**\n\t\t\t *  convert the -1,1 output to 0,1\n\t\t\t *  @type {Tone.AudioToGain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationScale = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t\t *  Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch the modulator an octave below carrier\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //connections\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.detune.connect(this._modulator.detune);\n\t        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t        this._carrier.chain(this._modulationNode, this.output);\n\t        this.phase = options.phase;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AMOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.AMOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'modulationType': 'square',\n\t        'harmonicity': 1\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.AMOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.start(time);\n\t        this._carrier.start(time);\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.AMOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._modulator.stop(time);\n\t        this._carrier.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._carrier.type;\n\t        },\n\t        set: function (type) {\n\t            this._carrier.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {string}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            return this._modulator.type;\n\t        },\n\t        set: function (type) {\n\t            this._modulator.type = type;\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._carrier.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._carrier.phase = phase;\n\t            this._modulator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.AMOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.AMOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._carrier.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._carrier.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.AMOscillator} this\n\t\t */\n\t    Tone.AMOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune',\n\t            'harmonicity'\n\t        ]);\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this._modulationScale.dispose();\n\t        this._modulationScale = null;\n\t        return this;\n\t    };\n\t    return Tone.AMOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.FatOscillator \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The starting frequency of the oscillator. \n\t\t *  @param {String} type The type of the carrier oscillator.\n\t\t *  @param {String} modulationType The type of the modulator oscillator.\n\t\t *  @example\n\t\t * //a sine oscillator frequency-modulated by a square wave\n\t\t * var fmOsc = new Tone.FatOscillator(\"Ab3\", \"sine\", \"square\").toMaster().start();\n\t\t */\n\t    Tone.FatOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type',\n\t            'spread'\n\t        ], Tone.FatOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The oscillator's frequency\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control signal.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  The array of oscillators\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillators = [];\n\t        /**\n\t\t\t *  The total spread of the oscillators\n\t\t\t *  @type  {Cents}\n\t\t\t *  @private\n\t\t\t */\n\t        this._spread = options.spread;\n\t        /**\n\t\t\t *  The type of the oscillator\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The phase of the oscillators\n\t\t\t *  @type {Degrees}\n\t\t\t *  @private\n\t\t\t */\n\t        this._phase = options.phase;\n\t        /**\n\t\t\t *  The partials array\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._partials = this.defaultArg(options.partials, []);\n\t        //set the count initially\n\t        this.count = options.count;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FatOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.FatOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'phase': 0,\n\t        'spread': 20,\n\t        'count': 3,\n\t        'type': 'sawtooth'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param  {Time} [time=now]\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._start = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._forEach(function (osc) {\n\t            osc.start(time);\n\t        });\n\t    };\n\t    /**\n\t\t *  stop the oscillator\n\t\t *  @param  {Time} time (optional) timing parameter\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._stop = function (time) {\n\t        time = this.toSeconds(time);\n\t        this._forEach(function (osc) {\n\t            osc.stop(time);\n\t        });\n\t    };\n\t    /**\n\t\t *  Iterate over all of the oscillators\n\t\t *  @param  {Function}  iterator  The iterator function\n\t\t *  @private\n\t\t */\n\t    Tone.FatOscillator.prototype._forEach = function (iterator) {\n\t        for (var i = 0; i < this._oscillators.length; i++) {\n\t            iterator.call(this, this._oscillators[i], i);\n\t        }\n\t    };\n\t    /**\n\t\t * The type of the carrier oscillator\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {string}\n\t\t * @name type\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            this._type = type;\n\t            this._forEach(function (osc) {\n\t                osc.type = type;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The detune spread between the oscillators. If \"count\" is\n\t\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t\t * for a total detune spread of 40 cents.\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Cents}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'spread', {\n\t        get: function () {\n\t            return this._spread;\n\t        },\n\t        set: function (spread) {\n\t            this._spread = spread;\n\t            if (this._oscillators.length > 1) {\n\t                var start = -spread / 2;\n\t                var step = spread / (this._oscillators.length - 1);\n\t                this._forEach(function (osc, i) {\n\t                    osc.detune.value = start + step * i;\n\t                });\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of detuned oscillators\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Number}\n\t\t * @name count\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'count', {\n\t        get: function () {\n\t            return this._oscillators.length;\n\t        },\n\t        set: function (count) {\n\t            count = Math.max(count, 1);\n\t            if (this._oscillators.length !== count) {\n\t                // var partials = this.partials;\n\t                // var type = this.type;\n\t                //dispose the previous oscillators\n\t                this._forEach(function (osc) {\n\t                    osc.dispose();\n\t                });\n\t                this._oscillators = [];\n\t                for (var i = 0; i < count; i++) {\n\t                    var osc = new Tone.Oscillator();\n\t                    if (this.type === Tone.Oscillator.Type.Custom) {\n\t                        osc.partials = this._partials;\n\t                    } else {\n\t                        osc.type = this._type;\n\t                    }\n\t                    osc.phase = this._phase;\n\t                    osc.volume.value = -6 - count;\n\t                    this.frequency.connect(osc.frequency);\n\t                    this.detune.connect(osc.detune);\n\t                    osc.connect(this.output);\n\t                    this._oscillators[i] = osc;\n\t                }\n\t                //set the spread\n\t                this.spread = this._spread;\n\t                if (this.state === Tone.State.Started) {\n\t                    this._forEach(function (osc) {\n\t                        osc.start();\n\t                    });\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The phase of the oscillator in degrees.\n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Number}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._phase;\n\t        },\n\t        set: function (phase) {\n\t            this._phase = phase;\n\t            this._forEach(function (osc) {\n\t                osc.phase = phase;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the carrier waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * @memberOf Tone.FatOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.FatOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._partials;\n\t        },\n\t        set: function (partials) {\n\t            this._partials = partials;\n\t            this._type = Tone.Oscillator.Type.Custom;\n\t            this._forEach(function (osc) {\n\t                osc.partials = partials;\n\t            });\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.FatOscillator} this\n\t\t */\n\t    Tone.FatOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this._forEach(function (osc) {\n\t            osc.dispose();\n\t        });\n\t        this._oscillators = null;\n\t        this._partials = null;\n\t        return this;\n\t    };\n\t    return Tone.FatOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Tone.OmniOscillator aggregates Tone.Oscillator, Tone.PulseOscillator,\n\t\t *         Tone.PWMOscillator, Tone.FMOscillator, Tone.AMOscillator, and Tone.FatOscillator\n\t\t *         into one class. The oscillator class can be changed by setting the `type`. \n\t\t *         `omniOsc.type = \"pwm\"` will set it to the Tone.PWMOscillator. Prefixing\n\t\t *         any of the basic types (\"sine\", \"square4\", etc.) with \"fm\", \"am\", or \"fat\"\n\t\t *         will use the FMOscillator, AMOscillator or FatOscillator respectively. \n\t\t *         For example: `omniOsc.type = \"fatsawtooth\"` will create set the oscillator\n\t\t *         to a FatOscillator of type \"sawtooth\". \n\t\t *\n\t\t *  @extends {Tone.Oscillator}\n\t\t *  @constructor\n\t\t *  @param {Frequency} frequency The initial frequency of the oscillator.\n\t\t *  @param {String} type The type of the oscillator.\n\t\t *  @example\n\t\t *  var omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\");\n\t\t */\n\t    Tone.OmniOscillator = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'frequency',\n\t            'type'\n\t        ], Tone.OmniOscillator.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune control\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  the type of the oscillator source\n\t\t\t *  @type {String}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sourceType = undefined;\n\t        /**\n\t\t\t *  the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillator = null;\n\t        //set the oscillator\n\t        this.type = options.type;\n\t        this._readOnly([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        //set the options\n\t        this.set(options);\n\t    };\n\t    Tone.extend(Tone.OmniOscillator, Tone.Oscillator);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t *  @const\n\t\t */\n\t    Tone.OmniOscillator.defaults = {\n\t        'frequency': 440,\n\t        'detune': 0,\n\t        'type': 'sine',\n\t        'phase': 0\n\t    };\n\t    /**\n\t\t *  @enum {String}\n\t\t *  @private\n\t\t */\n\t    var OmniOscType = {\n\t        Pulse: 'PulseOscillator',\n\t        PWM: 'PWMOscillator',\n\t        Osc: 'Oscillator',\n\t        FM: 'FMOscillator',\n\t        AM: 'AMOscillator',\n\t        Fat: 'FatOscillator'\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param {Time} [time=now] the time to start the oscillator\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._start = function (time) {\n\t        this._oscillator.start(time);\n\t    };\n\t    /**\n\t\t *  start the oscillator\n\t\t *  @param {Time} [time=now] the time to start the oscillator\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._stop = function (time) {\n\t        this._oscillator.stop(time);\n\t    };\n\t    /**\n\t\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error \n\t\t * when it's not.\n\t\t * \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {String}\n\t\t * @name type\n\t\t * @example\n\t\t * omniOsc.type = \"pwm\";\n\t\t * //modulationFrequency is parameter which is available\n\t\t * //only when the type is \"pwm\". \n\t\t * omniOsc.modulationFrequency.value = 0.5;\n\t\t * @example\n\t\t * //an square wave frequency modulated by a sawtooth\n\t\t * omniOsc.type = \"fmsquare\";\n\t\t * omniOsc.modulationType = \"sawtooth\";\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'type', {\n\t        get: function () {\n\t            var prefix = '';\n\t            if (this._sourceType === OmniOscType.FM) {\n\t                prefix = 'fm';\n\t            } else if (this._sourceType === OmniOscType.AM) {\n\t                prefix = 'am';\n\t            } else if (this._sourceType === OmniOscType.Fat) {\n\t                prefix = 'fat';\n\t            }\n\t            return prefix + this._oscillator.type;\n\t        },\n\t        set: function (type) {\n\t            if (type.substr(0, 2) === 'fm') {\n\t                this._createNewOscillator(OmniOscType.FM);\n\t                this._oscillator.type = type.substr(2);\n\t            } else if (type.substr(0, 2) === 'am') {\n\t                this._createNewOscillator(OmniOscType.AM);\n\t                this._oscillator.type = type.substr(2);\n\t            } else if (type.substr(0, 3) === 'fat') {\n\t                this._createNewOscillator(OmniOscType.Fat);\n\t                this._oscillator.type = type.substr(3);\n\t            } else if (type === 'pwm') {\n\t                this._createNewOscillator(OmniOscType.PWM);\n\t            } else if (type === 'pulse') {\n\t                this._createNewOscillator(OmniOscType.Pulse);\n\t            } else {\n\t                this._createNewOscillator(OmniOscType.Osc);\n\t                this._oscillator.type = type;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The partials of the waveform. A partial represents \n\t\t * the amplitude at a harmonic. The first harmonic is the \n\t\t * fundamental frequency, the second is the octave and so on\n\t\t * following the harmonic series. \n\t\t * Setting this value will automatically set the type to \"custom\". \n\t\t * The value is an empty array when the type is not \"custom\". \n\t\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Array}\n\t\t * @name partials\n\t\t * @example\n\t\t * osc.partials = [1, 0.2, 0.01];\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'partials', {\n\t        get: function () {\n\t            return this._oscillator.partials;\n\t        },\n\t        set: function (partials) {\n\t            this._oscillator.partials = partials;\n\t        }\n\t    });\n\t    /**\n\t\t *  Set a member/attribute of the oscillator. \n\t\t *  @param {Object|String} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone.OmniOscillator} this\n\t\t */\n\t    Tone.OmniOscillator.prototype.set = function (params, value) {\n\t        //make sure the type is set first\n\t        if (params === 'type') {\n\t            this.type = value;\n\t        } else if (this.isObject(params) && params.hasOwnProperty('type')) {\n\t            this.type = params.type;\n\t        }\n\t        //then set the rest\n\t        Tone.prototype.set.apply(this, arguments);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  connect the oscillator to the frequency and detune signals\n\t\t *  @private\n\t\t */\n\t    Tone.OmniOscillator.prototype._createNewOscillator = function (oscType) {\n\t        if (oscType !== this._sourceType) {\n\t            this._sourceType = oscType;\n\t            var OscillatorConstructor = Tone[oscType];\n\t            //short delay to avoid clicks on the change\n\t            var now = this.now() + this.blockTime;\n\t            if (this._oscillator !== null) {\n\t                var oldOsc = this._oscillator;\n\t                oldOsc.stop(now);\n\t                //dispose the old one\n\t                setTimeout(function () {\n\t                    oldOsc.dispose();\n\t                    oldOsc = null;\n\t                }, this.blockTime * 1000);\n\t            }\n\t            this._oscillator = new OscillatorConstructor();\n\t            this.frequency.connect(this._oscillator.frequency);\n\t            this.detune.connect(this._oscillator.detune);\n\t            this._oscillator.connect(this.output);\n\t            if (this.state === Tone.State.Started) {\n\t                this._oscillator.start(now);\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t * The phase of the oscillator in degrees. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Degrees}\n\t\t * @name phase\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'phase', {\n\t        get: function () {\n\t            return this._oscillator.phase;\n\t        },\n\t        set: function (phase) {\n\t            this._oscillator.phase = phase;\n\t        }\n\t    });\n\t    /**\n\t\t * The width of the oscillator (only if the oscillator is set to \"pulse\")\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {NormalRange}\n\t\t * @signal\n\t\t * @name width\n\t\t * @example\n\t\t * var omniOsc = new Tone.OmniOscillator(440, \"pulse\");\n\t\t * //can access the width attribute only if type === \"pulse\"\n\t\t * omniOsc.width.value = 0.2; \n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'width', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Pulse) {\n\t                return this._oscillator.width;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The number of detuned oscillators\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Number}\n\t\t * @name count\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'count', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                return this._oscillator.count;\n\t            }\n\t        },\n\t        set: function (count) {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                this._oscillator.count = count;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The detune spread between the oscillators. If \"count\" is\n\t\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t\t * for a total detune spread of 40 cents. See Tone.FatOscillator\n\t\t * for more info.\n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Cents}\n\t\t * @name spread\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'spread', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                return this._oscillator.spread;\n\t            }\n\t        },\n\t        set: function (spread) {\n\t            if (this._sourceType === OmniOscType.Fat) {\n\t                this._oscillator.spread = spread;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The type of the modulator oscillator. Only if the oscillator\n\t\t * is set to \"am\" or \"fm\" types. see. Tone.AMOscillator or Tone.FMOscillator\n\t\t * for more info. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {String}\n\t\t * @name modulationType\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationType', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                return this._oscillator.modulationType;\n\t            }\n\t        },\n\t        set: function (mType) {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                this._oscillator.modulationType = mType;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the \n\t\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t * modulating signal (ma) -- as in ma/mf. \n\t\t * See Tone.FMOscillator for more info. \n\t\t * @type {Positive}\n\t\t * @signal\n\t\t * @name modulationIndex\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationIndex', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM) {\n\t                return this._oscillator.modulationIndex;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Harmonicity is the frequency ratio between the carrier and the modulator oscillators. \n\t\t *  A harmonicity of 1 gives both oscillators the same frequency. \n\t\t *  Harmonicity = 2 means a change of an octave. See Tone.AMOscillator or Tone.FMOscillator\n\t\t *  for more info. \n\t\t *  @memberOf Tone.OmniOscillator#\n\t\t *  @signal\n\t\t *  @type {Positive}\n\t\t *  @name harmonicity\n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'harmonicity', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.FM || this._sourceType === OmniOscType.AM) {\n\t                return this._oscillator.harmonicity;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The modulationFrequency Signal of the oscillator \n\t\t * (only if the oscillator type is set to pwm). See \n\t\t * Tone.PWMOscillator for more info. \n\t\t * @memberOf Tone.OmniOscillator#\n\t\t * @type {Frequency}\n\t\t * @signal\n\t\t * @name modulationFrequency\n\t\t * @example\n\t\t * var omniOsc = new Tone.OmniOscillator(440, \"pwm\");\n\t\t * //can access the modulationFrequency attribute only if type === \"pwm\"\n\t\t * omniOsc.modulationFrequency.value = 0.2; \n\t\t */\n\t    Object.defineProperty(Tone.OmniOscillator.prototype, 'modulationFrequency', {\n\t        get: function () {\n\t            if (this._sourceType === OmniOscType.PWM) {\n\t                return this._oscillator.modulationFrequency;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return {Tone.OmniOscillator} this\n\t\t */\n\t    Tone.OmniOscillator.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'detune'\n\t        ]);\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._oscillator.dispose();\n\t        this._oscillator = null;\n\t        this._sourceType = null;\n\t        return this;\n\t    };\n\t    return Tone.OmniOscillator;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Base-class for all instruments\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t */\n\t    Tone.Instrument = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Instrument.defaults);\n\t        /**\n\t\t\t *  The output and volume triming node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t    };\n\t    Tone.extend(Tone.Instrument);\n\t    /**\n\t\t *  the default attributes\n\t\t *  @type {object}\n\t\t */\n\t    Tone.Instrument.defaults = {\n\t        /** the volume of the output in decibels */\n\t        'volume': 0\n\t    };\n\t    /**\n\t\t *  @abstract\n\t\t *  @param {string|number} note the note to trigger\n\t\t *  @param {Time} [time=now] the time to trigger the ntoe\n\t\t *  @param {number} [velocity=1] the velocity to trigger the note\n\t\t */\n\t    Tone.Instrument.prototype.triggerAttack = Tone.noOp;\n\t    /**\n\t\t *  @abstract\n\t\t *  @param {Time} [time=now] when to trigger the release\n\t\t */\n\t    Tone.Instrument.prototype.triggerRelease = Tone.noOp;\n\t    /**\n\t\t *  Trigger the attack and then the release after the duration. \n\t\t *  @param  {Frequency} note     The note to trigger.\n\t\t *  @param  {Time} duration How long the note should be held for before\n\t\t *                          triggering the release. This value must be greater than 0. \n\t\t *  @param {Time} [time=now]  When the note should be triggered.\n\t\t *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.\n\t\t *  @returns {Tone.Instrument} this\n\t\t *  @example\n\t\t * //trigger \"C4\" for the duration of an 8th note\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.Instrument.prototype.triggerAttackRelease = function (note, duration, time, velocity) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(note, time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Instrument} this\n\t\t */\n\t    Tone.Instrument.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this._writable(['volume']);\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    return Tone.Instrument;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  This is an abstract base class for other monophonic instruments to \n\t\t *          extend. IMPORTANT: It does not make any sound on its own and\n\t\t *          shouldn't be directly instantiated.\n\t\t *\n\t\t *  @constructor\n\t\t *  @abstract\n\t\t *  @extends {Tone.Instrument}\n\t\t */\n\t    Tone.Monophonic = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Monophonic.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The glide time between notes. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.portamento = options.portamento;\n\t    };\n\t    Tone.extend(Tone.Monophonic, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Monophonic.defaults = { 'portamento': 0 };\n\t    /**\n\t\t *  Trigger the attack of the note optionally with a given velocity. \n\t\t *  \n\t\t *  \n\t\t *  @param  {Frequency} note     The note to trigger.\n\t\t *  @param  {Time} [time=now]     When the note should start.\n\t\t *  @param  {number} [velocity=1] velocity The velocity scaler \n\t\t *                                determines how \"loud\" the note \n\t\t *                                will be triggered.\n\t\t *  @returns {Tone.Monophonic} this\n\t\t *  @example\n\t\t * synth.triggerAttack(\"C4\");\n\t\t *  @example\n\t\t * //trigger the note a half second from now at half velocity\n\t\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t\t */\n\t    Tone.Monophonic.prototype.triggerAttack = function (note, time, velocity) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._triggerEnvelopeAttack(time, velocity);\n\t        this.setNote(note, time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of the envelope\n\t\t *  @param  {Time} [time=now] If no time is given, the release happens immediatly\n\t\t *  @returns {Tone.Monophonic} this\n\t\t *  @example\n\t\t * synth.triggerRelease();\n\t\t */\n\t    Tone.Monophonic.prototype.triggerRelease = function (time) {\n\t        if (this.isUndef(time)) {\n\t            time = this.now() + this.blockTime;\n\t        } else {\n\t            time = this.toSeconds(time);\n\t        }\n\t        this._triggerEnvelopeRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  override this method with the actual method\n\t\t *  @abstract\n\t\t *  @private\n\t\t */\n\t    Tone.Monophonic.prototype._triggerEnvelopeAttack = function () {\n\t    };\n\t    /**\n\t\t *  override this method with the actual method\n\t\t *  @abstract\n\t\t *  @private\n\t\t */\n\t    Tone.Monophonic.prototype._triggerEnvelopeRelease = function () {\n\t    };\n\t    /**\n\t\t *  Set the note at the given time. If no time is given, the note\n\t\t *  will set immediately. \n\t\t *  @param {Frequency} note The note to change to.\n\t\t *  @param  {Time} [time=now] The time when the note should be set. \n\t\t *  @returns {Tone.Monophonic} this\n\t\t * @example\n\t\t * //change to F#6 in one quarter note from now.\n\t\t * synth.setNote(\"F#6\", \"+4n\");\n\t\t * @example\n\t\t * //change to Bb4 right now\n\t\t * synth.setNote(\"Bb4\");\n\t\t */\n\t    Tone.Monophonic.prototype.setNote = function (note, time) {\n\t        time = this.toSeconds(time);\n\t        if (this.portamento > 0) {\n\t            var currentNote = this.frequency.value;\n\t            this.frequency.setValueAtTime(currentNote, time);\n\t            var portTime = this.toSeconds(this.portamento);\n\t            this.frequency.exponentialRampToValueAtTime(note, time + portTime);\n\t        } else {\n\t            this.frequency.setValueAtTime(note, time);\n\t        }\n\t        return this;\n\t    };\n\t    return Tone.Monophonic;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Synth is composed simply of a Tone.OmniOscillator\n\t\t *          routed through a Tone.AmplitudeEnvelope. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1-1_0YW2Z1J2EPI36P8fNCMcZG7N1w1GZluPs4og4evo/pub?w=1163&h=231\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.Synth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.Synth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.Synth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this.oscillator.frequency;\n\t        /**\n\t\t\t *  The detune control.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this.oscillator.detune;\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the oscillators to the output\n\t        this.oscillator.chain(this.envelope, this.output);\n\t        //start the oscillators\n\t        this.oscillator.start();\n\t        this._readOnly([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.Synth, Tone.Monophonic);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Synth.defaults = {\n\t        'oscillator': { 'type': 'triangle' },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0.3,\n\t            'release': 1\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelope\n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {number} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.Synth} this\n\t\t *  @private\n\t\t */\n\t    Tone.Synth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelope\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.Synth} this\n\t\t *  @private\n\t\t */\n\t    Tone.Synth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Synth} this\n\t\t */\n\t    Tone.Synth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.Synth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  AMSynth uses the output of one Tone.Synth to modulate the\n\t\t *          amplitude of another Tone.Synth. The harmonicity (the ratio between\n\t\t *          the two signals) affects the timbre of the output signal greatly.\n\t\t *          Read more about Amplitude Modulation Synthesis on \n\t\t *          [SoundOnSound](http://www.soundonsound.com/sos/mar00/articles/synthsecrets.htm).\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1TQu8Ed4iFr1YTLKpB3U1_hur-UwBrh5gdBXc8BxfGKw/pub?w=1009&h=457\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                            see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.AMSynth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"4n\");\n\t\t */\n\t    Tone.AMSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.AMSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The carrier voice. \n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Synth();\n\t        this._carrier.volume.value = -10;\n\t        /**\n\t\t\t *  The carrier's oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.oscillator = this._carrier.oscillator;\n\t        /**\n\t\t\t *  The carrier's envelope\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = this._carrier.envelope.set(options.envelope);\n\t        /**\n\t\t\t *  The modulator voice. \n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Synth();\n\t        this._modulator.volume.value = -10;\n\t        /**\n\t\t\t *  The modulator's oscillator which is applied\n\t\t\t *  to the amplitude of the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulation = this._modulator.oscillator.set(options.modulation);\n\t        /**\n\t\t\t *  The modulator's envelope\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);\n\t        /**\n\t\t\t *  The frequency.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  convert the -1,1 output to 0,1\n\t\t\t *  @type {Tone.AudioToGain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationScale = new Tone.AudioToGain();\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain();\n\t        //control the two voices frequency\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.detune.fan(this._carrier.detune, this._modulator.detune);\n\t        this._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t        this._carrier.chain(this._modulationNode, this.output);\n\t        this._readOnly([\n\t            'frequency',\n\t            'harmonicity',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.AMSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.AMSynth.defaults = {\n\t        'harmonicity': 3,\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.01,\n\t            'decay': 0.01,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        },\n\t        'modulation': { 'type': 'square' },\n\t        'modulationEnvelope': {\n\t            'attack': 0.5,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t *  trigger the attack portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will occur\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note\n\t\t *  @private\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the port glide\n\t        time = this.toSeconds(time);\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.modulationEnvelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  trigger the release portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @private\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        this.modulationEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.AMSynth} this\n\t\t */\n\t    Tone.AMSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'harmonicity',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._modulationScale.dispose();\n\t        this._modulationScale = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.oscillator = null;\n\t        this.envelope = null;\n\t        this.modulationEnvelope = null;\n\t        this.modulation = null;\n\t        return this;\n\t    };\n\t    return Tone.AMSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.MonoSynth is composed of one oscillator, one filter, and two envelopes.\n\t\t *          The amplitude of the Tone.Oscillator and the cutoff frequency of the \n\t\t *          Tone.Filter are controlled by Tone.Envelopes. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n\t\t *          \n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.MonoSynth({\n\t\t * \t\"oscillator\" : {\n\t\t * \t\t\"type\" : \"square\"\n\t\t *  },\n\t\t *  \"envelope\" : {\n\t\t *  \t\"attack\" : 0.1\n\t\t *  }\n\t\t * }).toMaster();\n\t\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t\t */\n\t    Tone.MonoSynth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.MonoSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = this.oscillator.frequency;\n\t        /**\n\t\t\t *  The detune control.\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = this.oscillator.detune;\n\t        /**\n\t\t\t *  The filter.\n\t\t\t *  @type {Tone.Filter}\n\t\t\t */\n\t        this.filter = new Tone.Filter(options.filter);\n\t        /**\n\t\t\t *  The filter envelope.\n\t\t\t *  @type {Tone.FrequencyEnvelope}\n\t\t\t */\n\t        this.filterEnvelope = new Tone.FrequencyEnvelope(options.filterEnvelope);\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the oscillators to the output\n\t        this.oscillator.chain(this.filter, this.envelope, this.output);\n\t        //start the oscillators\n\t        this.oscillator.start();\n\t        //connect the filter envelope\n\t        this.filterEnvelope.connect(this.filter.frequency);\n\t        this._readOnly([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'filter',\n\t            'filterEnvelope',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MonoSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MonoSynth.defaults = {\n\t        'frequency': 'C4',\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'square' },\n\t        'filter': {\n\t            'Q': 6,\n\t            'type': 'lowpass',\n\t            'rolloff': -24\n\t        },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0.9,\n\t            'release': 1\n\t        },\n\t        'filterEnvelope': {\n\t            'attack': 0.06,\n\t            'decay': 0.2,\n\t            'sustain': 0.5,\n\t            'release': 2,\n\t            'baseFrequency': 200,\n\t            'octaves': 7,\n\t            'exponent': 2\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelope\n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.MonoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.filterEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelope\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.MonoSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        this.filterEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.MonoSynth} this\n\t\t */\n\t    Tone.MonoSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'frequency',\n\t            'detune',\n\t            'filter',\n\t            'filterEnvelope',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this.filterEnvelope.dispose();\n\t        this.filterEnvelope = null;\n\t        this.filter.dispose();\n\t        this.filter = null;\n\t        this.frequency = null;\n\t        this.detune = null;\n\t        return this;\n\t    };\n\t    return Tone.MonoSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.DuoSynth is a monophonic synth composed of two \n\t\t *          MonoSynths run in parallel with control over the \n\t\t *          frequency ratio between the two voices and vibrato effect.\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1bL4GXvfRMMlqS7XyBm9CjL9KJPSUKbcdBNpqOlkFLxk/pub?w=1012&h=448\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var duoSynth = new Tone.DuoSynth().toMaster();\n\t\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t\t */\n\t    Tone.DuoSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.DuoSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  the first voice\n\t\t\t *  @type {Tone.MonoSynth}\n\t\t\t */\n\t        this.voice0 = new Tone.MonoSynth(options.voice0);\n\t        this.voice0.volume.value = -10;\n\t        /**\n\t\t\t *  the second voice\n\t\t\t *  @type {Tone.MonoSynth}\n\t\t\t */\n\t        this.voice1 = new Tone.MonoSynth(options.voice1);\n\t        this.voice1.volume.value = -10;\n\t        /**\n\t\t\t *  The vibrato LFO. \n\t\t\t *  @type {Tone.LFO}\n\t\t\t *  @private\n\t\t\t */\n\t        this._vibrato = new Tone.LFO(options.vibratoRate, -50, 50);\n\t        this._vibrato.start();\n\t        /**\n\t\t\t * the vibrato frequency\n\t\t\t * @type {Frequency}\n\t\t\t * @signal\n\t\t\t */\n\t        this.vibratoRate = this._vibrato.frequency;\n\t        /**\n\t\t\t *  the vibrato gain\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._vibratoGain = new Tone.Gain(options.vibratoAmount, Tone.Type.Positive);\n\t        /**\n\t\t\t * The amount of vibrato\n\t\t\t * @type {Positive}\n\t\t\t * @signal\n\t\t\t */\n\t        this.vibratoAmount = this._vibratoGain.gain;\n\t        /**\n\t\t\t *  the frequency control\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * duoSynth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        //control the two voices frequency\n\t        this.frequency.connect(this.voice0.frequency);\n\t        this.frequency.chain(this.harmonicity, this.voice1.frequency);\n\t        this._vibrato.connect(this._vibratoGain);\n\t        this._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\t        this.voice0.connect(this.output);\n\t        this.voice1.connect(this.output);\n\t        this._readOnly([\n\t            'voice0',\n\t            'voice1',\n\t            'frequency',\n\t            'vibratoAmount',\n\t            'vibratoRate'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.DuoSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.DuoSynth.defaults = {\n\t        'vibratoAmount': 0.5,\n\t        'vibratoRate': 5,\n\t        'harmonicity': 1.5,\n\t        'voice0': {\n\t            'volume': -10,\n\t            'portamento': 0,\n\t            'oscillator': { 'type': 'sine' },\n\t            'filterEnvelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            },\n\t            'envelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            }\n\t        },\n\t        'voice1': {\n\t            'volume': -10,\n\t            'portamento': 0,\n\t            'oscillator': { 'type': 'sine' },\n\t            'filterEnvelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            },\n\t            'envelope': {\n\t                'attack': 0.01,\n\t                'decay': 0,\n\t                'sustain': 1,\n\t                'release': 0.5\n\t            }\n\t        }\n\t    };\n\t    /**\n\t\t *  start the attack portion of the envelopes\n\t\t *  \n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {NormalRange} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.DuoSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.voice0.envelope.triggerAttack(time, velocity);\n\t        this.voice1.envelope.triggerAttack(time, velocity);\n\t        this.voice0.filterEnvelope.triggerAttack(time);\n\t        this.voice1.filterEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  start the release portion of the envelopes\n\t\t *  \n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.DuoSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        this.voice0.triggerRelease(time);\n\t        this.voice1.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.DuoSynth} this\n\t\t */\n\t    Tone.DuoSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'voice0',\n\t            'voice1',\n\t            'frequency',\n\t            'vibratoAmount',\n\t            'vibratoRate'\n\t        ]);\n\t        this.voice0.dispose();\n\t        this.voice0 = null;\n\t        this.voice1.dispose();\n\t        this.voice1 = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._vibratoGain.dispose();\n\t        this._vibratoGain = null;\n\t        this._vibrato = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this.vibratoAmount.dispose();\n\t        this.vibratoAmount = null;\n\t        this.vibratoRate = null;\n\t        return this;\n\t    };\n\t    return Tone.DuoSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n\t\t *          the frequency of a second Tone.Synth. A lot of spectral content \n\t\t *          can be explored using the modulationIndex parameter. Read more about\n\t\t *          frequency modulation synthesis on [SoundOnSound](http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm).\n\t\t *          <img src=\"https://docs.google.com/drawings/d/1h0PUDZXPgi4Ikx6bVT6oncrYPLluFKy7lj53puxj-DM/pub?w=902&h=462\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Monophonic}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var fmSynth = new Tone.FMSynth().toMaster();\n\t\t * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t\t */\n\t    Tone.FMSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.FMSynth.defaults);\n\t        Tone.Monophonic.call(this, options);\n\t        /**\n\t\t\t *  The carrier voice.\n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._carrier = new Tone.Synth(options.carrier);\n\t        this._carrier.volume.value = -10;\n\t        /**\n\t\t\t *  The carrier's oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.oscillator = this._carrier.oscillator;\n\t        /**\n\t\t\t *  The carrier's envelope\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.envelope = this._carrier.envelope.set(options.envelope);\n\t        /**\n\t\t\t *  The modulator voice.\n\t\t\t *  @type {Tone.Synth}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulator = new Tone.Synth(options.modulator);\n\t        this._modulator.volume.value = -10;\n\t        /**\n\t\t\t *  The modulator's oscillator which is applied\n\t\t\t *  to the amplitude of the oscillator\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulation = this._modulator.oscillator.set(options.modulation);\n\t        /**\n\t\t\t *  The modulator's envelope\n\t\t\t *  @type {Tone.Oscillator}\n\t\t\t */\n\t        this.modulationEnvelope = this._modulator.envelope.set(options.modulationEnvelope);\n\t        /**\n\t\t\t *  The frequency control.\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(440, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        /**\n\t\t\t *  Harmonicity is the ratio between the two voices. A harmonicity of\n\t\t\t *  1 is no change. Harmonicity = 2 means a change of an octave. \n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t *  @example\n\t\t\t * //pitch voice1 an octave below voice0\n\t\t\t * synth.harmonicity.value = 0.5;\n\t\t\t */\n\t        this.harmonicity = new Tone.Multiply(options.harmonicity);\n\t        this.harmonicity.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  The modulation index which essentially the depth or amount of the modulation. It is the \n\t\t\t *  ratio of the frequency of the modulating signal (mf) to the amplitude of the \n\t\t\t *  modulating signal (ma) -- as in ma/mf. \n\t\t\t *\t@type {Positive}\n\t\t\t *\t@signal\n\t\t\t */\n\t        this.modulationIndex = new Tone.Multiply(options.modulationIndex);\n\t        this.modulationIndex.units = Tone.Type.Positive;\n\t        /**\n\t\t\t *  the node where the modulation happens\n\t\t\t *  @type {GainNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._modulationNode = new Tone.Gain(0);\n\t        //control the two voices frequency\n\t        this.frequency.connect(this._carrier.frequency);\n\t        this.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t        this.frequency.chain(this.modulationIndex, this._modulationNode);\n\t        this.detune.fan(this._carrier.detune, this._modulator.detune);\n\t        this._modulator.connect(this._modulationNode.gain);\n\t        this._modulationNode.connect(this._carrier.frequency);\n\t        this._carrier.connect(this.output);\n\t        this._readOnly([\n\t            'frequency',\n\t            'harmonicity',\n\t            'modulationIndex',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.FMSynth, Tone.Monophonic);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.FMSynth.defaults = {\n\t        'harmonicity': 3,\n\t        'modulationIndex': 10,\n\t        'detune': 0,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.01,\n\t            'decay': 0.01,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        },\n\t        'modulation': { 'type': 'square' },\n\t        'modulationEnvelope': {\n\t            'attack': 0.5,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.5\n\t        }\n\t    };\n\t    /**\n\t\t * \ttrigger the attack portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will occur\n\t\t *  @param {number} [velocity=1] the velocity of the note\n\t\t *  @returns {Tone.FMSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.FMSynth.prototype._triggerEnvelopeAttack = function (time, velocity) {\n\t        time = this.toSeconds(time);\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        this.modulationEnvelope.triggerAttack(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  trigger the release portion of the note\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @returns {Tone.FMSynth} this\n\t\t *  @private\n\t\t */\n\t    Tone.FMSynth.prototype._triggerEnvelopeRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        this.modulationEnvelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.FMSynth} this\n\t\t */\n\t    Tone.FMSynth.prototype.dispose = function () {\n\t        Tone.Monophonic.prototype.dispose.call(this);\n\t        this._writable([\n\t            'frequency',\n\t            'harmonicity',\n\t            'modulationIndex',\n\t            'oscillator',\n\t            'envelope',\n\t            'modulation',\n\t            'modulationEnvelope',\n\t            'detune'\n\t        ]);\n\t        this._carrier.dispose();\n\t        this._carrier = null;\n\t        this._modulator.dispose();\n\t        this._modulator = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.modulationIndex.dispose();\n\t        this.modulationIndex = null;\n\t        this.harmonicity.dispose();\n\t        this.harmonicity = null;\n\t        this._modulationNode.dispose();\n\t        this._modulationNode = null;\n\t        this.oscillator = null;\n\t        this.envelope = null;\n\t        this.modulationEnvelope = null;\n\t        this.modulation = null;\n\t        return this;\n\t    };\n\t    return Tone.FMSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.MembraneSynth makes kick and tom sounds using a single oscillator\n\t\t *          with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n\t\t *          is routed through a Tone.AmplitudeEnvelope to the output. The drum\n\t\t *          quality of the sound comes from the frequency envelope applied\n\t\t *          during during Tone.MembraneSynth.triggerAttack(note). The frequency\n\t\t *          envelope starts at <code>note * .octaves</code> and ramps to \n\t\t *          <code>note</code> over the duration of <code>.pitchDecay</code>. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t *  @example\n\t\t * var synth = new Tone.MembraneSynth().toMaster();\n\t\t * synth.triggerAttackRelease(\"C2\", \"8n\");\n\t\t */\n\t    Tone.MembraneSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.MembraneSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The oscillator.\n\t\t\t *  @type {Tone.OmniOscillator}\n\t\t\t */\n\t        this.oscillator = new Tone.OmniOscillator(options.oscillator).start();\n\t        /**\n\t\t\t *  The amplitude envelope.\n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        /**\n\t\t\t *  The number of octaves the pitch envelope ramps.\n\t\t\t *  @type {Positive}\n\t\t\t */\n\t        this.octaves = options.octaves;\n\t        /**\n\t\t\t *  The amount of time the frequency envelope takes. \n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.pitchDecay = options.pitchDecay;\n\t        this.oscillator.chain(this.envelope, this.output);\n\t        this._readOnly([\n\t            'oscillator',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.MembraneSynth, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MembraneSynth.defaults = {\n\t        'pitchDecay': 0.05,\n\t        'octaves': 10,\n\t        'oscillator': { 'type': 'sine' },\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 0.4,\n\t            'sustain': 0.01,\n\t            'release': 1.4,\n\t            'attackCurve': 'exponential'\n\t        }\n\t    };\n\t    /**\n\t\t *  Trigger the note at the given time with the given velocity. \n\t\t *  \n\t\t *  @param  {Frequency} note     the note\n\t\t *  @param  {Time} [time=now]     the time, if not given is now\n\t\t *  @param  {number} [velocity=1] velocity defaults to 1\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t *  @example\n\t\t *  kick.triggerAttack(60);\n\t\t */\n\t    Tone.MembraneSynth.prototype.triggerAttack = function (note, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        note = this.toFrequency(note);\n\t        var maxNote = note * this.octaves;\n\t        this.oscillator.frequency.setValueAtTime(maxNote, time);\n\t        this.oscillator.frequency.exponentialRampToValueAtTime(note, time + this.toSeconds(this.pitchDecay));\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of the note.\n\t\t *  \n\t\t *  @param  {Time} [time=now] the time the note will release\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t */\n\t    Tone.MembraneSynth.prototype.triggerRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.MembraneSynth} this\n\t\t */\n\t    Tone.MembraneSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'oscillator',\n\t            'envelope'\n\t        ]);\n\t        this.oscillator.dispose();\n\t        this.oscillator = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.MembraneSynth;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  Inharmonic ratio of frequencies based on the Roland TR-808\n\t\t *  Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n\t\t *  @private\n\t\t *  @static\n\t\t *  @type {Array}\n\t\t */\n\t    var inharmRatios = [\n\t        1,\n\t        1.483,\n\t        1.932,\n\t        2.546,\n\t        2.63,\n\t        3.897\n\t    ];\n\t    /**\n\t\t *  @class  A highly inharmonic and spectrally complex source with a highpass filter\n\t\t *          and amplitude envelope which is good for making metalophone sounds. Based\n\t\t *          on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n\t\t *          Inspiration from [Sound on Sound](http://www.soundonsound.com/sos/jul02/articles/synthsecrets0702.asp).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] The options availble for the synth\n\t\t *                             see defaults below\n\t\t */\n\t    Tone.MetalSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.MetalSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The frequency of the cymbal\n\t\t\t *  @type  {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.frequency = new Tone.Signal(options.frequency, Tone.Type.Frequency);\n\t        /**\n\t\t\t *  The array of FMOscillators\n\t\t\t *  @type  {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._oscillators = [];\n\t        /**\n\t\t\t *  The frequency multipliers\n\t\t\t *  @type {Array}\n\t\t\t *  @private\n\t\t\t */\n\t        this._freqMultipliers = [];\n\t        /**\n\t\t\t *  The amplitude for the body\n\t\t\t *  @type {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._amplitue = new Tone.Gain(0).connect(this.output);\n\t        /**\n\t\t\t *  highpass the output\n\t\t\t *  @type {Tone.Filter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._highpass = new Tone.Filter({\n\t            'type': 'highpass',\n\t            'Q': -3.0102999566398125\n\t        }).connect(this._amplitue);\n\t        /**\n\t\t\t *  The number of octaves the highpass\n\t\t\t *  filter frequency ramps\n\t\t\t *  @type {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._octaves = options.octaves;\n\t        /**\n\t\t\t *  Scale the body envelope\n\t\t\t *  for the bandpass\n\t\t\t *  @type {Tone.Scale}\n\t\t\t *  @private\n\t\t\t */\n\t        this._filterFreqScaler = new Tone.Scale(options.resonance, 7000);\n\t        /**\n\t\t\t *  The envelope which is connected both to the \n\t\t\t *  amplitude and highpass filter's cutoff frequency\n\t\t\t *  @type  {Tone.Envelope}\n\t\t\t */\n\t        this.envelope = new Tone.Envelope({\n\t            'attack': options.envelope.attack,\n\t            'attackCurve': 'linear',\n\t            'decay': options.envelope.decay,\n\t            'sustain': 0,\n\t            'release': options.envelope.release\n\t        }).chain(this._filterFreqScaler, this._highpass.frequency);\n\t        this.envelope.connect(this._amplitue.gain);\n\t        for (var i = 0; i < inharmRatios.length; i++) {\n\t            var osc = new Tone.FMOscillator({\n\t                'type': 'square',\n\t                'modulationType': 'square',\n\t                'harmonicity': options.harmonicity,\n\t                'modulationIndex': options.modulationIndex\n\t            });\n\t            osc.connect(this._highpass).start(0);\n\t            this._oscillators[i] = osc;\n\t            var mult = new Tone.Multiply(inharmRatios[i]);\n\t            this._freqMultipliers[i] = mult;\n\t            this.frequency.chain(mult, osc.frequency);\n\t        }\n\t        //set the octaves\n\t        this.octaves = options.octaves;\n\t    };\n\t    Tone.extend(Tone.MetalSynth, Tone.Instrument);\n\t    /**\n\t\t *  default values\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.MetalSynth.defaults = {\n\t        'frequency': 200,\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 1.4,\n\t            'release': 0.2\n\t        },\n\t        'harmonicity': 5.1,\n\t        'modulationIndex': 32,\n\t        'resonance': 4000,\n\t        'octaves': 1.5\n\t    };\n\t    /**\n\t\t *  Trigger the attack.\n\t\t *  @param  {Time}  time      When the attack should be triggered.\n\t\t *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerAttack = function (time, vel) {\n\t        time = this.toSeconds(time);\n\t        vel = this.defaultArg(vel, 1);\n\t        this.envelope.triggerAttack(time, vel);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release of the envelope.\n\t\t *  @param  {Time}  time      When the release should be triggered.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and release of the envelope after the given \n\t\t *  duration. \n\t\t *  @param  {Time}  duration  The duration before triggering the release\n\t\t *  @param  {Time}  time      When the attack should be triggered.\n\t\t *  @param  {NormalRange=1}  velocity  The velocity that the envelope should be triggered at.\n\t\t *  @return  {Tone.MetalSynth}  this\n\t\t */\n\t    Tone.MetalSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The modulationIndex of the oscillators which make up the source.\n\t\t *  see Tone.FMOscillator.modulationIndex\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Positive}\n\t\t *  @name  modulationIndex\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'modulationIndex', {\n\t        get: function () {\n\t            return this._oscillators[0].modulationIndex.value;\n\t        },\n\t        set: function (val) {\n\t            for (var i = 0; i < this._oscillators.length; i++) {\n\t                this._oscillators[i].modulationIndex.value = val;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The harmonicity of the oscillators which make up the source.\n\t\t *  see Tone.FMOscillator.harmonicity\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Positive}\n\t\t *  @name  harmonicity\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'harmonicity', {\n\t        get: function () {\n\t            return this._oscillators[0].harmonicity.value;\n\t        },\n\t        set: function (val) {\n\t            for (var i = 0; i < this._oscillators.length; i++) {\n\t                this._oscillators[i].harmonicity.value = val;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The frequency of the highpass filter attached to the envelope\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Frequency}\n\t\t *  @name  resonance\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'resonance', {\n\t        get: function () {\n\t            return this._filterFreqScaler.min;\n\t        },\n\t        set: function (val) {\n\t            this._filterFreqScaler.min = val;\n\t            this.octaves = this._octaves;\n\t        }\n\t    });\n\t    /**\n\t\t *  The number of octaves above the \"resonance\" frequency\n\t\t *  that the filter ramps during the attack/decay envelope\n\t\t *  @memberOf Tone.MetalSynth#\n\t\t *  @type {Number}\n\t\t *  @name  octaves\n\t\t */\n\t    Object.defineProperty(Tone.MetalSynth.prototype, 'octaves', {\n\t        get: function () {\n\t            return this._octaves;\n\t        },\n\t        set: function (octs) {\n\t            this._octaves = octs;\n\t            this._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, octs);\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up\n\t\t *  @returns {Tone.MetalSynth} this\n\t\t */\n\t    Tone.MetalSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        for (var i = 0; i < this._oscillators.length; i++) {\n\t            this._oscillators[i].dispose();\n\t            this._freqMultipliers[i].dispose();\n\t        }\n\t        this._oscillators = null;\n\t        this._freqMultipliers = null;\n\t        this.frequency.dispose();\n\t        this.frequency = null;\n\t        this._filterFreqScaler.dispose();\n\t        this._filterFreqScaler = null;\n\t        this._amplitue.dispose();\n\t        this._amplitue = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        this._highpass.dispose();\n\t        this._highpass = null;\n\t    };\n\t    return Tone.MetalSynth;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  BufferSource polyfill\n\t\t */\n\t    if (window.AudioBufferSourceNode && !AudioBufferSourceNode.prototype.start) {\n\t        AudioBufferSourceNode.prototype.start = AudioBufferSourceNode.prototype.noteGrainOn;\n\t        AudioBufferSourceNode.prototype.stop = AudioBufferSourceNode.prototype.noteOff;\n\t    }\n\t    /**\n\t\t *  @class Wrapper around the native BufferSourceNode.\n\t\t *  @param  {AudioBuffer|Tone.Buffer}  buffer   The buffer to play\n\t\t *  @param  {Function}  onended  The callback to invoke when the \n\t\t *                               buffer is done playing.\n\t\t */\n\t    Tone.BufferSource = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'buffer',\n\t            'onended'\n\t        ], Tone.BufferSource.defaults);\n\t        /**\n\t\t\t *  The callback to invoke after the \n\t\t\t *  buffer source is done playing. \n\t\t\t *  @type  {Function}\n\t\t\t */\n\t        this.onended = options.onended;\n\t        /**\n\t\t\t *  The time that the buffer was started.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._startTime = -1;\n\t        /**\n\t\t\t *  The time that the buffer is scheduled to stop.\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stopTime = -1;\n\t        /**\n\t\t\t *  The gain node which envelopes the BufferSource\n\t\t\t *  @type  {Tone.Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gainNode = this.output = new Tone.Gain();\n\t        /**\n\t\t\t *  The buffer source\n\t\t\t *  @type  {AudioBufferSourceNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._source = this.context.createBufferSource();\n\t        this._source.connect(this._gainNode);\n\t        /**\n\t\t\t *  The playbackRate of the buffer\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.playbackRate = new Tone.Param(this._source.playbackRate, Tone.Type.Positive);\n\t        /**\n\t\t\t *  The fadeIn time of the amplitude envelope.\n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.fadeIn = options.fadeIn;\n\t        /**\n\t\t\t *  The fadeOut time of the amplitude envelope.\n\t\t\t *  @type {Time}\n\t\t\t */\n\t        this.fadeOut = options.fadeOut;\n\t        /**\n\t\t\t *  The value that the buffer ramps to\n\t\t\t *  @type {Gain}\n\t\t\t *  @private\n\t\t\t */\n\t        this._gain = 1;\n\t        /**\n\t\t\t * The onended timeout\n\t\t\t * @type {Number}\n\t\t\t * @private\n\t\t\t */\n\t        this._onendedTimeout = -1;\n\t        //set the buffer initially\n\t        if (!this.isUndef(options.buffer)) {\n\t            this.buffer = options.buffer;\n\t        }\n\t        this.loop = options.loop;\n\t    };\n\t    Tone.extend(Tone.BufferSource);\n\t    /**\n\t\t *  The defaults\n\t\t *  @const\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.BufferSource.defaults = {\n\t        'onended': Tone.noOp,\n\t        'fadeIn': 0,\n\t        'fadeOut': 0\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, either \"started\" or \"stopped\".\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.BufferSource#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'state', {\n\t        get: function () {\n\t            var now = this.now();\n\t            if (this._startTime !== -1 && now >= this._startTime && now < this._stopTime) {\n\t                return Tone.State.Started;\n\t            } else {\n\t                return Tone.State.Stopped;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  Start the buffer\n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @param  {Gain}  [gain=1]  The gain to play the buffer back at.\n\t\t *  @param  {Time=}  fadeInTime  The optional fadeIn ramp time.\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.start = function (time, offset, duration, gain, fadeInTime) {\n\t        if (this._startTime !== -1) {\n\t            throw new Error('Tone.BufferSource: can only be started once.');\n\t        }\n\t        if (this.buffer) {\n\t            time = this.toSeconds(time);\n\t            //if it's a loop the default offset is the loopstart point\n\t            if (this.loop) {\n\t                offset = this.defaultArg(offset, this.loopStart);\n\t            } else {\n\t                //otherwise the default offset is 0\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toSeconds(offset);\n\t            //the values in seconds\n\t            time = this.toSeconds(time);\n\t            this._source.start(time, offset);\n\t            gain = this.defaultArg(gain, 1);\n\t            this._gain = gain;\n\t            //the fadeIn time\n\t            if (this.isUndef(fadeInTime)) {\n\t                fadeInTime = this.toSeconds(this.fadeIn);\n\t            } else {\n\t                fadeInTime = this.toSeconds(fadeInTime);\n\t            }\n\t            if (fadeInTime > 0) {\n\t                this._gainNode.gain.setValueAtTime(0, time);\n\t                this._gainNode.gain.linearRampToValueAtTime(this._gain, time + fadeInTime);\n\t            } else {\n\t                this._gainNode.gain.setValueAtTime(gain, time);\n\t            }\n\t            this._startTime = time + fadeInTime;\n\t            if (!this.isUndef(duration)) {\n\t                duration = this.defaultArg(duration, this.buffer.duration - offset);\n\t                duration = this.toSeconds(duration);\n\t                this.stop(time + duration + fadeInTime, fadeInTime);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the buffer. Optionally add a ramp time to fade the \n\t\t *  buffer out. \n\t\t *  @param  {Time=}  time         The time the buffer should stop.\n\t\t *  @param  {Time=}  fadeOutTime  How long the gain should fade out for\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.stop = function (time, fadeOutTime) {\n\t        if (this.buffer) {\n\t            time = this.toSeconds(time);\n\t            //the fadeOut time\n\t            if (this.isUndef(fadeOutTime)) {\n\t                fadeOutTime = this.toSeconds(this.fadeOut);\n\t            } else {\n\t                fadeOutTime = this.toSeconds(fadeOutTime);\n\t            }\n\t            this._stopTime = time + fadeOutTime;\n\t            //cancel the end curve\n\t            this._gainNode.gain.cancelScheduledValues(this._startTime + this.sampleTime);\n\t            //set a new one\n\t            if (fadeOutTime > 0) {\n\t                this._gainNode.gain.setValueAtTime(this._gain, time);\n\t                this._gainNode.gain.linearRampToValueAtTime(0, time + fadeOutTime);\n\t                time += fadeOutTime;\n\t            } else {\n\t                this._gainNode.gain.setValueAtTime(0, time);\n\t            }\n\t            // fix for safari bug and old FF\n\t            if (!this.isNumber(this._source.playbackState) || this._source.playbackState === 2) {\n\t                this._source.stop(time);\n\t            }\n\t            clearTimeout(this._onendedTimeout);\n\t            this._onendedTimeout = setTimeout(this._onended.bind(this), (this._stopTime - this.now()) * 1000);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Internal callback when the buffer is ended. \n\t\t *  Invokes `onended` and disposes the node.\n\t\t *  @private\n\t\t */\n\t    Tone.BufferSource.prototype._onended = function () {\n\t        this.onended(this);\n\t        this.dispose();\n\t    };\n\t    /**\n\t\t * If loop is true, the loop will start at this position. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._source.loopStart;\n\t        },\n\t        set: function (loopStart) {\n\t            this._source.loopStart = this.toSeconds(loopStart);\n\t        }\n\t    });\n\t    /**\n\t\t * If loop is true, the loop will end at this position.\n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._source.loopEnd;\n\t        },\n\t        set: function (loopEnd) {\n\t            this._source.loopEnd = this.toSeconds(loopEnd);\n\t        }\n\t    });\n\t    /**\n\t\t * The audio buffer belonging to the player. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {AudioBuffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'buffer', {\n\t        get: function () {\n\t            if (this._source) {\n\t                return this._source.buffer;\n\t            } else {\n\t                return null;\n\t            }\n\t        },\n\t        set: function (buffer) {\n\t            if (buffer instanceof Tone.Buffer) {\n\t                this._source.buffer = buffer.get();\n\t            } else {\n\t                this._source.buffer = buffer;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * If the buffer should loop once it's over. \n\t\t * @memberOf Tone.BufferSource#\n\t\t * @type {boolean}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.BufferSource.prototype, 'loop', {\n\t        get: function () {\n\t            return this._source.loop;\n\t        },\n\t        set: function (loop) {\n\t            this._source.loop = loop;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.BufferSource}  this\n\t\t */\n\t    Tone.BufferSource.prototype.dispose = function () {\n\t        this.onended = null;\n\t        if (this._source) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        if (this._gainNode) {\n\t            this._gainNode.dispose();\n\t            this._gainNode = null;\n\t        }\n\t        this._startTime = -1;\n\t        this.playbackRate = null;\n\t        this.output = null;\n\t        clearTimeout(this._onendedTimeout);\n\t        return this;\n\t    };\n\t    return Tone.BufferSource;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Noise is a noise generator. It uses looped noise buffers to save on performance.\n\t\t *          Tone.Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n\t\t *          colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Source}\n\t\t *  @param {string} type the noise type (white|pink|brown)\n\t\t *  @example\n\t\t * //initialize the noise and start\n\t\t * var noise = new Tone.Noise(\"pink\").start();\n\t\t * \n\t\t * //make an autofilter to shape the noise\n\t\t * var autoFilter = new Tone.AutoFilter({\n\t\t * \t\"frequency\" : \"8m\", \n\t\t * \t\"min\" : 800, \n\t\t * \t\"max\" : 15000\n\t\t * }).connect(Tone.Master);\n\t\t * \n\t\t * //connect the noise\n\t\t * noise.connect(autoFilter);\n\t\t * //start the autofilter LFO\n\t\t * autoFilter.start()\n\t\t */\n\t    Tone.Noise = function () {\n\t        var options = this.optionsObject(arguments, ['type'], Tone.Noise.defaults);\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {AudioBufferSourceNode}\n\t\t\t */\n\t        this._source = null;\n\t        /**\n\t\t\t *  the buffer\n\t\t\t *  @private\n\t\t\t *  @type {AudioBuffer}\n\t\t\t */\n\t        this._type = options.type;\n\t        /**\n\t\t\t *  The playback rate of the noise. Affects\n\t\t\t *  the \"frequency\" of the noise.\n\t\t\t *  @type {Positive}\n\t\t\t *  @signal\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t    };\n\t    Tone.extend(Tone.Noise, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Noise.defaults = {\n\t        'type': 'white',\n\t        'playbackRate': 1\n\t    };\n\t    /**\n\t\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\". \n\t\t * @memberOf Tone.Noise#\n\t\t * @type {string}\n\t\t * @name type\n\t\t * @example\n\t\t * noise.type = \"white\";\n\t\t */\n\t    Object.defineProperty(Tone.Noise.prototype, 'type', {\n\t        get: function () {\n\t            return this._type;\n\t        },\n\t        set: function (type) {\n\t            if (this._type !== type) {\n\t                if (type in _noiseBuffers) {\n\t                    this._type = type;\n\t                    //if it's playing, stop and restart it\n\t                    if (this.state === Tone.State.Started) {\n\t                        var now = this.now() + this.blockTime;\n\t                        this._stop(now);\n\t                        this._start(now);\n\t                    }\n\t                } else {\n\t                    throw new TypeError('Tone.Noise: invalid type: ' + type);\n\t                }\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  The playback rate of the noise. Affects\n\t\t *  the \"frequency\" of the noise.\n\t\t *  @type {Positive}\n\t\t *  @signal\n\t\t */\n\t    Object.defineProperty(Tone.Noise.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            if (this._source) {\n\t                this._source.playbackRate.value = rate;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t *  internal start method\n\t\t *\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.Noise.prototype._start = function (time) {\n\t        var buffer = _noiseBuffers[this._type];\n\t        this._source = new Tone.BufferSource(buffer).connect(this.output);\n\t        this._source.loop = true;\n\t        this._source.playbackRate.value = this._playbackRate;\n\t        this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t    };\n\t    /**\n\t\t *  internal stop method\n\t\t *\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.Noise.prototype._stop = function (time) {\n\t        if (this._source) {\n\t            this._source.stop(this.toSeconds(time));\n\t            this._source = null;\n\t        }\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Noise} this\n\t\t */\n\t    Tone.Noise.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._source !== null) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    // THE BUFFERS\n\t    ///////////////////////////////////////////////////////////////////////////\n\t    //Noise buffer stats\n\t    var bufferLength = 44100 * 5;\n\t    var channels = 2;\n\t    /**\n\t\t *\tthe noise arrays. only generated once on init\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Array}\n\t\t *  borrowed heavily from https://github.com/zacharydenton/noise.js \n\t\t *  (c) 2013 Zach Denton (MIT)\n\t\t */\n\t    var _noiseArrays = {\n\t        'pink': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                var b0, b1, b2, b3, b4, b5, b6;\n\t                b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    var white = Math.random() * 2 - 1;\n\t                    b0 = 0.99886 * b0 + white * 0.0555179;\n\t                    b1 = 0.99332 * b1 + white * 0.0750759;\n\t                    b2 = 0.969 * b2 + white * 0.153852;\n\t                    b3 = 0.8665 * b3 + white * 0.3104856;\n\t                    b4 = 0.55 * b4 + white * 0.5329522;\n\t                    b5 = -0.7616 * b5 - white * 0.016898;\n\t                    channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t                    channel[i] *= 0.11;\n\t                    // (roughly) compensate for gain\n\t                    b6 = white * 0.115926;\n\t                }\n\t            }\n\t            return buffer;\n\t        }(),\n\t        'brown': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                var lastOut = 0;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    var white = Math.random() * 2 - 1;\n\t                    channel[i] = (lastOut + 0.02 * white) / 1.02;\n\t                    lastOut = channel[i];\n\t                    channel[i] *= 3.5;    // (roughly) compensate for gain\n\t                }\n\t            }\n\t            return buffer;\n\t        }(),\n\t        'white': function () {\n\t            var buffer = [];\n\t            for (var channelNum = 0; channelNum < channels; channelNum++) {\n\t                var channel = new Float32Array(bufferLength);\n\t                buffer[channelNum] = channel;\n\t                for (var i = 0; i < bufferLength; i++) {\n\t                    channel[i] = Math.random() * 2 - 1;\n\t                }\n\t            }\n\t            return buffer;\n\t        }()\n\t    };\n\t    /**\n\t\t *\tstatic noise buffers\n\t\t *  @static\n\t\t *  @private\n\t\t *  @type {Tone.Buffer}\n\t\t */\n\t    var _noiseBuffers = {};\n\t    //create the Tone.Buffers\n\t    function createBuffers() {\n\t        for (var type in _noiseArrays) {\n\t            _noiseBuffers[type] = new Tone.Buffer().fromArray(_noiseArrays[type]);\n\t        }\n\t    }\n\t    createBuffers();\n\t    Tone.Context.on('init', createBuffers);\n\t    return Tone.Noise;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.NoiseSynth is composed of a noise generator (Tone.Noise), one filter (Tone.Filter), \n\t\t *          and two envelopes (Tone.Envelop). One envelope controls the amplitude\n\t\t *          of the noise and the other is controls the cutoff frequency of the filter. \n\t\t *          <img src=\"https://docs.google.com/drawings/d/1rqzuX9rBlhT50MRvD2TKml9bnZhcZmzXF1rf_o7vdnE/pub?w=918&h=242\">\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] the options available for the synth \n\t\t *                          see defaults below\n\t\t * @example\n\t\t * var noiseSynth = new Tone.NoiseSynth().toMaster();\n\t\t * noiseSynth.triggerAttackRelease(\"8n\");\n\t\t */\n\t    Tone.NoiseSynth = function (options) {\n\t        //get the defaults\n\t        options = this.defaultArg(options, Tone.NoiseSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The noise source.\n\t\t\t *  @type {Tone.Noise}\n\t\t\t *  @example\n\t\t\t * noiseSynth.set(\"noise.type\", \"brown\");\n\t\t\t */\n\t        this.noise = new Tone.Noise();\n\t        /**\n\t\t\t *  The amplitude envelope. \n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        //connect the noise to the output\n\t        this.noise.chain(this.envelope, this.output);\n\t        //start the noise\n\t        this.noise.start();\n\t        this._readOnly([\n\t            'noise',\n\t            'envelope'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.NoiseSynth, Tone.Instrument);\n\t    /**\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.NoiseSynth.defaults = {\n\t        'noise': { 'type': 'white' },\n\t        'envelope': {\n\t            'attack': 0.005,\n\t            'decay': 0.1,\n\t            'sustain': 0\n\t        }\n\t    };\n\t    /**\n\t\t *  Start the attack portion of the envelopes. Unlike other \n\t\t *  instruments, Tone.NoiseSynth doesn't have a note. \n\t\t *  @param {Time} [time=now] the time the attack should start\n\t\t *  @param {number} [velocity=1] the velocity of the note (0-1)\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t *  @example\n\t\t * noiseSynth.triggerAttack();\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerAttack = function (time, velocity) {\n\t        //the envelopes\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the release portion of the envelopes.\n\t\t *  @param {Time} [time=now] the time the release should start\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerRelease = function (time) {\n\t        this.envelope.triggerRelease(time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and then the release. \n\t\t *  @param  {Time} duration the duration of the note\n\t\t *  @param  {Time} [time=now]     the time of the attack\n\t\t *  @param  {number} [velocity=1] the velocity\n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.triggerAttackRelease = function (duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        duration = this.toSeconds(duration);\n\t        this.triggerAttack(time, velocity);\n\t        this.triggerRelease(time + duration);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.NoiseSynth} this\n\t\t */\n\t    Tone.NoiseSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'noise',\n\t            'envelope'\n\t        ]);\n\t        this.noise.dispose();\n\t        this.noise = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.NoiseSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Karplus-String string synthesis. Often out of tune. \n\t\t *         Will change when the AudioWorkerNode is available across\n\t\t *         browsers. \n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {Object} [options] see the defaults\n\t\t *  @example\n\t\t * var plucky = new Tone.PluckSynth().toMaster();\n\t\t * plucky.triggerAttack(\"C4\");\n\t\t */\n\t    Tone.PluckSynth = function (options) {\n\t        options = this.defaultArg(options, Tone.PluckSynth.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  @type {Tone.Noise}\n\t\t\t *  @private\n\t\t\t */\n\t        this._noise = new Tone.Noise('pink');\n\t        /**\n\t\t\t *  The amount of noise at the attack. \n\t\t\t *  Nominal range of [0.1, 20]\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this.attackNoise = options.attackNoise;\n\t        /**\n\t\t\t *  the LFCF\n\t\t\t *  @type {Tone.LowpassCombFilter}\n\t\t\t *  @private\n\t\t\t */\n\t        this._lfcf = new Tone.LowpassCombFilter({\n\t            'resonance': options.resonance,\n\t            'dampening': options.dampening\n\t        });\n\t        /**\n\t\t\t *  The resonance control. \n\t\t\t *  @type {NormalRange}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.resonance = this._lfcf.resonance;\n\t        /**\n\t\t\t *  The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t\t\t *  @type {Frequency}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.dampening = this._lfcf.dampening;\n\t        //connections\n\t        this._noise.connect(this._lfcf);\n\t        this._lfcf.connect(this.output);\n\t        this._readOnly([\n\t            'resonance',\n\t            'dampening'\n\t        ]);\n\t    };\n\t    Tone.extend(Tone.PluckSynth, Tone.Instrument);\n\t    /**\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PluckSynth.defaults = {\n\t        'attackNoise': 1,\n\t        'dampening': 4000,\n\t        'resonance': 0.9\n\t    };\n\t    /**\n\t\t *  Trigger the note. \n\t\t *  @param {Frequency} note The note to trigger.\n\t\t *  @param {Time} [time=now] When the note should be triggered.\n\t\t *  @returns {Tone.PluckSynth} this\n\t\t */\n\t    Tone.PluckSynth.prototype.triggerAttack = function (note, time) {\n\t        note = this.toFrequency(note);\n\t        time = this.toSeconds(time);\n\t        var delayAmount = 1 / note;\n\t        this._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t        this._noise.start(time);\n\t        this._noise.stop(time + delayAmount * this.attackNoise);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up. \n\t\t *  @returns {Tone.PluckSynth} this\n\t\t */\n\t    Tone.PluckSynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._noise.dispose();\n\t        this._lfcf.dispose();\n\t        this._noise = null;\n\t        this._lfcf = null;\n\t        this._writable([\n\t            'resonance',\n\t            'dampening'\n\t        ]);\n\t        this.dampening = null;\n\t        this.resonance = null;\n\t        return this;\n\t    };\n\t    return Tone.PluckSynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.PolySynth handles voice creation and allocation for any\n\t\t *          instruments passed in as the second paramter. PolySynth is \n\t\t *          not a synthesizer by itself, it merely manages voices of \n\t\t *          one of the other types of synths, allowing any of the \n\t\t *          monophonic synthesizers to be polyphonic. \n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {number|Object} [polyphony=4] The number of voices to create\n\t\t *  @param {function} [voice=Tone.Synth] The constructor of the voices\n\t\t *                                            uses Tone.Synth by default. \n\t\t *  @example\n\t\t * //a polysynth composed of 6 Voices of Synth\n\t\t * var synth = new Tone.PolySynth(6, Tone.Synth).toMaster();\n\t\t * //set the attributes using the set interface\n\t\t * synth.set(\"detune\", -1200);\n\t\t * //play a chord\n\t\t * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], \"4n\");\n\t\t */\n\t    Tone.PolySynth = function () {\n\t        Tone.Instrument.call(this);\n\t        var options = this.optionsObject(arguments, [\n\t            'polyphony',\n\t            'voice'\n\t        ], Tone.PolySynth.defaults);\n\t        options = this.defaultArg(options, Tone.Instrument.defaults);\n\t        //max polyphony\n\t        options.polyphony = Math.min(Tone.PolySynth.MAX_POLYPHONY, options.polyphony);\n\t        /**\n\t\t\t *  the array of voices\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this.voices = new Array(options.polyphony);\n\t        /**\n\t\t\t *  The queue of voices with data about last trigger\n\t\t\t *  and the triggered note\n\t\t\t *  @private\n\t\t\t *  @type {Array}\n\t\t\t */\n\t        this._triggers = new Array(options.polyphony);\n\t        /**\n\t\t\t *  The detune in cents\n\t\t\t *  @type {Cents}\n\t\t\t *  @signal\n\t\t\t */\n\t        this.detune = new Tone.Signal(options.detune, Tone.Type.Cents);\n\t        this._readOnly('detune');\n\t        //create the voices\n\t        for (var i = 0; i < options.polyphony; i++) {\n\t            var v = new options.voice(arguments[2], arguments[3]);\n\t            this.voices[i] = v;\n\t            v.connect(this.output);\n\t            if (v.hasOwnProperty('detune')) {\n\t                this.detune.connect(v.detune);\n\t            }\n\t            this._triggers[i] = {\n\t                release: -1,\n\t                note: null,\n\t                voice: v\n\t            };\n\t        }\n\t        //set the volume initially\n\t        this.volume.value = options.volume;\n\t    };\n\t    Tone.extend(Tone.PolySynth, Tone.Instrument);\n\t    /**\n\t\t *  the defaults\n\t\t *  @const\n\t\t *  @static\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.PolySynth.defaults = {\n\t        'polyphony': 4,\n\t        'volume': 0,\n\t        'detune': 0,\n\t        'voice': Tone.Synth\n\t    };\n\t    /**\n\t\t *  Trigger the attack portion of the note\n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} [time=now]  The start time of the note.\n\t\t *  @param {number} [velocity=1] The velocity of the note.\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * //trigger a chord immediately with a velocity of 0.2\n\t\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"], undefined, 0.2);\n\t\t */\n\t    Tone.PolySynth.prototype.triggerAttack = function (notes, time, velocity) {\n\t        if (!Array.isArray(notes)) {\n\t            notes = [notes];\n\t        }\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < notes.length; i++) {\n\t            var val = notes[i];\n\t            //trigger the oldest voice\n\t            var oldest = this._triggers[0];\n\t            var oldestIndex = 0;\n\t            for (var j = 1; j < this._triggers.length; j++) {\n\t                if (this._triggers[j].release < oldest.release) {\n\t                    oldest = this._triggers[j];\n\t                    oldestIndex = j;\n\t                }\n\t            }\n\t            oldest.release = Infinity;\n\t            oldest.note = JSON.stringify(val);\n\t            oldest.voice.triggerAttack(val, time, velocity);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and release after the specified duration\n\t\t *  \n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} duration the duration of the note\n\t\t *  @param  {Time} [time=now]     if no time is given, defaults to now\n\t\t *  @param  {number} [velocity=1] the velocity of the attack (0-1)\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * //trigger a chord for a duration of a half note \n\t\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], \"2n\");\n\t\t *  @example\n\t\t * //can pass in an array of durations as well\n\t\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"C5\"], [\"2n\", \"4n\", \"4n\"]);\n\t\t */\n\t    Tone.PolySynth.prototype.triggerAttackRelease = function (notes, duration, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        this.triggerAttack(notes, time, velocity);\n\t        if (this.isArray(duration) && this.isArray(notes)) {\n\t            for (var i = 0; i < notes.length; i++) {\n\t                var d = duration[Math.min(i, duration.length - 1)];\n\t                this.triggerRelease(notes[i], time + this.toSeconds(d));\n\t            }\n\t        } else {\n\t            this.triggerRelease(notes, time + this.toSeconds(duration));\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the release of the note. Unlike monophonic instruments, \n\t\t *  a note (or array of notes) needs to be passed in as the first argument.\n\t\t *  @param  {Frequency|Array} notes The notes to play. Accepts a single\n\t\t *                                  Frequency or an array of frequencies.\n\t\t *  @param  {Time} [time=now]  When the release will be triggered. \n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * poly.triggerRelease([\"Ab3\", \"C4\", \"F5\"], \"+2n\");\n\t\t */\n\t    Tone.PolySynth.prototype.triggerRelease = function (notes, time) {\n\t        if (!Array.isArray(notes)) {\n\t            notes = [notes];\n\t        }\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < notes.length; i++) {\n\t            //get the voice\n\t            var stringified = JSON.stringify(notes[i]);\n\t            for (var v = 0; v < this._triggers.length; v++) {\n\t                var desc = this._triggers[v];\n\t                if (desc.note === stringified && desc.release > time) {\n\t                    desc.voice.triggerRelease(time);\n\t                    desc.release = time;\n\t                }\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set a member/attribute of the voices. \n\t\t *  @param {Object|string} params\n\t\t *  @param {number=} value\n\t\t *  @param {Time=} rampTime\n\t\t *  @returns {Tone.PolySynth} this\n\t\t *  @example\n\t\t * poly.set({\n\t\t * \t\"filter\" : {\n\t\t * \t\t\"type\" : \"highpass\"\n\t\t * \t},\n\t\t * \t\"envelope\" : {\n\t\t * \t\t\"attack\" : 0.25\n\t\t * \t}\n\t\t * });\n\t\t */\n\t    Tone.PolySynth.prototype.set = function (params, value, rampTime) {\n\t        for (var i = 0; i < this.voices.length; i++) {\n\t            this.voices[i].set(params, value, rampTime);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Get the synth's attributes. Given no arguments get\n\t\t *  will return all available object properties and their corresponding\n\t\t *  values. Pass in a single attribute to retrieve or an array\n\t\t *  of attributes. The attribute strings can also include a \".\"\n\t\t *  to access deeper properties.\n\t\t *  @param {Array=} params the parameters to get, otherwise will return \n\t\t *  \t\t\t\t\t   all available.\n\t\t */\n\t    Tone.PolySynth.prototype.get = function (params) {\n\t        return this.voices[0].get(params);\n\t    };\n\t    /**\n\t\t *  Trigger the release portion of all the currently active voices.\n\t\t *  @param {Time} [time=now] When the notes should be released.\n\t\t *  @return {Tone.PolySynth} this\n\t\t */\n\t    Tone.PolySynth.prototype.releaseAll = function (time) {\n\t        time = this.toSeconds(time);\n\t        for (var i = 0; i < this._triggers.length; i++) {\n\t            var desc = this._triggers[i];\n\t            if (desc.release > time) {\n\t                desc.release = time;\n\t                desc.voice.triggerRelease(time);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.PolySynth} this\n\t\t */\n\t    Tone.PolySynth.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        for (var i = 0; i < this.voices.length; i++) {\n\t            this.voices[i].dispose();\n\t            this.voices[i] = null;\n\t        }\n\t        this._writable('detune');\n\t        this.detune.dispose();\n\t        this.detune = null;\n\t        this.voices = null;\n\t        this._triggers = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  The maximum number of notes that can be allocated \n\t\t *  to a polysynth. \n\t\t *  @type  {Number}\n\t\t *  @static\n\t\t */\n\t    Tone.PolySynth.MAX_POLYPHONY = 20;\n\t    return Tone.PolySynth;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.Player is an audio file player with start, loop, and stop functions.\n\t\t *  \n\t\t *  @constructor\n\t\t *  @extends {Tone.Source} \n\t\t *  @param {string|AudioBuffer} url Either the AudioBuffer or the url from\n\t\t *                                  which to load the AudioBuffer\n\t\t *  @param {function=} onload The function to invoke when the buffer is loaded. \n\t\t *                            Recommended to use Tone.Buffer.on('load') instead.\n\t\t *  @example\n\t\t * var player = new Tone.Player(\"./path/to/sample.mp3\").toMaster();\n\t\t * //play as soon as the buffer is loaded\n\t\t * player.autostart = true;\n\t\t */\n\t    Tone.Player = function (url) {\n\t        var options;\n\t        if (url instanceof Tone.Buffer) {\n\t            url = url.get();\n\t            options = Tone.Player.defaults;\n\t        } else {\n\t            options = this.optionsObject(arguments, [\n\t                'url',\n\t                'onload'\n\t            ], Tone.Player.defaults);\n\t        }\n\t        Tone.Source.call(this, options);\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {AudioBufferSourceNode}\n\t\t\t */\n\t        this._source = null;\n\t        /**\n\t\t\t *  If the file should play as soon\n\t\t\t *  as the buffer is loaded. \n\t\t\t *  @type {boolean}\n\t\t\t *  @example\n\t\t\t * //will play as soon as it's loaded\n\t\t\t * var player = new Tone.Player({\n\t\t\t * \t\"url\" : \"./path/to/sample.mp3\",\n\t\t\t * \t\"autostart\" : true,\n\t\t\t * }).toMaster();\n\t\t\t */\n\t        this.autostart = options.autostart;\n\t        /**\n\t\t\t *  the buffer\n\t\t\t *  @private\n\t\t\t *  @type {Tone.Buffer}\n\t\t\t */\n\t        this._buffer = new Tone.Buffer({\n\t            'url': options.url,\n\t            'onload': this._onload.bind(this, options.onload),\n\t            'reverse': options.reverse\n\t        });\n\t        if (url instanceof AudioBuffer) {\n\t            this._buffer.set(url);\n\t        }\n\t        /**\n\t\t\t *  if the buffer should loop once it's over\n\t\t\t *  @type {boolean}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loop = options.loop;\n\t        /**\n\t\t\t *  if 'loop' is true, the loop will start at this position\n\t\t\t *  @type {Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = options.loopStart;\n\t        /**\n\t\t\t *  if 'loop' is true, the loop will end at this position\n\t\t\t *  @type {Time}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = options.loopEnd;\n\t        /**\n\t\t\t *  the playback rate\n\t\t\t *  @private\n\t\t\t *  @type {number}\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  Enabling retrigger will allow a player to be restarted\n\t\t\t *  before the the previous 'start' is done playing. Otherwise, \n\t\t\t *  successive calls to Tone.Player.start will only start\n\t\t\t *  the sample if it had played all the way through. \n\t\t\t *  @type {boolean}\n\t\t\t */\n\t        this.retrigger = options.retrigger;\n\t    };\n\t    Tone.extend(Tone.Player, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.Player.defaults = {\n\t        'onload': Tone.noOp,\n\t        'playbackRate': 1,\n\t        'loop': false,\n\t        'autostart': false,\n\t        'loopStart': 0,\n\t        'loopEnd': 0,\n\t        'retrigger': false,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Load the audio file as an audio buffer.\n\t\t *  Decodes the audio asynchronously and invokes\n\t\t *  the callback once the audio buffer loads. \n\t\t *  Note: this does not need to be called if a url\n\t\t *  was passed in to the constructor. Only use this\n\t\t *  if you want to manually load a new url. \n\t\t * @param {string} url The url of the buffer to load.\n\t\t *                     Filetype support depends on the\n\t\t *                     browser.\n\t\t *  @param  {function=} callback The function to invoke once\n\t\t *                               the sample is loaded.\n\t\t *  @returns {Promise}\n\t\t */\n\t    Tone.Player.prototype.load = function (url, callback) {\n\t        return this._buffer.load(url, this._onload.bind(this, callback));\n\t    };\n\t    /**\n\t\t * Internal callback when the buffer is loaded.\n\t\t * @private\n\t\t */\n\t    Tone.Player.prototype._onload = function (callback) {\n\t        callback = this.defaultArg(callback, Tone.noOp);\n\t        callback(this);\n\t        if (this.autostart) {\n\t            this.start();\n\t        }\n\t    };\n\t    /**\n\t\t *  Play the buffer at the given startTime. Optionally add an offset\n\t\t *  and/or duration which will play the buffer from a position\n\t\t *  within the buffer for the given duration. \n\t\t *  \n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @returns {Tone.Player} this\n\t\t *  @memberOf Tone.Player#\n\t\t *  @method start\n\t\t *  @name start\n\t\t */\n\t    /**\n\t\t *  Internal start method\n\t\t *  @private\n\t\t */\n\t    Tone.Player.prototype._start = function (startTime, offset, duration) {\n\t        if (this._buffer.loaded) {\n\t            //if it's a loop the default offset is the loopstart point\n\t            if (this._loop) {\n\t                offset = this.defaultArg(offset, this._loopStart);\n\t            } else {\n\t                //otherwise the default offset is 0\n\t                offset = this.defaultArg(offset, 0);\n\t            }\n\t            offset = this.toSeconds(offset);\n\t            //make sure it has a positive duration\n\t            duration = this.defaultArg(duration, Math.max(this._buffer.duration - offset, 0));\n\t            duration = this.toSeconds(duration);\n\t            //the values in seconds\n\t            startTime = this.toSeconds(startTime);\n\t            //make the source\n\t            this._source = this.context.createBufferSource();\n\t            this._source.buffer = this._buffer.get();\n\t            //set the looping properties\n\t            if (this._loop) {\n\t                this._source.loop = this._loop;\n\t                this._source.loopStart = this.toSeconds(this._loopStart);\n\t                this._source.loopEnd = this.toSeconds(this._loopEnd);\n\t            } else if (!this._synced) {\n\t                //if it's not looping, set the state change at the end of the sample\n\t                this._state.setStateAtTime(Tone.State.Stopped, startTime + duration);\n\t            }\n\t            //and other properties\n\t            this._source.playbackRate.value = this._playbackRate;\n\t            this._source.connect(this.output);\n\t            //start it\n\t            if (this._loop) {\n\t                //modify the offset if it's greater than the loop time\n\t                var loopEnd = this._source.loopEnd || this._buffer.duration;\n\t                var loopStart = this._source.loopStart;\n\t                var loopDuration = loopEnd - loopStart;\n\t                if (offset > loopEnd) {\n\t                    //move the offset back\n\t                    while (offset > loopEnd) {\n\t                        offset -= loopDuration;\n\t                    }\n\t                }\n\t                this._source.start(startTime, offset);\n\t            } else {\n\t                this._source.start(startTime, offset, duration);\n\t            }\n\t        } else {\n\t            throw Error('Tone.Player: tried to start Player before the buffer was loaded');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop playback.\n\t\t *  @private\n\t\t *  @param  {Time} [time=now]\n\t\t *  @returns {Tone.Player} this\n\t\t */\n\t    Tone.Player.prototype._stop = function (time) {\n\t        if (this._source) {\n\t            this._source.stop(this.toSeconds(time));\n\t            this._source = null;\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Seek to a specific time in the player's buffer. If the \n\t\t *  source is no longer playing at that time, it will stop.\n\t\t *  If you seek to a time that \n\t\t *  @param {Time} offset The time to seek to.\n\t\t *  @param {Time=} time The time for the seek event to occur.\n\t\t *  @return {Tone.Player} this\n\t\t *  @example\n\t\t * source.start(0.2);\n\t\t * source.stop(0.4);\n\t\t */\n\t    Tone.Player.prototype.seek = function (offset, time) {\n\t        time = this.toSeconds(time);\n\t        if (this._state.getValueAtTime(time) === Tone.State.Started) {\n\t            offset = this.toSeconds(offset);\n\t            // if it's currently playing, stop it\n\t            this._stop(time);\n\t            //restart it at the given time\n\t            this._start(time, offset);\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Set the loop start and end. Will only loop if loop is \n\t\t *  set to true. \n\t\t *  @param {Time} loopStart The loop end time\n\t\t *  @param {Time} loopEnd The loop end time\n\t\t *  @returns {Tone.Player} this\n\t\t *  @example\n\t\t * //loop 0.1 seconds of the file. \n\t\t * player.setLoopPoints(0.2, 0.3);\n\t\t * player.loop = true;\n\t\t */\n\t    Tone.Player.prototype.setLoopPoints = function (loopStart, loopEnd) {\n\t        this.loopStart = loopStart;\n\t        this.loopEnd = loopEnd;\n\t        return this;\n\t    };\n\t    /**\n\t\t * If loop is true, the loop will start at this position. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._loopStart;\n\t        },\n\t        set: function (loopStart) {\n\t            this._loopStart = loopStart;\n\t            if (this._source) {\n\t                this._source.loopStart = this.toSeconds(loopStart);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * If loop is true, the loop will end at this position.\n\t\t * @memberOf Tone.Player#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._loopEnd;\n\t        },\n\t        set: function (loopEnd) {\n\t            this._loopEnd = loopEnd;\n\t            if (this._source) {\n\t                this._source.loopEnd = this.toSeconds(loopEnd);\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The audio buffer belonging to the player. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {Tone.Buffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'buffer', {\n\t        get: function () {\n\t            return this._buffer;\n\t        },\n\t        set: function (buffer) {\n\t            this._buffer.set(buffer);\n\t        }\n\t    });\n\t    /**\n\t\t * If the buffer should loop once it's over. \n\t\t * @memberOf Tone.Player#\n\t\t * @type {boolean}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'loop', {\n\t        get: function () {\n\t            return this._loop;\n\t        },\n\t        set: function (loop) {\n\t            this._loop = loop;\n\t            if (this._source) {\n\t                this._source.loop = loop;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The playback speed. 1 is normal speed. This is not a signal because\n\t\t * Safari and iOS currently don't support playbackRate as a signal.\n\t\t * @memberOf Tone.Player#\n\t\t * @type {number}\n\t\t * @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            if (this._source) {\n\t                this._source.playbackRate.value = rate;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.Player#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Player.prototype, 'reverse', {\n\t        get: function () {\n\t            return this._buffer.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this._buffer.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t *  Dispose and disconnect.\n\t\t *  @return {Tone.Player} this\n\t\t */\n\t    Tone.Player.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        if (this._source !== null) {\n\t            this._source.disconnect();\n\t            this._source = null;\n\t        }\n\t        this._buffer.dispose();\n\t        this._buffer = null;\n\t        return this;\n\t    };\n\t    return Tone.Player;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Sampler wraps Tone.Player in an AmplitudeEnvelope.\n\t\t *\n\t\t *  @constructor\n\t\t *  @extends {Tone.Instrument}\n\t\t *  @param {String} url the url of the audio file\n\t\t *  @param {Function=} onload The callback to invoke when the sample is loaded.\n\t\t *  @example\n\t\t * var sampler = new Sampler(\"./audio/casio/A1.mp3\", function(){\n\t\t * \t//repitch the sample down a half step\n\t\t * \tsampler.triggerAttack(-1);\n\t\t * }).toMaster();\n\t\t */\n\t    Tone.Sampler = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.Sampler.defaults);\n\t        Tone.Instrument.call(this, options);\n\t        /**\n\t\t\t *  The sample player.\n\t\t\t *  @type {Tone.Player}\n\t\t\t */\n\t        this.player = new Tone.Player(options.url, options.onload);\n\t        this.player.retrigger = true;\n\t        /**\n\t\t\t *  The amplitude envelope. \n\t\t\t *  @type {Tone.AmplitudeEnvelope}\n\t\t\t */\n\t        this.envelope = new Tone.AmplitudeEnvelope(options.envelope);\n\t        this.player.chain(this.envelope, this.output);\n\t        this._readOnly([\n\t            'player',\n\t            'envelope'\n\t        ]);\n\t        this.loop = options.loop;\n\t        this.reverse = options.reverse;\n\t    };\n\t    Tone.extend(Tone.Sampler, Tone.Instrument);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t */\n\t    Tone.Sampler.defaults = {\n\t        'onload': Tone.noOp,\n\t        'loop': false,\n\t        'reverse': false,\n\t        'envelope': {\n\t            'attack': 0.001,\n\t            'decay': 0,\n\t            'sustain': 1,\n\t            'release': 0.1\n\t        }\n\t    };\n\t    /**\n\t\t *  Trigger the start of the sample. \n\t\t *  @param {Interval} [pitch=0] The amount the sample should\n\t\t *                              be repitched. \n\t\t *  @param {Time} [time=now] The time when the sample should start\n\t\t *  @param {NormalRange} [velocity=1] The velocity of the note\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * sampler.triggerAttack(0, \"+0.1\", 0.5);\n\t\t */\n\t    Tone.Sampler.prototype.triggerAttack = function (pitch, time, velocity) {\n\t        time = this.toSeconds(time);\n\t        pitch = this.defaultArg(pitch, 0);\n\t        this.player.playbackRate = this.intervalToFrequencyRatio(pitch);\n\t        this.player.start(time);\n\t        this.envelope.triggerAttack(time, velocity);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start the release portion of the sample. Will stop the sample once the \n\t\t *  envelope has fully released. \n\t\t *  \n\t\t *  @param {Time} [time=now] The time when the note should release\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * sampler.triggerRelease();\n\t\t */\n\t    Tone.Sampler.prototype.triggerRelease = function (time) {\n\t        time = this.toSeconds(time);\n\t        this.envelope.triggerRelease(time);\n\t        this.player.stop(this.toSeconds(this.envelope.release) + time);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Trigger the attack and then the release after the duration. \n\t\t *  @param  {Interval} interval     The interval in half-steps that the\n\t\t *                                  sample should be pitch shifted.\n\t\t *  @param  {Time} duration How long the note should be held for before\n\t\t *                          triggering the release.\n\t\t *  @param {Time} [time=now]  When the note should be triggered.\n\t\t *  @param  {NormalRange} [velocity=1] The velocity the note should be triggered at.\n\t\t *  @returns {Tone.Sampler} this\n\t\t *  @example\n\t\t * //trigger the unpitched note for the duration of an 8th note\n\t\t * synth.triggerAttackRelease(0, \"8n\");\n\t\t *  @memberOf Tone.Sampler#\n\t\t *  @name triggerAttackRelease\n\t\t *  @method triggerAttackRelease\n\t\t */\n\t    /**\n\t\t * If the output sample should loop or not.\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {number|string}\n\t\t * @name loop\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'loop', {\n\t        get: function () {\n\t            return this.player.loop;\n\t        },\n\t        set: function (loop) {\n\t            this.player.loop = loop;\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'reverse', {\n\t        get: function () {\n\t            return this.player.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this.player.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t * The buffer to play.\n\t\t * @memberOf Tone.Sampler#\n\t\t * @type {Tone.Buffer}\n\t\t * @name buffer\n\t\t */\n\t    Object.defineProperty(Tone.Sampler.prototype, 'buffer', {\n\t        get: function () {\n\t            return this.player.buffer;\n\t        },\n\t        set: function (buff) {\n\t            this.player.buffer = buff;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @returns {Tone.Sampler} this\n\t\t */\n\t    Tone.Sampler.prototype.dispose = function () {\n\t        Tone.Instrument.prototype.dispose.call(this);\n\t        this._writable([\n\t            'player',\n\t            'envelope'\n\t        ]);\n\t        this.player.dispose();\n\t        this.player = null;\n\t        this.envelope.dispose();\n\t        this.envelope = null;\n\t        return this;\n\t    };\n\t    return Tone.Sampler;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Maps a NormalRange [0, 1] to an AudioRange [-1, 1]. \n\t\t *         See also Tone.AudioToGain. \n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @example\n\t\t * var g2a = new Tone.GainToAudio();\n\t\t */\n\t    Tone.GainToAudio = function () {\n\t        /**\n\t\t\t *  @type {WaveShaperNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._norm = this.input = this.output = new Tone.WaveShaper(function (x) {\n\t            return Math.abs(x) * 2 - 1;\n\t        });\n\t    };\n\t    Tone.extend(Tone.GainToAudio, Tone.SignalBase);\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.GainToAudio} this\n\t\t */\n\t    Tone.GainToAudio.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._norm.dispose();\n\t        this._norm = null;\n\t        return this;\n\t    };\n\t    return Tone.GainToAudio;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class Normalize takes an input min and max and maps it linearly to NormalRange [0,1]\n\t\t *\n\t\t *  @extends {Tone.SignalBase}\n\t\t *  @constructor\n\t\t *  @param {number} inputMin the min input value\n\t\t *  @param {number} inputMax the max input value\n\t\t *  @example\n\t\t * var norm = new Tone.Normalize(2, 4);\n\t\t * var sig = new Tone.Signal(3).connect(norm);\n\t\t * //output of norm is 0.5. \n\t\t */\n\t    Tone.Normalize = function (inputMin, inputMax) {\n\t        /**\n\t\t\t *  the min input value\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputMin = this.defaultArg(inputMin, 0);\n\t        /**\n\t\t\t *  the max input value\n\t\t\t *  @type {number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._inputMax = this.defaultArg(inputMax, 1);\n\t        /**\n\t\t\t *  subtract the min from the input\n\t\t\t *  @type {Tone.Add}\n\t\t\t *  @private\n\t\t\t */\n\t        this._sub = this.input = new Tone.Add(0);\n\t        /**\n\t\t\t *  divide by the difference between the input and output\n\t\t\t *  @type {Tone.Multiply}\n\t\t\t *  @private\n\t\t\t */\n\t        this._div = this.output = new Tone.Multiply(1);\n\t        this._sub.connect(this._div);\n\t        this._setRange();\n\t    };\n\t    Tone.extend(Tone.Normalize, Tone.SignalBase);\n\t    /**\n\t\t * The minimum value the input signal will reach.\n\t\t * @memberOf Tone.Normalize#\n\t\t * @type {number}\n\t\t * @name min\n\t\t */\n\t    Object.defineProperty(Tone.Normalize.prototype, 'min', {\n\t        get: function () {\n\t            return this._inputMin;\n\t        },\n\t        set: function (min) {\n\t            this._inputMin = min;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t * The maximum value the input signal will reach.\n\t\t * @memberOf Tone.Normalize#\n\t\t * @type {number}\n\t\t * @name max\n\t\t */\n\t    Object.defineProperty(Tone.Normalize.prototype, 'max', {\n\t        get: function () {\n\t            return this._inputMax;\n\t        },\n\t        set: function (max) {\n\t            this._inputMax = max;\n\t            this._setRange();\n\t        }\n\t    });\n\t    /**\n\t\t *  set the values\n\t\t *  @private\n\t\t */\n\t    Tone.Normalize.prototype._setRange = function () {\n\t        this._sub.value = -this._inputMin;\n\t        this._div.value = 1 / (this._inputMax - this._inputMin);\n\t    };\n\t    /**\n\t\t *  clean up\n\t\t *  @returns {Tone.Normalize} this\n\t\t */\n\t    Tone.Normalize.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._sub.dispose();\n\t        this._sub = null;\n\t        this._div.dispose();\n\t        this._div = null;\n\t        return this;\n\t    };\n\t    return Tone.Normalize;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t *  @class Tone.MultiPlayer is well suited for one-shots, multi-sampled instruments\n\t\t *         or any time you need to play a bunch of audio buffers. \n\t\t *  @param  {Object|Array|Tone.Buffers}  buffers  The buffers which are available\n\t\t *                                                to the MultiPlayer\n\t\t *  @param {Function} onload The callback to invoke when all of the buffers are loaded.\n\t\t *  @extends {Tone}\n\t\t *  @example\n\t\t * var multiPlayer = new MultiPlayer({\n\t\t * \t\"kick\" : \"path/to/kick.mp3\",\n\t\t * \t\"snare\" : \"path/to/snare.mp3\",\n\t\t * }, function(){\n\t\t * \tmultiPlayer.start(\"kick\");\n\t\t * });\n\t\t *  @example\n\t\t * //can also store the values in an array\n\t\t * var multiPlayer = new MultiPlayer([\"path/to/kick.mp3\", \"path/to/snare.mp3\"], \n\t\t * function(){\n\t\t * \t//if an array is passed in, the samples are referenced to by index\n\t\t * \tmultiPlayer.start(1);\n\t\t * });\n\t\t */\n\t    Tone.MultiPlayer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'urls',\n\t            'onload'\n\t        ], Tone.MultiPlayer.defaults);\n\t        if (options.urls instanceof Tone.Buffers) {\n\t            /**\n\t\t\t\t *  All the buffers belonging to the player.\n\t\t\t\t *  @type  {Tone.Buffers}\n\t\t\t\t */\n\t            this.buffers = options.urls;\n\t        } else {\n\t            this.buffers = new Tone.Buffers(options.urls, options.onload);\n\t        }\n\t        /**\n\t\t\t *  Keeps track of the currently playing sources.\n\t\t\t *  @type  {Object}\n\t\t\t *  @private\n\t\t\t */\n\t        this._activeSources = {};\n\t        /**\n\t\t\t *  The fade in envelope which is applied\n\t\t\t *  to the beginning of the BufferSource\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.fadeIn = options.fadeIn;\n\t        /**\n\t\t\t *  The fade out envelope which is applied\n\t\t\t *  to the end of the BufferSource\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.fadeOut = options.fadeOut;\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * source.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        //make the output explicitly stereo\n\t        this._volume.output.output.channelCount = 2;\n\t        this._volume.output.output.channelCountMode = 'explicit';\n\t        //mute initially\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.MultiPlayer, Tone.Source);\n\t    /**\n\t\t *  The defaults\n\t\t *  @type  {Object}\n\t\t */\n\t    Tone.MultiPlayer.defaults = {\n\t        'onload': Tone.noOp,\n\t        'fadeIn': 0,\n\t        'fadeOut': 0\n\t    };\n\t    /**\n\t\t * Make the source from the buffername\n\t\t * @param  {String} bufferName\n\t\t * @return {Tone.BufferSource}\n\t\t * @private\n\t\t */\n\t    Tone.MultiPlayer.prototype._makeSource = function (bufferName) {\n\t        var buffer;\n\t        if (this.isString(bufferName) || this.isNumber(bufferName)) {\n\t            buffer = this.buffers.get(bufferName).get();\n\t        } else if (bufferName instanceof Tone.Buffer) {\n\t            buffer = bufferName.get();\n\t        } else if (bufferName instanceof AudioBuffer) {\n\t            buffer = bufferName;\n\t        }\n\t        var source = new Tone.BufferSource(buffer).connect(this.output);\n\t        if (!this._activeSources.hasOwnProperty(bufferName)) {\n\t            this._activeSources[bufferName] = [];\n\t        }\n\t        this._activeSources[bufferName].push(source);\n\t        return source;\n\t    };\n\t    /**\n\t\t *  Start a buffer by name. The `start` method allows a number of options\n\t\t *  to be passed in such as offset, interval, and gain. This is good for multi-sampled \n\t\t *  instruments and sound sprites where samples are repitched played back at different velocities.\n\t\t *  @param  {String}  bufferName    The name of the buffer to start.\n\t\t *  @param  {Time}  time      When to start the buffer.\n\t\t *  @param  {Time}  [offset=0]    The offset into the buffer to play from.\n\t\t *  @param  {Time=}  duration   How long to play the buffer for.\n\t\t *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.\n\t\t *  @param  {Gain}  [gain=1]      The gain to play the sample at.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.start = function (bufferName, time, offset, duration, pitch, gain) {\n\t        time = this.toSeconds(time);\n\t        var source = this._makeSource(bufferName);\n\t        source.start(time, offset, duration, this.defaultArg(gain, 1), this.fadeIn);\n\t        if (duration) {\n\t            source.stop(time + this.toSeconds(duration), this.fadeOut);\n\t        }\n\t        pitch = this.defaultArg(pitch, 0);\n\t        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Start a looping buffer by name. Similar to `start`, but the buffer\n\t\t *  is looped instead of played straight through. Can still be stopped with `stop`. \n\t\t *  @param  {String}  bufferName    The name of the buffer to start.\n\t\t *  @param  {Time}  time      When to start the buffer.\n\t\t *  @param  {Time}  [offset=0]    The offset into the buffer to play from.\n\t\t *  @param  {Time=}  loopStart   The start of the loop.\n\t\t *  @param  {Time=}  loopEnd\tThe end of the loop.\n\t\t *  @param  {Interval}  [pitch=0]  The interval to repitch the buffer.\n\t\t *  @param  {Gain}  [gain=1]      The gain to play the sample at.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.startLoop = function (bufferName, time, offset, loopStart, loopEnd, pitch, gain) {\n\t        time = this.toSeconds(time);\n\t        var source = this._makeSource(bufferName);\n\t        source.loop = true;\n\t        source.loopStart = this.toSeconds(this.defaultArg(loopStart, 0));\n\t        source.loopEnd = this.toSeconds(this.defaultArg(loopEnd, 0));\n\t        source.start(time, offset, undefined, this.defaultArg(gain, 1), this.fadeIn);\n\t        pitch = this.defaultArg(pitch, 0);\n\t        source.playbackRate.value = this.intervalToFrequencyRatio(pitch);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop the first played instance of the buffer name.\n\t\t *  @param  {String}  bufferName  The buffer to stop.\n\t\t *  @param  {Time=}  time    When to stop the buffer\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.stop = function (bufferName, time) {\n\t        if (this._activeSources[bufferName] && this._activeSources[bufferName].length) {\n\t            time = this.toSeconds(time);\n\t            this._activeSources[bufferName].shift().stop(time, this.fadeOut);\n\t        } else {\n\t            throw new Error('Tone.MultiPlayer: cannot stop a buffer that hasn\\'t been started or is already stopped');\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Stop all currently playing buffers at the given time.\n\t\t *  @param  {Time=}  time  When to stop the buffers.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.stopAll = function (time) {\n\t        time = this.toSeconds(time);\n\t        for (var bufferName in this._activeSources) {\n\t            var sources = this._activeSources[bufferName];\n\t            for (var i = 0; i < sources.length; i++) {\n\t                sources[i].stop(time);\n\t            }\n\t        }\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Add another buffer to the available buffers.\n\t\t *  @param {String} name The name to that the buffer is refered\n\t\t *                       to in start/stop methods. \n\t\t *  @param {String|Tone.Buffer} url The url of the buffer to load\n\t\t *                                  or the buffer.\n\t\t *  @param {Function} callback The function to invoke after the buffer is loaded.\n\t\t */\n\t    Tone.MultiPlayer.prototype.add = function (name, url, callback) {\n\t        this.buffers.add(name, url, callback);\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source. \"started\"\n\t\t *  if there are any buffers playing. \"stopped\" otherwise.\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.MultiPlayer#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.MultiPlayer.prototype, 'state', {\n\t        get: function () {\n\t            return this._activeSources.length > 0 ? Tone.State.Started : Tone.State.Stopped;\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.MultiPlayer#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * source.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.MultiPlayer.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t *  Clean up.\n\t\t *  @return  {Tone.MultiPlayer}  this\n\t\t */\n\t    Tone.MultiPlayer.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this._writable('volume');\n\t        this.volume = null;\n\t        for (var bufferName in this._activeSources) {\n\t            this._activeSources[bufferName].forEach(function (source) {\n\t                source.dispose();\n\t            });\n\t        }\n\t        this.buffers.dispose();\n\t        this.buffers = null;\n\t        this._activeSources = null;\n\t        return this;\n\t    };\n\t    return Tone.MultiPlayer;\n\t});\n\tModule(function (Tone) {\n\t    /**\n\t\t * @class Tone.GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n\t\t *        Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the \n\t\t *        amount of time each small chunk of audio is played for and the overlap is the \n\t\t *        amount of crossfading transition time between successive grains.\n\t\t * @extends {Tone}\n\t\t * @param {String|Tone.Buffer} url\tThe url to load, or the Tone.Buffer to play.\n\t\t * @param {Function=} callback The callback to invoke after the url is loaded.\n\t\t */\n\t    Tone.GrainPlayer = function () {\n\t        var options = this.optionsObject(arguments, [\n\t            'url',\n\t            'onload'\n\t        ], Tone.GrainPlayer.defaults);\n\t        Tone.Source.call(this);\n\t        /**\n\t\t\t *  The audio buffer belonging to the player.\n\t\t\t *  @type  {Tone.Buffer}\n\t\t\t */\n\t        this.buffer = new Tone.Buffer(options.url, options.onload);\n\t        /**\n\t\t\t *  Plays the buffer with a small envelope\n\t\t\t *  @type  {Tone.MultiPlayer}\n\t\t\t *  @private\n\t\t\t */\n\t        this._player = new Tone.MultiPlayer().connect(this.output);\n\t        /**\n\t\t\t *  Create a repeating tick to schedule\n\t\t\t *  the grains.\n\t\t\t *  @type  {Tone.Clock}\n\t\t\t *  @private\n\t\t\t */\n\t        this._clock = new Tone.Clock(this._tick.bind(this), 1);\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopStart = 0;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._loopEnd = 0;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._playbackRate = options.playbackRate;\n\t        /**\n\t\t\t *  @type  {Number}\n\t\t\t *  @private\n\t\t\t */\n\t        this._grainSize = options.grainSize;\n\t        /**\n\t\t\t *  @private\n\t\t\t *  @type {Number}\n\t\t\t */\n\t        this._overlap = options.overlap;\n\t        /**\n\t\t\t *  Adjust the pitch independently of the playbackRate.\n\t\t\t *  @type  {Cents}\n\t\t\t */\n\t        this.detune = options.detune;\n\t        /**\n\t\t\t *  The amount of time randomly added\n\t\t\t *  or subtracted from the grain's offset\n\t\t\t *  @type  {Time}\n\t\t\t */\n\t        this.drift = options.drift;\n\t        //setup\n\t        this.overlap = options.overlap;\n\t        this.loop = options.loop;\n\t        this.playbackRate = options.playbackRate;\n\t        this.grainSize = options.grainSize;\n\t        this.loopStart = options.loopStart;\n\t        this.loopEnd = options.loopEnd;\n\t        this.reverse = options.reverse;\n\t    };\n\t    Tone.extend(Tone.GrainPlayer, Tone.Source);\n\t    /**\n\t\t *  the default parameters\n\t\t *  @static\n\t\t *  @const\n\t\t *  @type {Object}\n\t\t */\n\t    Tone.GrainPlayer.defaults = {\n\t        'onload': Tone.noOp,\n\t        'overlap': 0.1,\n\t        'grainSize': 0.2,\n\t        'drift': 0,\n\t        'playbackRate': 1,\n\t        'detune': 0,\n\t        'loop': false,\n\t        'loopStart': 0,\n\t        'loopEnd': 0,\n\t        'reverse': false\n\t    };\n\t    /**\n\t\t *  Play the buffer at the given startTime. Optionally add an offset\n\t\t *  and/or duration which will play the buffer from a position\n\t\t *  within the buffer for the given duration. \n\t\t *  \n\t\t *  @param  {Time} [startTime=now] When the player should start.\n\t\t *  @param  {Time} [offset=0] The offset from the beginning of the sample\n\t\t *                                 to start at. \n\t\t *  @param  {Time=} duration How long the sample should play. If no duration\n\t\t *                                is given, it will default to the full length \n\t\t *                                of the sample (minus any offset)\n\t\t *  @returns {Tone.GrainPlayer} this\n\t\t *  @memberOf Tone.GrainPlayer#\n\t\t *  @method start\n\t\t *  @name start\n\t\t */\n\t    /**\n\t\t *  Internal start method\n\t\t *  @param {Time} time\n\t\t *  @param {Time} offset\n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._start = function (time, offset, duration) {\n\t        offset = this.defaultArg(offset, 0);\n\t        offset = this.toSeconds(offset);\n\t        time = this.toSeconds(time);\n\t        this._offset = offset;\n\t        this._clock.start(time);\n\t        //unmute the player\n\t        this._player.volume.setValueAtTime(0, time);\n\t        if (duration) {\n\t            this._stop(time + this.toSeconds(duration));\n\t        }\n\t    };\n\t    /**\n\t\t *  Internal start method\n\t\t *  @param {Time} time\n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._stop = function (time) {\n\t        this._clock.stop(time);\n\t        //mute the player\n\t        this._player.volume.cancelScheduledValues(time);\n\t        this._player.volume.setValueAtTime(-Infinity, time);\n\t    };\n\t    /**\n\t\t *  Invoked on each clock tick. scheduled a new\n\t\t *  grain at this time.\n\t\t *  @param  {Time}  time \n\t\t *  @private\n\t\t */\n\t    Tone.GrainPlayer.prototype._tick = function (time) {\n\t        var bufferDuration = this.buffer.duration;\n\t        if (this.loop && this._loopEnd > 0) {\n\t            bufferDuration = this._loopEnd;\n\t        }\n\t        var drift = (Math.random() * 2 - 1) * this.drift;\n\t        var offset = this._offset - this._overlap + drift;\n\t        var detune = this.detune / 100;\n\t        //keep the offset within the limits of the buffer\n\t        offset = Math.max(offset, 0);\n\t        offset = Math.min(offset, bufferDuration);\n\t        var originalFadeIn = this._player.fadeIn;\n\t        if (this.loop && this._offset > bufferDuration) {\n\t            //play the end\n\t            var endSegmentDuration = this._offset - bufferDuration;\n\t            this._player.start(this.buffer, time, offset, endSegmentDuration + this._overlap, detune);\n\t            //and play the beginning \n\t            offset = this._offset % bufferDuration;\n\t            this._offset = this._loopStart;\n\t            this._player.fadeIn = 0;\n\t            this._player.start(this.buffer, time + endSegmentDuration, this._offset, offset + this._overlap, detune);\n\t        } else if (this._offset > bufferDuration) {\n\t            //set the state to stopped. \n\t            this.stop(time);\n\t        } else {\n\t            if (offset === 0) {\n\t                this._player.fadeIn = 0;\n\t            }\n\t            this._player.start(this.buffer, time, offset, this.grainSize + this._overlap, detune);\n\t        }\n\t        this._player.fadeIn = originalFadeIn;\n\t        //increment the offset\n\t        var duration = this._clock._nextTick - time;\n\t        this._offset += duration * this._playbackRate;\n\t    };\n\t    /**\n\t\t *  Jump to a specific time and play it.\n\t\t *  @param  {Time}  offset  The offset to jump to.\n\t\t *  @param {Time=} time When to make the jump.\n\t\t *  @return  {[type]}  [description]\n\t\t */\n\t    Tone.GrainPlayer.prototype.scrub = function (offset, time) {\n\t        this._offset = this.toSeconds(offset);\n\t        this._tick(this.toSeconds(time));\n\t        return this;\n\t    };\n\t    /**\n\t\t * The playback rate of the sample\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Positive}\n\t\t * @name playbackRate\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'playbackRate', {\n\t        get: function () {\n\t            return this._playbackRate;\n\t        },\n\t        set: function (rate) {\n\t            this._playbackRate = rate;\n\t            this.grainSize = this._grainSize;\n\t        }\n\t    });\n\t    /**\n\t\t * The loop start time. \n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name loopStart\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopStart', {\n\t        get: function () {\n\t            return this._loopStart;\n\t        },\n\t        set: function (time) {\n\t            this._loopStart = this.toSeconds(time);\n\t        }\n\t    });\n\t    /**\n\t\t * The loop end time. \n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name loopEnd\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'loopEnd', {\n\t        get: function () {\n\t            return this._loopEnd;\n\t        },\n\t        set: function (time) {\n\t            this._loopEnd = this.toSeconds(time);\n\t        }\n\t    });\n\t    /**\n\t\t * The direction the buffer should play in\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {boolean}\n\t\t * @name reverse\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'reverse', {\n\t        get: function () {\n\t            return this.buffer.reverse;\n\t        },\n\t        set: function (rev) {\n\t            this.buffer.reverse = rev;\n\t        }\n\t    });\n\t    /**\n\t\t * The size of each chunk of audio that the \n\t\t * buffer is chopped into and played back at.\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name grainSize\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'grainSize', {\n\t        get: function () {\n\t            return this._grainSize;\n\t        },\n\t        set: function (size) {\n\t            this._grainSize = this.toSeconds(size);\n\t            this._clock.frequency.value = this._playbackRate / this._grainSize;\n\t        }\n\t    });\n\t    /**\n\t\t * This is the duration of the cross-fade between \n\t\t * sucessive grains.\n\t\t * @memberOf Tone.GrainPlayer#\n\t\t * @type {Time}\n\t\t * @name overlap\n\t\t */\n\t    Object.defineProperty(Tone.GrainPlayer.prototype, 'overlap', {\n\t        get: function () {\n\t            return this._overlap;\n\t        },\n\t        set: function (time) {\n\t            time = this.toSeconds(time);\n\t            this._overlap = time;\n\t            if (this._overlap < 0) {\n\t                this._player.fadeIn = 0.01;\n\t                this._player.fadeOut = 0.01;\n\t            } else {\n\t                this._player.fadeIn = time;\n\t                this._player.fadeOut = time;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Clean up\n\t\t * @return {Tone.GrainPlayer} this\n\t\t */\n\t    Tone.GrainPlayer.prototype.dispose = function () {\n\t        Tone.Source.prototype.dispose.call(this);\n\t        this.buffer.dispose();\n\t        this.buffer = null;\n\t        this._player.dispose();\n\t        this._player = null;\n\t        this._clock.dispose();\n\t        this._clock = null;\n\t        return this;\n\t    };\n\t    return Tone.GrainPlayer;\n\t});\n\tModule(function (Tone) {\n\t    \n\t    /**\n\t\t *  @class  Tone.UserMedia uses MediaDevices.getUserMedia to open up\n\t\t *          and external microphone or audio input. Check \n\t\t *          [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n\t\t *          to see which browsers are supported. Access to an external input\n\t\t *          is limited to secure (HTTPS) connections.\n\t\t *         \n\t\t *  @constructor\n\t\t *  @extends {Tone}\n\t\t *  @param {Decibels=} volume The level of the input\n\t\t *  @example\n\t\t * //list the inputs and open the third one\n\t\t * var motu = new Tone.UserMedia();\n\t\t * \n\t\t * //opening the input asks the user to activate their mic\n\t\t * motu.open().then(function(){\n\t\t * \t//opening is activates the microphone\n\t\t * \t//starting lets audio through\n\t\t * \tmotu.start(10);\n\t\t * });\n\t\t */\n\t    Tone.UserMedia = function () {\n\t        var options = this.optionsObject(arguments, ['volume'], Tone.UserMedia.defaults);\n\t        /**\n\t\t\t *  The MediaStreamNode \n\t\t\t *  @type {MediaStreamAudioSourceNode}\n\t\t\t *  @private\n\t\t\t */\n\t        this._mediaStream = null;\n\t        /**\n\t\t\t *  The media stream created by getUserMedia.\n\t\t\t *  @type {LocalMediaStream}\n\t\t\t *  @private\n\t\t\t */\n\t        this._stream = null;\n\t        /**\n\t\t\t *  The open device\n\t\t\t *  @type  {MediaDeviceInfo}\n\t\t\t *  @private\n\t\t\t */\n\t        this._device = null;\n\t        /**\n\t\t\t *  The output volume node\n\t\t\t *  @type  {Tone.Volume}\n\t\t\t *  @private\n\t\t\t */\n\t        this._volume = this.output = new Tone.Volume(options.volume);\n\t        /**\n\t\t\t * The volume of the output in decibels.\n\t\t\t * @type {Decibels}\n\t\t\t * @signal\n\t\t\t * @example\n\t\t\t * input.volume.value = -6;\n\t\t\t */\n\t        this.volume = this._volume.volume;\n\t        this._readOnly('volume');\n\t        this.mute = options.mute;\n\t    };\n\t    Tone.extend(Tone.UserMedia);\n\t    /**\n\t\t * the default parameters\n\t\t * @type {Object}\n\t\t */\n\t    Tone.UserMedia.defaults = {\n\t        'volume': 0,\n\t        'mute': false\n\t    };\n\t    /**\n\t\t *  Open the media stream. If a string is passed in, it is assumed\n\t\t *  to be the label or id of the stream, if a number is passed in,\n\t\t *  it is the input number of the stream.\n\t\t *  @param  {String|Number} [labelOrId=\"default\"] The label or id of the audio input media device. \n\t\t *                                                With no argument, the default stream is opened.\n\t\t *  @return {Promise} The promise is resolved when the stream is open.\n\t\t */\n\t    Tone.UserMedia.prototype.open = function (labelOrId) {\n\t        labelOrId = this.defaultArg(labelOrId, 'default');\n\t        return this.enumerateDevices().then(function (devices) {\n\t            var device;\n\t            if (this.isNumber(labelOrId)) {\n\t                device = devices[labelOrId];\n\t            } else {\n\t                device = devices.find(function (device) {\n\t                    return device.label === labelOrId || device.deviceId === labelOrId;\n\t                });\n\t                if (!device) {\n\t                    //otherwise just take the first one\n\t                    device = devices[0];\n\t                }\n\t            }\n\t            //didn't find a matching device\n\t            if (!device) {\n\t                throw new Error('Tone.UserMedia: no matching audio inputs.');\n\t            }\n\t            this._device = device;\n\t            //do getUserMedia\n\t            var constraints = {\n\t                audio: {\n\t                    'deviceId': device.deviceId,\n\t                    'echoCancellation': false,\n\t                    'sampleRate': this.context.sampleRate\n\t                }\n\t            };\n\t            return navigator.mediaDevices.getUserMedia(constraints).then(function (stream) {\n\t                //start a new source only if the previous one is closed\n\t                if (!this._stream) {\n\t                    this._stream = stream;\n\t                    //Wrap a MediaStreamSourceNode around the live input stream.\n\t                    this._mediaStream = this.context.createMediaStreamSource(stream);\n\t                    //Connect the MediaStreamSourceNode to a gate gain node\n\t                    this._mediaStream.connect(this.output);\n\t                }\n\t                return this;\n\t            }.bind(this));\n\t        }.bind(this));\n\t    };\n\t    /**\n\t\t *  Close the media stream\n\t\t *  @return {Tone.UserMedia} this\n\t\t */\n\t    Tone.UserMedia.prototype.close = function () {\n\t        if (this._stream) {\n\t            this._stream.getAudioTracks().forEach(function (track) {\n\t                track.stop();\n\t            });\n\t            this._stream = null;\n\t            //remove the old media stream\n\t            this._mediaStream.disconnect();\n\t            this._mediaStream = null;\n\t        }\n\t        this._device = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  Returns a promise which resolves with the list of audio input devices available.\n\t\t *  @return {Promise} The promise that is resolved with the devices\n\t\t *  @example\n\t\t * extInput.enumerateDevices().then(function(devices){\n\t\t * \tconsole.log(devices)\n\t\t * })\n\t\t */\n\t    Tone.UserMedia.prototype.enumerateDevices = function () {\n\t        return navigator.mediaDevices.enumerateDevices().then(function (devices) {\n\t            return devices.filter(function (device) {\n\t                return device.kind === 'audioinput';\n\t            });\n\t        });\n\t    };\n\t    /**\n\t\t *  Returns the playback state of the source, \"started\" when the microphone is open\n\t\t *  and \"stopped\" when the mic is closed.\n\t\t *  @type {Tone.State}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name state\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'state', {\n\t        get: function () {\n\t            return this._stream && this._stream.active ? Tone.State.Started : Tone.State.Stopped;\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns an identifier for the represented device that is \n\t\t * \tpersisted across sessions. It is un-guessable by other applications and \n\t\t * \tunique to the origin of the calling application. It is reset when the \n\t\t * \tuser clears cookies (for Private Browsing, a different identifier is \n\t\t * \tused that is not persisted across sessions). Returns undefined when the \n\t\t * \tdevice is not open.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name deviceId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'deviceId', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.deviceId;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns a group identifier. Two devices have the \n\t\t * \tsame group identifier if they belong to the same physical device.\n\t\t * \tReturns undefined when the device is not open.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name groupId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'groupId', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.groupId;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * \tReturns a label describing this device (for example \"Built-in Microphone\"). \n\t\t * \tReturns undefined when the device is not open or label is not available\n\t\t * \tbecause of permissions.\n\t\t *  @type {String}\n\t\t *  @readOnly\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name groupId\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'label', {\n\t        get: function () {\n\t            if (this._device) {\n\t                return this._device.label;\n\t            }\n\t        }\n\t    });\n\t    /**\n\t\t * Mute the output. \n\t\t * @memberOf Tone.UserMedia#\n\t\t * @type {boolean}\n\t\t * @name mute\n\t\t * @example\n\t\t * //mute the output\n\t\t * userMedia.mute = true;\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia.prototype, 'mute', {\n\t        get: function () {\n\t            return this._volume.mute;\n\t        },\n\t        set: function (mute) {\n\t            this._volume.mute = mute;\n\t        }\n\t    });\n\t    /**\n\t\t * Clean up.\n\t\t * @return {Tone.UserMedia} this\n\t\t */\n\t    Tone.UserMedia.prototype.dispose = function () {\n\t        Tone.prototype.dispose.call(this);\n\t        this.close();\n\t        this._writable('volume');\n\t        this._volume.dispose();\n\t        this._volume = null;\n\t        this.volume = null;\n\t        return this;\n\t    };\n\t    /**\n\t\t *  If getUserMedia is supported by the browser.\n\t\t *  @type  {Boolean}\n\t\t *  @memberOf Tone.UserMedia#\n\t\t *  @name supported\n\t\t *  @static\n\t\t *  @readOnly\n\t\t */\n\t    Object.defineProperty(Tone.UserMedia, 'supported', {\n\t        get: function () {\n\t            return !Tone.prototype.isUndef(navigator.mediaDevices) && Tone.prototype.isFunction(navigator.mediaDevices.getUserMedia);\n\t        }\n\t    });\n\t    return Tone.UserMedia;\n\t});\n\t\n\treturn Tone;\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tone/build/Tone.js\n// module id = 6\n// module chunks = 0","/* globals __VUE_SSR_CONTEXT__ */\n\n// this module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle\n\nmodule.exports = function normalizeComponent (\n  rawScriptExports,\n  compiledTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */\n) {\n  var esModule\n  var scriptExports = rawScriptExports = rawScriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof rawScriptExports.default\n  if (type === 'object' || type === 'function') {\n    esModule = rawScriptExports\n    scriptExports = rawScriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (compiledTemplate) {\n    options.render = compiledTemplate.render\n    options.staticRenderFns = compiledTemplate.staticRenderFns\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = injectStyles\n  }\n\n  if (hook) {\n    var functional = options.functional\n    var existing = functional\n      ? options.render\n      : options.beforeCreate\n    if (!functional) {\n      // inject component registration as beforeCreate hook\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    } else {\n      // register for functioal component in vue file\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return existing(h, context)\n      }\n    }\n  }\n\n  return {\n    esModule: esModule,\n    exports: scriptExports,\n    options: options\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/component-normalizer.js\n// module id = 7\n// module chunks = 0","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', {\n    attrs: {\n      \"id\": \"app\"\n    }\n  }, [_c('h1', [_vm._v(_vm._s(_vm.msg))]), _vm._v(\" \"), _vm._l((_vm.notes), function(note) {\n    return _c('div', [_c('a', {\n      attrs: {\n        \"tabindex\": \"note.id\"\n      },\n      on: {\n        \"click\": function($event) {\n          _vm.makeSound(note.value)\n        }\n      }\n    }, [_vm._v(_vm._s(note.text))])])\n  })], 2)\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-271881da\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/Main.vue\n// module id = 8\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/index.js!../node_modules/vue-loader/lib/style-compiler/index.js?{\\\"vue\\\":true,\\\"id\\\":\\\"data-v-271881da\\\",\\\"scoped\\\":false,\\\"hasInlineConfig\\\":false}!../node_modules/sass-loader/lib/loader.js!../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./Main.vue\");\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add the styles to the DOM\nvar update = require(\"!../node_modules/vue-style-loader/lib/addStylesClient.js\")(\"abec262e\", content, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader!./~/css-loader!./~/vue-loader/lib/style-compiler?{\"vue\":true,\"id\":\"data-v-271881da\",\"scoped\":false,\"hasInlineConfig\":false}!./~/sass-loader/lib/loader.js!./~/vue-loader/lib/selector.js?type=styles&index=0!./src/Main.vue\n// module id = 9\n// module chunks = 0","/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n  Modified by Evan You @yyx990803\n*/\n\nvar hasDocument = typeof document !== 'undefined'\n\nif (typeof DEBUG !== 'undefined' && DEBUG) {\n  if (!hasDocument) {\n    throw new Error(\n    'vue-style-loader cannot be used in a non-browser environment. ' +\n    \"Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.\"\n  ) }\n}\n\nvar listToStyles = require('./listToStyles')\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nvar stylesInDom = {/*\n  [id: number]: {\n    id: number,\n    refs: number,\n    parts: Array<(obj?: StyleObjectPart) => void>\n  }\n*/}\n\nvar head = hasDocument && (document.head || document.getElementsByTagName('head')[0])\nvar singletonElement = null\nvar singletonCounter = 0\nvar isProduction = false\nvar noop = function () {}\n\n// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n// tags it will allow on a page\nvar isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase())\n\nmodule.exports = function (parentId, list, _isProduction) {\n  isProduction = _isProduction\n\n  var styles = listToStyles(parentId, list)\n  addStylesToDom(styles)\n\n  return function update (newList) {\n    var mayRemove = []\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i]\n      var domStyle = stylesInDom[item.id]\n      domStyle.refs--\n      mayRemove.push(domStyle)\n    }\n    if (newList) {\n      styles = listToStyles(parentId, newList)\n      addStylesToDom(styles)\n    } else {\n      styles = []\n    }\n    for (var i = 0; i < mayRemove.length; i++) {\n      var domStyle = mayRemove[i]\n      if (domStyle.refs === 0) {\n        for (var j = 0; j < domStyle.parts.length; j++) {\n          domStyle.parts[j]()\n        }\n        delete stylesInDom[domStyle.id]\n      }\n    }\n  }\n}\n\nfunction addStylesToDom (styles /* Array<StyleObject> */) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var domStyle = stylesInDom[item.id]\n    if (domStyle) {\n      domStyle.refs++\n      for (var j = 0; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j])\n      }\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j]))\n      }\n      if (domStyle.parts.length > item.parts.length) {\n        domStyle.parts.length = item.parts.length\n      }\n    } else {\n      var parts = []\n      for (var j = 0; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j]))\n      }\n      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }\n    }\n  }\n}\n\nfunction createStyleElement () {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  head.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */) {\n  var update, remove\n  var styleElement = document.querySelector('style[data-vue-ssr-id~=\"' + obj.id + '\"]')\n\n  if (styleElement) {\n    if (isProduction) {\n      // has SSR styles and in production mode.\n      // simply do nothing.\n      return noop\n    } else {\n      // has SSR styles but in dev mode.\n      // for some reason Chrome can't handle source map in server-rendered\n      // style tags - source maps in <style> only works if the style tag is\n      // created and inserted dynamically. So we remove the server rendered\n      // styles and inject new ones.\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  if (isOldIE) {\n    // use singleton mode for IE9.\n    var styleIndex = singletonCounter++\n    styleElement = singletonElement || (singletonElement = createStyleElement())\n    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)\n    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)\n  } else {\n    // use multi-style-tag mode in all other cases\n    styleElement = createStyleElement()\n    update = applyToTag.bind(null, styleElement)\n    remove = function () {\n      styleElement.parentNode.removeChild(styleElement)\n    }\n  }\n\n  update(obj)\n\n  return function updateStyle (newObj /* StyleObjectPart */) {\n    if (newObj) {\n      if (newObj.css === obj.css &&\n          newObj.media === obj.media &&\n          newObj.sourceMap === obj.sourceMap) {\n        return\n      }\n      update(obj = newObj)\n    } else {\n      remove()\n    }\n  }\n}\n\nvar replaceText = (function () {\n  var textStore = []\n\n  return function (index, replacement) {\n    textStore[index] = replacement\n    return textStore.filter(Boolean).join('\\n')\n  }\n})()\n\nfunction applyToSingletonTag (styleElement, index, remove, obj) {\n  var css = remove ? '' : obj.css\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = replaceText(index, css)\n  } else {\n    var cssNode = document.createTextNode(css)\n    var childNodes = styleElement.childNodes\n    if (childNodes[index]) styleElement.removeChild(childNodes[index])\n    if (childNodes.length) {\n      styleElement.insertBefore(cssNode, childNodes[index])\n    } else {\n      styleElement.appendChild(cssNode)\n    }\n  }\n}\n\nfunction applyToTag (styleElement, obj) {\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/addStylesClient.js\n// module id = 10\n// module chunks = 0","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nmodule.exports = function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-style-loader/lib/listToStyles.js\n// module id = 11\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}